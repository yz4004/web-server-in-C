From do.not.reply@cloud.cs.columbia.edu Sun Jan 30 10:28:01 2022
Date: Sun, 30 Jan 2022 10:28:01 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab1.mbox
Message-ID: <20220130152801.GA26813@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="k1lZvvs/B4yU6o8G"
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 2519
Lines: 79


--k1lZvvs/B4yU6o8G
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 8d403828a464b9109e6ac579efac3f76ce31516a Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sun, 30 Jan 2022 10:24:48 -0500
Subject: [PATCH] Modified README

---
 README.txt | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index fd2e560..b4545fc 100644
--- a/README.txt
+++ b/README.txt
@@ -15,6 +15,17 @@ implemented or how you tried to fix your non-working code.
 
 Please answer the academic honesty questions.
 
+Yixuan Zou
+yz4004
+lab1 
+
+[1] yes
+[2] yes
+[3] yes
+[4] no yes yes 
+[5] yes
+[6] yes
+[7] yes
 
 
 --------------------------------------------------------------------------
@@ -25,12 +36,12 @@ Part 0
 Please write your answers after [ANSWER] on the same line.  Our auto-grading
 script will look for lines that contain [ANSWER].
 
-[0.1][ANSWER] 
+[0.1][ANSWER] git init
 
-[0.2][ANSWER] 
+[0.2][ANSWER] git clone
 
-[0.3][ANSWER] 
+[0.3][ANSWER] git checkout -- filename
 
-[0.4][ANSWER] 
+[0.4][ANSWER] git reset HEAD filename
 
 
-- 
2.17.1


--k1lZvvs/B4yU6o8G
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab1.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 8d403828a464b9109e6ac579efac3f76ce31516a Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sun, 30 Jan 2022 10:24:48 =
-0500=0ASubject: [PATCH] Modified README=0A=0A---=0A README.txt | 19 ++++++=
+++++++++----=0A 1 file changed, 15 insertions(+), 4 deletions(-)=0A=0Adiff=
 --git a/README.txt b/README.txt=0Aindex fd2e560..b4545fc 100644=0A--- a/RE=
ADME.txt=0A+++ b/README.txt=0A@@ -15,6 +15,17 @@ implemented or how you tri=
ed to fix your non-working code.=0A =0A Please answer the academic honesty =
questions.=0A =0A+Yixuan Zou=0A+yz4004=0A+lab1 =0A+=0A+[1] yes=0A+[2] yes=
=0A+[3] yes=0A+[4] no yes yes =0A+[5] yes=0A+[6] yes=0A+[7] yes=0A =0A =0A =
--------------------------------------------------------------------------=
=0A@@ -25,12 +36,12 @@ Part 0=0A Please write your answers after [ANSWER] o=
n the same line.  Our auto-grading=0A script will look for lines that conta=
in [ANSWER].=0A =0A-[0.1][ANSWER] =0A+[0.1][ANSWER] git init=0A =0A-[0.2][A=
NSWER] =0A+[0.2][ANSWER] git clone=0A =0A-[0.3][ANSWER] =0A+[0.3][ANSWER] g=
it checkout -- filename=0A =0A-[0.4][ANSWER] =0A+[0.4][ANSWER] git reset HE=
AD filename=0A =0A =0A-- =0A2.17.1=0A=0A
--k1lZvvs/B4yU6o8G--

From do.not.reply@cloud.cs.columbia.edu Sat Feb  5 11:21:14 2022
Date: Sat, 5 Feb 2022 11:21:14 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab1.mbox
Message-ID: <20220205162114.GA26950@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="nFreZHaLTZJo0R7j"
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 58835
Lines: 1322


--nFreZHaLTZJo0R7j
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 8d403828a464b9109e6ac579efac3f76ce31516a Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sun, 30 Jan 2022 10:24:48 -0500
Subject: [PATCH 1/5] Modified README

---
 README.txt | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index fd2e560..b4545fc 100644
--- a/README.txt
+++ b/README.txt
@@ -15,6 +15,17 @@ implemented or how you tried to fix your non-working code.
 
 Please answer the academic honesty questions.
 
+Yixuan Zou
+yz4004
+lab1 
+
+[1] yes
+[2] yes
+[3] yes
+[4] no yes yes 
+[5] yes
+[6] yes
+[7] yes
 
 
 --------------------------------------------------------------------------
@@ -25,12 +36,12 @@ Part 0
 Please write your answers after [ANSWER] on the same line.  Our auto-grading
 script will look for lines that contain [ANSWER].
 
-[0.1][ANSWER] 
+[0.1][ANSWER] git init
 
-[0.2][ANSWER] 
+[0.2][ANSWER] git clone
 
-[0.3][ANSWER] 
+[0.3][ANSWER] git checkout -- filename
 
-[0.4][ANSWER] 
+[0.4][ANSWER] git reset HEAD filename
 
 
-- 
2.17.1


From e1cdb3cd3df5659f104ae6889ac3db19f3f9f59a Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 31 Jan 2022 17:06:23 -0500
Subject: [PATCH 2/5] finishing part1

---
 part1/.Makefile.un~ | Bin 0 -> 9425 bytes
 part1/.gcc.c.un~    | Bin 0 -> 6274 bytes
 part1/.gcd.h.un~    | Bin 0 -> 523 bytes
 part1/.main.c.un~   | Bin 0 -> 50440 bytes
 part1/.prime.c.un~  | Bin 0 -> 22781 bytes
 part1/.prime.h.un~  | Bin 0 -> 1048 bytes
 part1/Makefile      |  81 ++++++++++++++++++++++++++++++++++++++++++++
 part1/Makefile~     |  78 ++++++++++++++++++++++++++++++++++++++++++
 part1/gcd.c         |  12 +++++++
 part1/gcd.h         |   1 +
 part1/main.c        |  27 +++++++++++++++
 part1/main.c~       |  27 +++++++++++++++
 part1/prime.c       |  15 ++++++++
 part1/prime.c~      |  14 ++++++++
 part1/prime.h       |   1 +
 part1/prime.h~      |   1 +
 16 files changed, 257 insertions(+)
 create mode 100644 part1/.Makefile.un~
 create mode 100644 part1/.gcc.c.un~
 create mode 100644 part1/.gcd.h.un~
 create mode 100644 part1/.main.c.un~
 create mode 100644 part1/.prime.c.un~
 create mode 100644 part1/.prime.h.un~
 create mode 100644 part1/Makefile
 create mode 100644 part1/Makefile~
 create mode 100644 part1/gcd.c
 create mode 100644 part1/gcd.h
 create mode 100644 part1/main.c
 create mode 100644 part1/main.c~
 create mode 100644 part1/prime.c
 create mode 100644 part1/prime.c~
 create mode 100644 part1/prime.h
 create mode 100644 part1/prime.h~

diff --git a/part1/.Makefile.un~ b/part1/.Makefile.un~
new file mode 100644
index 0000000000000000000000000000000000000000..40abf99e45af50cb2fe22d662d2742353fb179a0
GIT binary patch
literal 9425
zcmeI2OKVd>6vuBKCe}ymqpcMQjtZsLCcC1hDiy@K@PR@^L6qxlYzs-Q1YHPj>R$94
z2!b1Rp({5P{RqXK&|MMn1Bls(p8uIS;WR=)>A0E$r!%=pGl%ozKQm`0R~MSkYOOQr
zmneJf@ygrWhx*d<nf#~b!$<E|_Z@sab$fMsDE_(kdZsoVMbTyQQZrs?Rnn^AHZgbG
z3(b0E-k7;$wlYs2I7YsQJVQQ24nr#*#hoip^LV!y-CD-GWLewrU%Ulp`$ZPz<W*=l
zJ_GTO&Ns%9iN25Yd_7~BTx3k>YY;$on0y!hhcR`b;YqNK%|P54eZiO_i)oC$ew_RQ
zITAkzJvvpUruiVAovow}9Z==T#efkq9mIox4q5PNgzk+-ca#P@PA=$%d!|$iZ{EQJ
ztW7FBfILAyjAsEJvf$GQ-a8F%iUvDLF7QU2)JS@)xx}@C54Z{{K%fLZMjG&`%y{V%
zzNNpz=QcD>eZW*ykpU&}_2XH<hb;Is!neFGK1&PRQK!DO_<(D(3J@rv+<;Fd#b1~3
ztuVf<-L#xnLt)c05H}iClQimai|Yv|I#B9U9|ge~awZu>r!wQE8+Rt!Of6@rouyIE
zk;{^Iz&L9+P5F))ucRifr1$TcByHC<NATLBLIhLnS=j<d$%L<#IDXWVC#tn0<ias>
zas!sFDhMFM{**0Xl1%t&3Dakd36)uuycZL&Y*Rr18MY!^v<FNoGhVuJryMb+yqy(M
z2%I7pOe5W`i0yQb#+=H4YrBdJD50`Y$El?F>k_^-=O?1Fi!>y*BBpOHNlcl_H=J*F
z;h8cWrtpcU!w77=dvu`!De6HSd4_@jN$_ff@fEAEU{#0-5GoXmqk^$Vgr?k}%}VNy
ztL0z}@CH=80E<;}H=czl6<P3UbQ4g}E8iFmhW(+yTzjVJ=2xdfpxU8=14f_=XPPQ0
z{<?&&_^;@IYNrYf7=b;gP9?=(m(cZVbW#?G>h|*#Y8O43FJ=0~Qzt-B<GUXhDTrcG
z4f`3F5WfvkENO~zsUQ@4FBR<UDW}qa#d32&0wmy-@H#Af$bwHJc(wK59kS~C<B}bB
z?8$_^YIiaOIbQQzyr7B=5nCWBnef#T$s3v^N`Yx|k)fQi0E_$@g1U?>U_vJTixH-q
yy_inZ$d|}b{Rt+mBs>N(%!{GALpHn{VS2)tinh9wMGZeZ0;ctUd^EZE_2qAYD1tu#

literal 0
HcmV?d00001

diff --git a/part1/.gcc.c.un~ b/part1/.gcc.c.un~
new file mode 100644
index 0000000000000000000000000000000000000000..0e2cb31747bf57b6be7201734c3dfb41dac3a6dd
GIT binary patch
literal 6274
zcmeI$J!lj`6u|Ml%NgU>5v{Dk6biXQF3lmLv63{xX``(y<{}4r2}dG#rqC1tJFOIK
z1i{84V42F!%EHRhMkHV_E?DUM&&^w37EG1t=E2^~?F@Uv`|)P?_ICfl>sy0stKYNw
zt6zIxK7P13cj4)??wN0M&)=_p-Ffok^3v{`e0S~brCye0C*{y+N~b0VEkUbCmKQf)
zHW;mCcRn*JQJ*yab21c8{E^6}%xLN!at88Z;hg8lvY%%w*M=hNY<VX776LLq&K%EF
ze&bAv!_7cmEd8!B!BH{<CcZb!Pcx@vOH3v+QM!3?{gY*?ZfsgjkQ^~9fUIOoOeQl?
zx_Qyvu}o}TN&wkZyY2X4zawf%;Z=J25mjWw?|z{Oxzw~A8jPnR)NDj=^Ww&|)#V43
zU_T&ezyS7NcLuF4mpUqk2GV|<6RCDJEwNhB?NoKO5G@ldGiDKxLFdmUCX<;cU1924
zCaQ?kYqiYu2kY+M-R1ePXTo#Ltc1C6o#I^LA`3A?xYnv%T0vA*Q@LnIt$+s7akDG{
z%dIh?nao7#3fe=9M!i4)3%9e{rhH5uV$_l$yGt_t1hYb*sdvLvcAAxFt-K5wT0y;$
z!2(mg-43M&jD5!f8c@FcQmIKMqJ}^{ItXf3{xK}~R`QMevOT&hZXDQP^0%<CItbYz
z{j0IW7P1np5w^#cO}9a<ucnjeugs6!RX1+AfCiEW3hM$8H0mvFiX<Uw2-@~RXbsQ;
zm8~rn1snIcR9|ExdI;4EPgVQ(m_hYWUp#@F4)x{6=SOaF(Ji!Cl7D%k5B&Q|k?F(U
M`o?h3+1h*e7vFZfQ2+n{

literal 0
HcmV?d00001

diff --git a/part1/.gcd.h.un~ b/part1/.gcd.h.un~
new file mode 100644
index 0000000000000000000000000000000000000000..737b358ce4b56cfe44896aa11d6b7b89df3da8bb
GIT binary patch
literal 523
zcmWH`%$*;a=aT=Ffl2nx)lbvvW7qrb>s^o=D9kp|UvJyyOF>(BriR=&_s!%I0|Nsi
z5Q6|Rjm`%16MqE!WdX4m8R9R1wV)CZDX7?gAYfodRWQn<W(WYI;}0}CzDl4O4300;
H#^<X5H+v%E

literal 0
HcmV?d00001

diff --git a/part1/.main.c.un~ b/part1/.main.c.un~
new file mode 100644
index 0000000000000000000000000000000000000000..5dd52d42967691a723ed268861e5456b74b955a4
GIT binary patch
literal 50440
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

literal 0
HcmV?d00001

diff --git a/part1/.prime.c.un~ b/part1/.prime.c.un~
new file mode 100644
index 0000000000000000000000000000000000000000..2e47e260ddc1425d59ae1577ffceb66bf7e3a77f
GIT binary patch
literal 22781
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

literal 0
HcmV?d00001

diff --git a/part1/.prime.h.un~ b/part1/.prime.h.un~
new file mode 100644
index 0000000000000000000000000000000000000000..5fa40bad6cd8ef58f6c08b46a7fb4ba2615ea557
GIT binary patch
literal 1048
zcmWH`%$*;a=aT=Ffys7io-DUma8g&`5s&nl7v|Wmd=|1Lo^f*bl4$#|zuROP7#J9V
zST-p?KPNRYPoX>`wIn08D88U5GdEQuGp|IULem<mh#g8Z0cj8b(J;)A_(N5f1!NQx
zL;MAhED*pHg4iG_5C(()K)}EZ<BihP4}ruV3LN0*U}X3zfo42BTEH^!NCBz>voS;&
xOdG*bimVc3B*+|)7${vZfTI*$1xR8PP$>j}IZOwd!!V*06!7@-uxaD-RRCK&KK}p!

literal 0
HcmV?d00001

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..51400fa
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,81 @@
+# This Makefile should be used as a template for future Makefiles.
+# It's heavily commented, so hopefully you can understand what each
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+# Linking options:
+# -g for debugging info
+
+LDFLAGS = -g
+
+# List the libraries you need to link with in LDLIBS
+# For example, use "-lm" for the math library
+
+LDLIBS =
+
+# The 1st target gets built when you type "make".
+# It's usually your executable.  ("main" in this case.)
+#
+# Note that we did not specify the linking rule.
+# Instead, we rely on one of make's implicit rules:
+#
+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)
+#
+# Also note that make assumes that main depends on main.o,
+# so we can omit it if we want to.
+
+main: main.o prime.o gcd.o
+	gcc main.o prime.o gcd.o -lm -o main
+# main.o depends not only on main.c, but also on myadd.h because
+# main.c includes myadd.h.  main.o will get recompiled if either
+# main.c or myadd.h get modified.
+#
+# make already knows main.o depends on main.c, so we can omit main.c
+# in the dependency list if we want to.
+#
+# make uses the following implicit rule to compile a .c file into a .o
+# file:
+#
+#     $(CC) -c $(CFLAGS) <the-.c-file>
+#
+
+main.o: main.c prime.h gcd.h
+	gcc -c main.c -o main.o
+# And myadd.o depends on myadd.c and myadd.h.
+
+prime.o: prime.c prime.h
+	gcc -c prime.c -lm -o prime.o
+
+gcd.o: gcd.c gcd.h
+	gcc -c gcd.c -o gcd.o
+
+# Always provide the "clean" target that removes intermediate files.
+# What you remove depend on your choice of coding tools
+# (different editors generate different backup files for example).
+#
+# And the "clean" target is not a file name, so we tell make that
+# it's a "phony" target.
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
diff --git a/part1/Makefile~ b/part1/Makefile~
new file mode 100644
index 0000000..28f46ba
--- /dev/null
+++ b/part1/Makefile~
@@ -0,0 +1,78 @@
+# This Makefile should be used as a template for future Makefiles.
+# It's heavily commented, so hopefully you can understand what each
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+# Linking options:
+# -g for debugging info
+
+LDFLAGS = -g
+
+# List the libraries you need to link with in LDLIBS
+# For example, use "-lm" for the math library
+
+LDLIBS =
+
+# The 1st target gets built when you type "make".
+# It's usually your executable.  ("main" in this case.)
+#
+# Note that we did not specify the linking rule.
+# Instead, we rely on one of make's implicit rules:
+#
+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)
+#
+# Also note that make assumes that main depends on main.o,
+# so we can omit it if we want to.
+
+main: main.o prime.o
+	gcc main.o prime.o -lm -o main
+# main.o depends not only on main.c, but also on myadd.h because
+# main.c includes myadd.h.  main.o will get recompiled if either
+# main.c or myadd.h get modified.
+#
+# make already knows main.o depends on main.c, so we can omit main.c
+# in the dependency list if we want to.
+#
+# make uses the following implicit rule to compile a .c file into a .o
+# file:
+#
+#     $(CC) -c $(CFLAGS) <the-.c-file>
+#
+
+main.o: main.c prime.h
+	gcc -c main.c -o main.o
+# And myadd.o depends on myadd.c and myadd.h.
+
+prime.o: prime.c prime.h
+	gcc -c prime.c -lm -o prime.o
+
+# Always provide the "clean" target that removes intermediate files.
+# What you remove depend on your choice of coding tools
+# (different editors generate different backup files for example).
+#
+# And the "clean" target is not a file name, so we tell make that
+# it's a "phony" target.
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
diff --git a/part1/gcd.c b/part1/gcd.c
new file mode 100644
index 0000000..7cbe5bc
--- /dev/null
+++ b/part1/gcd.c
@@ -0,0 +1,12 @@
+
+#include "gcd.h"
+//
+// default input x < y
+int gcd(int x, int y)
+{
+    if( y%x == 0)
+        return x;
+    else
+        return gcd( y%x, x);
+}
+
diff --git a/part1/gcd.h b/part1/gcd.h
new file mode 100644
index 0000000..1e829c9
--- /dev/null
+++ b/part1/gcd.h
@@ -0,0 +1 @@
+int gcd(int x, int y);
diff --git a/part1/main.c b/part1/main.c
new file mode 100644
index 0000000..c012227
--- /dev/null
+++ b/part1/main.c
@@ -0,0 +1,27 @@
+#include <stdio.h>
+#include "prime.h"
+#include "gcd.h"
+int main()
+{
+    int x,y ;
+
+    printf("please input two positive integers: ");
+    scanf("%d%d", &x,&y );
+    printf("You typed in %d and %d\n", x, y);
+    printf("your input average is %f\n",( ((float) x)+ ((float) y ) )/2);  
+        
+    if(whether_prime(x) == 1) 
+        printf("%d is prime\n", x);
+    else
+        printf("%d is not prime\n",x);
+    
+    if(whether_prime(y) == 1)
+        printf("%d is prime\n", y);
+    else
+        printf("%d is not prime\n", y);
+    
+    printf("The gcd of %d, %d is %d\n", x,y,gcd(x,y));
+    
+
+    return 0;
+}
diff --git a/part1/main.c~ b/part1/main.c~
new file mode 100644
index 0000000..677781a
--- /dev/null
+++ b/part1/main.c~
@@ -0,0 +1,27 @@
+#include <stdio.h>
+#include "prime.h"
+#include "gcd.h"
+int main()
+{
+    int x,y ;
+
+    printf("please input two positive integers: ");
+    scanf("%d%d", &x,&y );
+    printf("You typed in %d and %d\n", x, y);
+    printf("your input average is %f\n",( ((float) x)+ ((float) y ) )/2);  
+        
+    if(whether_prime(x) == 1) 
+        printf("%d is prime\n", x);
+    else
+        printf("%d is not prime\n",x);
+    
+    if(whether_prime(y) == 1)
+        printf("%d is prime\n", y);
+    else
+        printf("%d is not prime\n", y);
+    
+    printf("The gcd of %d, %d is %d", x,y,gcd(x,y));
+    
+
+    return 0;
+}
diff --git a/part1/prime.c b/part1/prime.c
new file mode 100644
index 0000000..fb55efc
--- /dev/null
+++ b/part1/prime.c
@@ -0,0 +1,15 @@
+#include "prime.h"
+#include <math.h>
+
+int  whether_prime(int x)
+{
+    if(x == 1) return 0;
+    float y = (float) x;
+    y = sqrt(y);
+
+    for(int i=2; i<=y; i++){
+        if( x%i == 0)  return 0;
+        // 0 indicates x is not prime
+    }
+    return 1;
+}    
diff --git a/part1/prime.c~ b/part1/prime.c~
new file mode 100644
index 0000000..a75e52e
--- /dev/null
+++ b/part1/prime.c~
@@ -0,0 +1,14 @@
+#include "prime.h"
+#include <math.h>
+
+int  whether_prime(int x)
+{
+    float y = (float) x;
+    y = sqrt(y);
+
+    for(int i=2; i<=y; i++){
+        if( x%i == 0)  return 0;
+        // 0 indicates x is not prime
+    }
+    return 1;
+}    
diff --git a/part1/prime.h b/part1/prime.h
new file mode 100644
index 0000000..eafd030
--- /dev/null
+++ b/part1/prime.h
@@ -0,0 +1 @@
+int  whether_prime(int x);
diff --git a/part1/prime.h~ b/part1/prime.h~
new file mode 100644
index 0000000..4763068
--- /dev/null
+++ b/part1/prime.h~
@@ -0,0 +1 @@
+boolean whether_prime(int x);
-- 
2.17.1


From 9ca8ea32cb49b3cdcb5e33d424235621ccb7c254 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 5 Feb 2022 10:51:36 -0500
Subject: [PATCH 3/5] Finishing part2

---
 part2/Makefile  |  39 ++++++++++++++++++
 part2/convert.c | 104 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 143 insertions(+)
 create mode 100644 part2/Makefile
 create mode 100644 part2/convert.c

diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..cd1a2e8
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,39 @@
+# This Makefile should be used as a template for future Makefiles.
+# It's heavily commented, so hopefully you can understand what each
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+
+LDFLAGS = -g
+
+LDLIBS =
+
+
+convert:  convert.o
+
+convert.o: convert.c
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
diff --git a/part2/convert.c b/part2/convert.c
new file mode 100644
index 0000000..e2159f8
--- /dev/null
+++ b/part2/convert.c
@@ -0,0 +1,104 @@
+#include <stdio.h>
+
+int convert_binary(int x);
+
+int convert(){    
+    int x;    
+    scanf("%d",&x);
+    printf("signed dec:   %d\n", x);
+    printf("unsigned dec: %u\n", x);
+    printf("hex:          %x\n", x);
+    convert_binary(x);
+    return 0; 
+}
+
+int convert_binary(int x){    
+
+    
+
+    char output[39] ={0};
+    int i;
+    int mask = 1;	
+    for (i=38; i>-1; i--) {  
+        if( ((i+1)%5 == 0) && i != 0 ){
+            output[i] = ' ';
+        }else{
+
+            if(x& mask){
+                output[i] = '1';
+            }else{
+           
+                output[i] = '0';
+            }
+            mask <<= 1;
+        }
+                
+                
+    } 
+    printf("binary:       %s\n", output);
+
+    return 0;
+}
+
+int main()
+{
+    convert();
+
+    return 0;
+}
+
+/*
+int convert_binary(int x )
+{
+    //int x;
+    int tens = 1;
+    int result = 0;
+   while(x/2 != 0){
+        
+       result += x%2 * tens;
+       tens *= 10;
+       x = x/2;
+   }
+   // x = 0/1 after while
+   result += x%2 * tens;  
+
+   return result;
+}
+
+int convert_binary_rec(int x, int mask);
+
+int convert_binary(int x){
+    
+    if((x < 2)& (x>-2)){
+        printf("%d",x);
+        return 0;
+    }
+
+    // I wnat to know the size of mask
+    int mask = 1;
+    int y =x;
+       
+    while(y > 1){
+        printf("%d",mask);
+        y /= 2;
+        mask *= 2;
+    }
+    convert_binary_rec(x, mask);
+    return 0; 
+
+}
+
+int convert_binary_rec(int x, int mask){
+        
+    if((x == 0) | (mask == 0) ) return 0;
+    
+
+    if( (x & mask) == 0) {
+        printf("%d",0);
+    }else{
+        printf("%d",1);
+    }
+    convert_binary_rec(x&(mask-1), mask/2);
+    return 0;
+}
+*/
-- 
2.17.1


From d92afdab2662a43d85220e2c96a46654d2e9ccc9 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 5 Feb 2022 11:08:24 -0500
Subject: [PATCH 4/5] Add reference in README.txt, change printed prompt in
 part1 main.c

---
 README.txt   | 7 +++++++
 part1/main.c | 2 +-
 2 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/README.txt b/README.txt
index b4545fc..97f0c99 100644
--- a/README.txt
+++ b/README.txt
@@ -45,3 +45,10 @@ script will look for lines that contain [ANSWER].
 [0.4][ANSWER] git reset HEAD filename
 
 
+
+
+--------------------------------------------------------------------------
+Reference
+
+For part1, Euclidean Algorithm, I referred to this article:
+https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/the-euclidean-algorithm
diff --git a/part1/main.c b/part1/main.c
index c012227..5164695 100644
--- a/part1/main.c
+++ b/part1/main.c
@@ -8,7 +8,7 @@ int main()
     printf("please input two positive integers: ");
     scanf("%d%d", &x,&y );
     printf("You typed in %d and %d\n", x, y);
-    printf("your input average is %f\n",( ((float) x)+ ((float) y ) )/2);  
+    printf("The average is %f\n",( ((float) x)+ ((float) y ) )/2);  
         
     if(whether_prime(x) == 1) 
         printf("%d is prime\n", x);
-- 
2.17.1


From 465228ca078637d2d7df3504dfc6d70ecd65d653 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 5 Feb 2022 11:18:56 -0500
Subject: [PATCH 5/5] delete unnecessary building code (recursive method) in
 convert.c

---
 part2/convert.c | 55 -------------------------------------------------
 1 file changed, 55 deletions(-)

diff --git a/part2/convert.c b/part2/convert.c
index e2159f8..a6b6240 100644
--- a/part2/convert.c
+++ b/part2/convert.c
@@ -47,58 +47,3 @@ int main()
     return 0;
 }
 
-/*
-int convert_binary(int x )
-{
-    //int x;
-    int tens = 1;
-    int result = 0;
-   while(x/2 != 0){
-        
-       result += x%2 * tens;
-       tens *= 10;
-       x = x/2;
-   }
-   // x = 0/1 after while
-   result += x%2 * tens;  
-
-   return result;
-}
-
-int convert_binary_rec(int x, int mask);
-
-int convert_binary(int x){
-    
-    if((x < 2)& (x>-2)){
-        printf("%d",x);
-        return 0;
-    }
-
-    // I wnat to know the size of mask
-    int mask = 1;
-    int y =x;
-       
-    while(y > 1){
-        printf("%d",mask);
-        y /= 2;
-        mask *= 2;
-    }
-    convert_binary_rec(x, mask);
-    return 0; 
-
-}
-
-int convert_binary_rec(int x, int mask){
-        
-    if((x == 0) | (mask == 0) ) return 0;
-    
-
-    if( (x & mask) == 0) {
-        printf("%d",0);
-    }else{
-        printf("%d",1);
-    }
-    convert_binary_rec(x&(mask-1), mask/2);
-    return 0;
-}
-*/
-- 
2.17.1


--nFreZHaLTZJo0R7j
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab1.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 8d403828a464b9109e6ac579efac3f76ce31516a Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sun, 30 Jan 2022 10:24:48 =
-0500=0ASubject: [PATCH 1/5] Modified README=0A=0A---=0A README.txt | 19 ++=
+++++++++++++----=0A 1 file changed, 15 insertions(+), 4 deletions(-)=0A=0A=
diff --git a/README.txt b/README.txt=0Aindex fd2e560..b4545fc 100644=0A--- =
a/README.txt=0A+++ b/README.txt=0A@@ -15,6 +15,17 @@ implemented or how you=
 tried to fix your non-working code.=0A =0A Please answer the academic hone=
sty questions.=0A =0A+Yixuan Zou=0A+yz4004=0A+lab1 =0A+=0A+[1] yes=0A+[2] y=
es=0A+[3] yes=0A+[4] no yes yes =0A+[5] yes=0A+[6] yes=0A+[7] yes=0A =0A =
=0A -----------------------------------------------------------------------=
---=0A@@ -25,12 +36,12 @@ Part 0=0A Please write your answers after [ANSWER=
] on the same line.  Our auto-grading=0A script will look for lines that co=
ntain [ANSWER].=0A =0A-[0.1][ANSWER] =0A+[0.1][ANSWER] git init=0A =0A-[0.2=
][ANSWER] =0A+[0.2][ANSWER] git clone=0A =0A-[0.3][ANSWER] =0A+[0.3][ANSWER=
] git checkout -- filename=0A =0A-[0.4][ANSWER] =0A+[0.4][ANSWER] git reset=
 HEAD filename=0A =0A =0A-- =0A2.17.1=0A=0A=0AFrom e1cdb3cd3df5659f104ae688=
9ac3db19f3f9f59a Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columb=
ia.edu>=0ADate: Mon, 31 Jan 2022 17:06:23 -0500=0ASubject: [PATCH 2/5] fini=
shing part1=0A=0A---=0A part1/.Makefile.un~ | Bin 0 -> 9425 bytes=0A part1/=
=2Egcc.c.un~    | Bin 0 -> 6274 bytes=0A part1/.gcd.h.un~    | Bin 0 -> 523=
 bytes=0A part1/.main.c.un~   | Bin 0 -> 50440 bytes=0A part1/.prime.c.un~ =
 | Bin 0 -> 22781 bytes=0A part1/.prime.h.un~  | Bin 0 -> 1048 bytes=0A par=
t1/Makefile      |  81 ++++++++++++++++++++++++++++++++++++++++++++=0A part=
1/Makefile~     |  78 ++++++++++++++++++++++++++++++++++++++++++=0A part1/g=
cd.c         |  12 +++++++=0A part1/gcd.h         |   1 +=0A part1/main.c  =
      |  27 +++++++++++++++=0A part1/main.c~       |  27 +++++++++++++++=0A=
 part1/prime.c       |  15 ++++++++=0A part1/prime.c~      |  14 ++++++++=
=0A part1/prime.h       |   1 +=0A part1/prime.h~      |   1 +=0A 16 files =
changed, 257 insertions(+)=0A create mode 100644 part1/.Makefile.un~=0A cre=
ate mode 100644 part1/.gcc.c.un~=0A create mode 100644 part1/.gcd.h.un~=0A =
create mode 100644 part1/.main.c.un~=0A create mode 100644 part1/.prime.c.u=
n~=0A create mode 100644 part1/.prime.h.un~=0A create mode 100644 part1/Mak=
efile=0A create mode 100644 part1/Makefile~=0A create mode 100644 part1/gcd=
=2Ec=0A create mode 100644 part1/gcd.h=0A create mode 100644 part1/main.c=
=0A create mode 100644 part1/main.c~=0A create mode 100644 part1/prime.c=0A=
 create mode 100644 part1/prime.c~=0A create mode 100644 part1/prime.h=0A c=
reate mode 100644 part1/prime.h~=0A=0Adiff --git a/part1/.Makefile.un~ b/pa=
rt1/.Makefile.un~=0Anew file mode 100644=0Aindex 00000000000000000000000000=
00000000000000..40abf99e45af50cb2fe22d662d2742353fb179a0=0AGIT binary patch=
=0Aliteral 9425=0AzcmeI2OKVd>6vuBKCe}ymqpcMQjtZsLCcC1hDiy@K@PR@^L6qxlYzs-Q1=
YHPj>R$94=0Az2!b1Rp({5P{RqXK&|MMn1Bls(p8uIS;WR=3D)>A0E$r!%=3DpGl%ozKQm`0R~M=
SkYOOQr=0AzmneJf@ygrWhx*d<nf#~b!$<E|_Z@sab$fMsDE_(kdZsoVMbTyQQZrs?Rnn^AHZgb=
G=0Az3(b0E-k7;$wlYs2I7YsQJVQQ24nr#*#hoip^LV!y-CD-GWLewrU%Ulp`$ZPz<W*=3Dl=0A=
zJ_GTO&Ns%9iN25Yd_7~BTx3k>YY;$on0y!hhcR`b;YqNK%|P54eZiO_i)oC$ew_RQ=0AzITAkz=
JvvpUruiVAovow}9Z=3D=3DT#efkq9mIox4q5PNgzk+-ca#P@PA=3D$%d!|$iZ{EQJ=0AztW7FB=
fILAyjAsEJvf$GQ-a8F%iUvDLF7QU2)JS@)xx}@C54Z{{K%fLZMjG&`%y{V%=0AzzNNpz=3DQcD=
>eZW*ykpU&}_2XH<hb;Is!neFGK1&PRQK!DO_<(D(3J@rv+<;Fd#b1~3=0AztuVf<-L#xnLt)c0=
5H}iClQimai|Yv|I#B9U9|ge~awZu>r!wQE8+Rt!Of6@rouyIE=0Azk;{^Iz&L9+P5F))ucRifr=
1$TcByHC<NATLBLIhLnS=3Dj<d$%L<#IDXWVC#tn0<ias>=0Azas!sFDhMFM{**0Xl1%t&3Dakd=
36)uuycZL&Y*Rr18MY!^v<FNoGhVuJryMb+yqy(M=0Az2%I7pOe5W`i0yQb#+=3DH4YrBdJD50`=
Y$El?F>k_^-=3DO?1Fi!>y*BBpOHNlcl_H=3DJ*F=0Az;h8cWrtpcU!w77=3Ddvu`!De6HSd4_@=
jN$_ff@fEAEU{#0-5GoXmqk^$Vgr?k}%}VNy=0AztL0z}@CH=3D80E<;}H=3Dczl6<P3UbQ4g}E=
8iFmhW(+yTzjVJ=3D2xdfpxU8=3D14f_=3DXPPQ0=0Az{<?&&_^;@IYNrYf7=3Db;gP9?=3D(m(=
cZVbW#?G>h|*#Y8O43FJ=3D0~Qzt-B<GUXhDTrcG=0Az4f`3F5WfvkENO~zsUQ@4FBR<UDW}qa#=
d32&0wmy-@H#Af$bwHJc(wK59kS~C<B}bB=0Az?8$_^YIiaOIbQQzyr7B=3D5nCWBnef#T$s3v^=
N`Yx|k)fQi0E_$@g1U?>U_vJTixH-q=0Ayy_inZ$d|}b{Rt+mBs>N(%!{GALpHn{VS2)tinh9wM=
GZeZ0;ctUd^EZE_2qAYD1tu#=0A=0Aliteral 0=0AHcmV?d00001=0A=0Adiff --git a/par=
t1/.gcc.c.un~ b/part1/.gcc.c.un~=0Anew file mode 100644=0Aindex 00000000000=
00000000000000000000000000000..0e2cb31747bf57b6be7201734c3dfb41dac3a6dd=0AG=
IT binary patch=0Aliteral 6274=0AzcmeI$J!lj`6u|Ml%NgU>5v{Dk6biXQF3lmLv63{xX=
``(y<{}4r2}dG#rqC1tJFOIK=0Az1i{84V42F!%EHRhMkHV_E?DUM&&^w37EG1t=3DE2^~?F@Uv=
`|)P?_ICfl>sy0stKYNw=0Azt6zIxK7P13cj4)??wN0M&)=3D_p-Ffok^3v{`e0S~brCye0C*{y=
+N~b0VEkUbCmKQf)=0AzHW;mCcRn*JQJ*yab21c8{E^6}%xLN!at88Z;hg8lvY%%w*M=3DhNY<V=
X776LLq&K%EF=0Aze&bAv!_7cmEd8!B!BH{<CcZb!Pcx@vOH3v+QM!3?{gY*?ZfsgjkQ^~9fUIO=
oOeQl?=0Azx_Qyvu}o}TN&wkZyY2X4zawf%;Z=3DJ25mjWw?|z{Oxzw~A8jPnR)NDj=3D^Ww&|)=
#V43=0AzU_T&ezyS7NcLuF4mpUqk2GV|<6RCDJEwNhB?NoKO5G@ldGiDKxLFdmUCX<;cU1924=
=0AzCaQ?kYqiYu2kY+M-R1ePXTo#Ltc1C6o#I^LA`3A?xYnv%T0vA*Q@LnIt$+s7akDG{=0Az%d=
Ih?nao7#3fe=3D9M!i4)3%9e{rhH5uV$_l$yGt_t1hYb*sdvLvcAAxFt-K5wT0y;$=0Az!2(mg-=
43M&jD5!f8c@FcQmIKMqJ}^{ItXf3{xK}~R`QMevOT&hZXDQP^0%<CItbYz=0Az{j0IW7P1np5w=
^#cO}9a<ucnjeugs6!RX1+AfCiEW3hM$8H0mvFiX<Uw2-@~RXbsQ;=0Azm8~rn1snIcR9|ExdI;=
4EPgVQ(m_hYWUp#@F4)x{6=3DSOaF(Ji!Cl7D%k5B&Q|k?F(U=0AM`o?h3+1h*e7vFZfQ2+n{=
=0A=0Aliteral 0=0AHcmV?d00001=0A=0Adiff --git a/part1/.gcd.h.un~ b/part1/.g=
cd.h.un~=0Anew file mode 100644=0Aindex 00000000000000000000000000000000000=
00000..737b358ce4b56cfe44896aa11d6b7b89df3da8bb=0AGIT binary patch=0Alitera=
l 523=0AzcmWH`%$*;a=3DaT=3DFfl2nx)lbvvW7qrb>s^o=3DD9kp|UvJyyOF>(BriR=3D&_s!=
%I0|Nsi=0Az5Q6|Rjm`%16MqE!WdX4m8R9R1wV)CZDX7?gAYfodRWQn<W(WYI;}0}CzDl4O4300=
;=0AH#^<X5H+v%E=0A=0Aliteral 0=0AHcmV?d00001=0A=0Adiff --git a/part1/.main.=
c.un~ b/part1/.main.c.un~=0Anew file mode 100644=0Aindex 000000000000000000=
0000000000000000000000..5dd52d42967691a723ed268861e5456b74b955a4=0AGIT bina=
ry patch=0Aliteral 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
al 0=0AHcmV?d00001=0A=0Adiff --git a/part1/.prime.c.un~ b/part1/.prime.c.un=
~=0Anew file mode 100644=0Aindex 0000000000000000000000000000000000000000..=
2e47e260ddc1425d59ae1577ffceb66bf7e3a77f=0AGIT binary patch=0Aliteral 22781=
=0AzcmeI)TW?fV6u|MJaw!OMmHXuYR$B{oKz)Lem=3DL2MKuwGWN157*rPX23BH_UYHGTx2=0Az=
@KwCTV0>2-9(*xI5;6EljPU~y=3DS|mt&0eRgLtDlv`)%#yxOdO&Gu>G~);{}O>WhtY=0AzS6-M=
tJ@aQ}VB*!4yN|wq<HM^T?R)0h^S7%*Z+`spw?o%Ixq0)>v)kVK>{g{x*(jTp=0Az71CgPD(#@Q=
tx{``ty{^bgOxMCqz(hArm}-|*S}IK54caGd7mRtYwv3)N2PLSXV-T_=0AzQF;0UWuomNAX_EdO=
4%yPq`mnm%KeXkFx~J>8us*S2>gaZ%J9V0OszFi%qBC8d`J8+=0Az+aX(+5rnKo%>G!)YzJmaR$=
MH`@6t0Z8zYkCL>U=3DpVaZk3+WR+qJ+cgf)w1bSmy*o(=0Az**Hirm<HJqOhh4P5vBv(Ok~a)*=
<jjqxH0|4)P=3DM4ljmx!$+5{(i47+DSb>$FgUuq6=0AzwHCJ9o{jKZfo+hvky$Zu@ww8ZPEf6t=
O_!aKWhpAzs#^QN5zpl*;M%IEvYF;^W4cu|=0Az#;Yfa#>pgSQZ_aYMQ$rQLXIfpEFxF^A9BZ>9=
8&At*id8J%f65!3OS3&o$8ibFTW5H=0Aza&GVZoKv}r!Z$iPa_N<nd~iJ|n-z{NNrTYBlB*WN)1=
J^cV1&>vt|4Kc70BotXE%#T=0Az)>@ce@=3DP}I8PlF6GA$(<VjJ8bEm8GE8Hwg1lcgzwuX#a|2=
M!a|<s^!Ui~SF|kyu~d=0Az6<jVdS(?K2gXgmBfyB>?u=3DpFxd`@4zQ5j4UiL6DKu6rg<Q;-<b=
PBO|$v);PUoGx0;=0Az3-uEz%jmbsjSxzXCp%*SNf5FY;rq$+*`x;pS+>dOtWIovzS)foLfG_nN=
o1XiOqQmw=0Az{oKt)_$jb$G_F)9HI%l{Clv%aOdkM*nuR4-y^tF7pUsu4(7K$gu+jS;X*9TD#Z=
AeW=0Az7zskwB38e4XPCEIjn!Gh0%w~W4{(9y0+P2WSo5BIvi>tHp0lh4i*i|h7^q&>r`UF?=0A=
zv+P?#hqF~9h45k7tiTItEKDpSS!*HveX0CghZdy-18BP&6L^5dlEeiiUsJ$tb%U`=3D=0AzwDg=
+G!E}PdN8d6?W5SLDVlk2elD87Czr7buR#-xI-wuJtzx)Fo>801=3Dv38V5WG%vV=0Az$8*`)iz=
Ph-diIj(FeMi{yWD_~LrY6&StN4RqV<nzt?0Zlhn9tZ0WEZPyRjh0A#rEe=0Az1tnjz);{>D&n>=
&vXg5LbI(6Z*$BhR&4q}UIGlGz{h}RYG#gd%R<Hd4+yDkjnKaGju=0AzVs@xejE@)9kxTN)hQi;=
1)XM;Su4dTxx?zd6KHZj@!oLHSEV0Za8re&&Jyh}b_6DRa=0AzGxxqeGc#4MO&9M?)?1VH=3D9#=
yfjdOK<=3DVW#yog5+C=3DSB)A{|pYXFHVj`A!iZ7K~HGu=0AzYlMdvOy6Q&>Ly9#_Pep7%6V3w=
D1@YoOqQldu2;!{xn&NDCb=3D2OG~-Uxrp}j7eQ-M9=0AzhJ+y#C<jIc5`?Tp+`jf1Xm3uMn?Cj=
7&C2udG+V>7BlfTkroxR3!eDa&$=3DejRYfG_d=0Azx|M9hBc&ToV{UAPv~i1R(gh`7Q{28&w^f=
~KvOC?jFip<6U7Uj}WKd7Yb}$VNM9yz<=0Azp^*Zztcq&|D|+ThKfG%@YwgkReZtvI7n>*bFRIe=
{t!k4bMpgR;sqqUl7m#H&dolZQ=0AzDYNw?TgR*<gXowW7JQK59m^4du$<Bh*@7>jER<%)EX^=
=3DF?uLaQ7je3*jHSPeOh3(D=0Az%zpD})_oC2mT8%H55_XDC>ddU(v1*O&Tet*(*>pPW-pALr*=
^A5OB1^rW~tZx6bK&v=0AzOy3H0(DSrBW=3DevPwba^2pVO>c)8VqW(2c9>E%f93rH=3Di*N4jO=
=3DlZ~;W$vZ_nmIy(D=0AzkhRGF+G4E=3D4t50X*0Bk$xRjg<8OEVBlrgEf1fY|aIKNpW`mB4I7=
(e&tH<p7uBG8hE=0AzAUT|NQNcyOc!PmxEVp<fqH4uooy{Y%t26DGh#+~yj+7cM`UQ~-O5aUSq}=
NL6n-(Qv=0AzWmj4zB1neZ5a6O;JWz8%>AUHP^sZ6*CQo$LPjt2d)P9Kwl1JST;G$nF(p^ycZh9=
i3=0AzYGqL(yVlZ<i3pO%>`1BMqF+pOE+~CBJrPm0;)%ZSS!4@y?U;xl8MY&(hD$SueX*h=3D=
=0Az3d<;-sEn$7-=3DajEUrNhF1j&dS1YGosEOJ5VyXlFDs+C2F>_LfkOhk}8ZbwQD7yW|B=0Az=
1*Pw%CnBm=3DJkghaqT|*<X_<&18MPy&hKqh$VxqH1^jUkNGOF@jixQC;rDY<5<cJ#p=0AzT$(}=
b3nCYpewv=3DBjH-N*C;G}~k-f#Hzbp|!a@75Hxag-Ph%6F)*1ZtTdq;-QmzMhG=0AvsNcig(_Q=
?Jt(JQ4&?g+jMz{RR5G5qbD7}b&<CBiimlLRp`aSm&{p;#~s1d$A=0A=0Aliteral 0=0AHcmV?=
d00001=0A=0Adiff --git a/part1/.prime.h.un~ b/part1/.prime.h.un~=0Anew file=
 mode 100644=0Aindex 0000000000000000000000000000000000000000..5fa40bad6cd8=
ef58f6c08b46a7fb4ba2615ea557=0AGIT binary patch=0Aliteral 1048=0AzcmWH`%$*;=
a=3DaT=3DFfys7io-DUma8g&`5s&nl7v|Wmd=3D|1Lo^f*bl4$#|zuROP7#J9V=0AzST-p?KPNR=
YPoX>`wIn08D88U5GdEQuGp|IULem<mh#g8Z0cj8b(J;)A_(N5f1!NQx=0AzL;MAhED*pHg4iG_=
5C(()K)}EZ<BihP4}ruV3LN0*U}X3zfo42BTEH^!NCBz>voS;&=0AxOdG*bimVc3B*+|)7${vZf=
TI*$1xR8PP$>j}IZOwd!!V*06!7@-uxaD-RRCK&KK}p!=0A=0Aliteral 0=0AHcmV?d00001=
=0A=0Adiff --git a/part1/Makefile b/part1/Makefile=0Anew file mode 100644=
=0Aindex 0000000..51400fa=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 =
+1,81 @@=0A+# This Makefile should be used as a template for future Makefil=
es.=0A+# It's heavily commented, so hopefully you can understand what each=
=0A+# line does.=0A+=0A+# We'll use gcc for C compilation and g++ for C++ c=
ompilation=0A+=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+# Let's leave a place h=
older for additional include directories=0A+=0A+INCLUDES =3D=0A+=0A+# Compi=
lation options:=0A+# -g for debugging info and -Wall enables all warnings=
=0A+=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g -Wall $(INCLUD=
ES)=0A+=0A+# Linking options:=0A+# -g for debugging info=0A+=0A+LDFLAGS =3D=
 -g=0A+=0A+# List the libraries you need to link with in LDLIBS=0A+# For ex=
ample, use "-lm" for the math library=0A+=0A+LDLIBS =3D=0A+=0A+# The 1st ta=
rget gets built when you type "make".=0A+# It's usually your executable.  (=
"main" in this case.)=0A+#=0A+# Note that we did not specify the linking ru=
le.=0A+# Instead, we rely on one of make's implicit rules:=0A+#=0A+#     $(=
CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)=0A+#=0A+# Also note that =
make assumes that main depends on main.o,=0A+# so we can omit it if we want=
 to.=0A+=0A+main: main.o prime.o gcd.o=0A+	gcc main.o prime.o gcd.o -lm -o =
main=0A+# main.o depends not only on main.c, but also on myadd.h because=0A=
+# main.c includes myadd.h.  main.o will get recompiled if either=0A+# main=
=2Ec or myadd.h get modified.=0A+#=0A+# make already knows main.o depends o=
n main.c, so we can omit main.c=0A+# in the dependency list if we want to.=
=0A+#=0A+# make uses the following implicit rule to compile a .c file into =
a .o=0A+# file:=0A+#=0A+#     $(CC) -c $(CFLAGS) <the-.c-file>=0A+#=0A+=0A+=
main.o: main.c prime.h gcd.h=0A+	gcc -c main.c -o main.o=0A+# And myadd.o d=
epends on myadd.c and myadd.h.=0A+=0A+prime.o: prime.c prime.h=0A+	gcc -c p=
rime.c -lm -o prime.o=0A+=0A+gcd.o: gcd.c gcd.h=0A+	gcc -c gcd.c -o gcd.o=
=0A+=0A+# Always provide the "clean" target that removes intermediate files=
=2E=0A+# What you remove depend on your choice of coding tools=0A+# (differ=
ent editors generate different backup files for example).=0A+#=0A+# And the=
 "clean" target is not a file name, so we tell make that=0A+# it's a "phony=
" target.=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.o a.out core main=0A+=
=0A+# "all" target is useful if your Makefile builds multiple programs.=0A+=
# Here we'll have it first do "clean", and rebuild the main target.=0A+=0A+=
=2EPHONY: all=0A+all: clean main=0Adiff --git a/part1/Makefile~ b/part1/Mak=
efile~=0Anew file mode 100644=0Aindex 0000000..28f46ba=0A--- /dev/null=0A++=
+ b/part1/Makefile~=0A@@ -0,0 +1,78 @@=0A+# This Makefile should be used as=
 a template for future Makefiles.=0A+# It's heavily commented, so hopefully=
 you can understand what each=0A+# line does.=0A+=0A+# We'll use gcc for C =
compilation and g++ for C++ compilation=0A+=0A+CC  =3D gcc=0A+CXX =3D g++=
=0A+=0A+# Let's leave a place holder for additional include directories=0A+=
=0A+INCLUDES =3D=0A+=0A+# Compilation options:=0A+# -g for debugging info a=
nd -Wall enables all warnings=0A+=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=0A+C=
XXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+# Linking options:=0A+# -g for debu=
gging info=0A+=0A+LDFLAGS =3D -g=0A+=0A+# List the libraries you need to li=
nk with in LDLIBS=0A+# For example, use "-lm" for the math library=0A+=0A+L=
DLIBS =3D=0A+=0A+# The 1st target gets built when you type "make".=0A+# It'=
s usually your executable.  ("main" in this case.)=0A+#=0A+# Note that we d=
id not specify the linking rule.=0A+# Instead, we rely on one of make's imp=
licit rules:=0A+#=0A+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLI=
BS)=0A+#=0A+# Also note that make assumes that main depends on main.o,=0A+#=
 so we can omit it if we want to.=0A+=0A+main: main.o prime.o=0A+	gcc main.=
o prime.o -lm -o main=0A+# main.o depends not only on main.c, but also on m=
yadd.h because=0A+# main.c includes myadd.h.  main.o will get recompiled if=
 either=0A+# main.c or myadd.h get modified.=0A+#=0A+# make already knows m=
ain.o depends on main.c, so we can omit main.c=0A+# in the dependency list =
if we want to.=0A+#=0A+# make uses the following implicit rule to compile a=
 .c file into a .o=0A+# file:=0A+#=0A+#     $(CC) -c $(CFLAGS) <the-.c-file=
>=0A+#=0A+=0A+main.o: main.c prime.h=0A+	gcc -c main.c -o main.o=0A+# And m=
yadd.o depends on myadd.c and myadd.h.=0A+=0A+prime.o: prime.c prime.h=0A+	=
gcc -c prime.c -lm -o prime.o=0A+=0A+# Always provide the "clean" target th=
at removes intermediate files.=0A+# What you remove depend on your choice o=
f coding tools=0A+# (different editors generate different backup files for =
example).=0A+#=0A+# And the "clean" target is not a file name, so we tell m=
ake that=0A+# it's a "phony" target.=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm =
-f *.o a.out core main=0A+=0A+# "all" target is useful if your Makefile bui=
lds multiple programs.=0A+# Here we'll have it first do "clean", and rebuil=
d the main target.=0A+=0A+.PHONY: all=0A+all: clean main=0Adiff --git a/par=
t1/gcd.c b/part1/gcd.c=0Anew file mode 100644=0Aindex 0000000..7cbe5bc=0A--=
- /dev/null=0A+++ b/part1/gcd.c=0A@@ -0,0 +1,12 @@=0A+=0A+#include "gcd.h"=
=0A+//=0A+// default input x < y=0A+int gcd(int x, int y)=0A+{=0A+    if( y=
%x =3D=3D 0)=0A+        return x;=0A+    else=0A+        return gcd( y%x, x=
);=0A+}=0A+=0Adiff --git a/part1/gcd.h b/part1/gcd.h=0Anew file mode 100644=
=0Aindex 0000000..1e829c9=0A--- /dev/null=0A+++ b/part1/gcd.h=0A@@ -0,0 +1 =
@@=0A+int gcd(int x, int y);=0Adiff --git a/part1/main.c b/part1/main.c=0An=
ew file mode 100644=0Aindex 0000000..c012227=0A--- /dev/null=0A+++ b/part1/=
main.c=0A@@ -0,0 +1,27 @@=0A+#include <stdio.h>=0A+#include "prime.h"=0A+#i=
nclude "gcd.h"=0A+int main()=0A+{=0A+    int x,y ;=0A+=0A+    printf("pleas=
e input two positive integers: ");=0A+    scanf("%d%d", &x,&y );=0A+    pri=
ntf("You typed in %d and %d\n", x, y);=0A+    printf("your input average is=
 %f\n",( ((float) x)+ ((float) y ) )/2);  =0A+        =0A+    if(whether_pr=
ime(x) =3D=3D 1) =0A+        printf("%d is prime\n", x);=0A+    else=0A+   =
     printf("%d is not prime\n",x);=0A+    =0A+    if(whether_prime(y) =3D=
=3D 1)=0A+        printf("%d is prime\n", y);=0A+    else=0A+        printf=
("%d is not prime\n", y);=0A+    =0A+    printf("The gcd of %d, %d is %d\n"=
, x,y,gcd(x,y));=0A+    =0A+=0A+    return 0;=0A+}=0Adiff --git a/part1/mai=
n.c~ b/part1/main.c~=0Anew file mode 100644=0Aindex 0000000..677781a=0A--- =
/dev/null=0A+++ b/part1/main.c~=0A@@ -0,0 +1,27 @@=0A+#include <stdio.h>=0A=
+#include "prime.h"=0A+#include "gcd.h"=0A+int main()=0A+{=0A+    int x,y ;=
=0A+=0A+    printf("please input two positive integers: ");=0A+    scanf("%=
d%d", &x,&y );=0A+    printf("You typed in %d and %d\n", x, y);=0A+    prin=
tf("your input average is %f\n",( ((float) x)+ ((float) y ) )/2);  =0A+    =
    =0A+    if(whether_prime(x) =3D=3D 1) =0A+        printf("%d is prime\n=
", x);=0A+    else=0A+        printf("%d is not prime\n",x);=0A+    =0A+   =
 if(whether_prime(y) =3D=3D 1)=0A+        printf("%d is prime\n", y);=0A+  =
  else=0A+        printf("%d is not prime\n", y);=0A+    =0A+    printf("Th=
e gcd of %d, %d is %d", x,y,gcd(x,y));=0A+    =0A+=0A+    return 0;=0A+}=0A=
diff --git a/part1/prime.c b/part1/prime.c=0Anew file mode 100644=0Aindex 0=
000000..fb55efc=0A--- /dev/null=0A+++ b/part1/prime.c=0A@@ -0,0 +1,15 @@=0A=
+#include "prime.h"=0A+#include <math.h>=0A+=0A+int  whether_prime(int x)=
=0A+{=0A+    if(x =3D=3D 1) return 0;=0A+    float y =3D (float) x;=0A+    =
y =3D sqrt(y);=0A+=0A+    for(int i=3D2; i<=3Dy; i++){=0A+        if( x%i =
=3D=3D 0)  return 0;=0A+        // 0 indicates x is not prime=0A+    }=0A+ =
   return 1;=0A+}    =0Adiff --git a/part1/prime.c~ b/part1/prime.c~=0Anew =
file mode 100644=0Aindex 0000000..a75e52e=0A--- /dev/null=0A+++ b/part1/pri=
me.c~=0A@@ -0,0 +1,14 @@=0A+#include "prime.h"=0A+#include <math.h>=0A+=0A+=
int  whether_prime(int x)=0A+{=0A+    float y =3D (float) x;=0A+    y =3D s=
qrt(y);=0A+=0A+    for(int i=3D2; i<=3Dy; i++){=0A+        if( x%i =3D=3D 0=
)  return 0;=0A+        // 0 indicates x is not prime=0A+    }=0A+    retur=
n 1;=0A+}    =0Adiff --git a/part1/prime.h b/part1/prime.h=0Anew file mode =
100644=0Aindex 0000000..eafd030=0A--- /dev/null=0A+++ b/part1/prime.h=0A@@ =
-0,0 +1 @@=0A+int  whether_prime(int x);=0Adiff --git a/part1/prime.h~ b/pa=
rt1/prime.h~=0Anew file mode 100644=0Aindex 0000000..4763068=0A--- /dev/nul=
l=0A+++ b/part1/prime.h~=0A@@ -0,0 +1 @@=0A+boolean whether_prime(int x);=
=0A-- =0A2.17.1=0A=0A=0AFrom 9ca8ea32cb49b3cdcb5e33d424235621ccb7c254 Mon S=
ep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 5=
 Feb 2022 10:51:36 -0500=0ASubject: [PATCH 3/5] Finishing part2=0A=0A---=0A=
 part2/Makefile  |  39 ++++++++++++++++++=0A part2/convert.c | 104 ++++++++=
++++++++++++++++++++++++++++++++++++++++=0A 2 files changed, 143 insertions=
(+)=0A create mode 100644 part2/Makefile=0A create mode 100644 part2/conver=
t.c=0A=0Adiff --git a/part2/Makefile b/part2/Makefile=0Anew file mode 10064=
4=0Aindex 0000000..cd1a2e8=0A--- /dev/null=0A+++ b/part2/Makefile=0A@@ -0,0=
 +1,39 @@=0A+# This Makefile should be used as a template for future Makefi=
les.=0A+# It's heavily commented, so hopefully you can understand what each=
=0A+# line does.=0A+=0A+# We'll use gcc for C compilation and g++ for C++ c=
ompilation=0A+=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+# Let's leave a place h=
older for additional include directories=0A+=0A+INCLUDES =3D=0A+=0A+# Compi=
lation options:=0A+# -g for debugging info and -Wall enables all warnings=
=0A+=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g -Wall $(INCLUD=
ES)=0A+=0A+=0A+LDFLAGS =3D -g=0A+=0A+LDLIBS =3D=0A+=0A+=0A+convert:  conver=
t.o=0A+=0A+convert.o: convert.c=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.=
o a.out core main=0A+=0A+=0A+# "all" target is useful if your Makefile buil=
ds multiple programs.=0A+# Here we'll have it first do "clean", and rebuild=
 the main target.=0A+=0A+.PHONY: all=0A+all: clean main=0Adiff --git a/part=
2/convert.c b/part2/convert.c=0Anew file mode 100644=0Aindex 0000000..e2159=
f8=0A--- /dev/null=0A+++ b/part2/convert.c=0A@@ -0,0 +1,104 @@=0A+#include =
<stdio.h>=0A+=0A+int convert_binary(int x);=0A+=0A+int convert(){    =0A+  =
  int x;    =0A+    scanf("%d",&x);=0A+    printf("signed dec:   %d\n", x);=
=0A+    printf("unsigned dec: %u\n", x);=0A+    printf("hex:          %x\n"=
, x);=0A+    convert_binary(x);=0A+    return 0; =0A+}=0A+=0A+int convert_b=
inary(int x){    =0A+=0A+    =0A+=0A+    char output[39] =3D{0};=0A+    int=
 i;=0A+    int mask =3D 1;	=0A+    for (i=3D38; i>-1; i--) {  =0A+        i=
f( ((i+1)%5 =3D=3D 0) && i !=3D 0 ){=0A+            output[i] =3D ' ';=0A+ =
       }else{=0A+=0A+            if(x& mask){=0A+                output[i] =
=3D '1';=0A+            }else{=0A+           =0A+                output[i] =
=3D '0';=0A+            }=0A+            mask <<=3D 1;=0A+        }=0A+    =
            =0A+                =0A+    } =0A+    printf("binary:       %s\=
n", output);=0A+=0A+    return 0;=0A+}=0A+=0A+int main()=0A+{=0A+    conver=
t();=0A+=0A+    return 0;=0A+}=0A+=0A+/*=0A+int convert_binary(int x )=0A+{=
=0A+    //int x;=0A+    int tens =3D 1;=0A+    int result =3D 0;=0A+   whil=
e(x/2 !=3D 0){=0A+        =0A+       result +=3D x%2 * tens;=0A+       tens=
 *=3D 10;=0A+       x =3D x/2;=0A+   }=0A+   // x =3D 0/1 after while=0A+  =
 result +=3D x%2 * tens;  =0A+=0A+   return result;=0A+}=0A+=0A+int convert=
_binary_rec(int x, int mask);=0A+=0A+int convert_binary(int x){=0A+    =0A+=
    if((x < 2)& (x>-2)){=0A+        printf("%d",x);=0A+        return 0;=0A=
+    }=0A+=0A+    // I wnat to know the size of mask=0A+    int mask =3D 1;=
=0A+    int y =3Dx;=0A+       =0A+    while(y > 1){=0A+        printf("%d",=
mask);=0A+        y /=3D 2;=0A+        mask *=3D 2;=0A+    }=0A+    convert=
_binary_rec(x, mask);=0A+    return 0; =0A+=0A+}=0A+=0A+int convert_binary_=
rec(int x, int mask){=0A+        =0A+    if((x =3D=3D 0) | (mask =3D=3D 0) =
) return 0;=0A+    =0A+=0A+    if( (x & mask) =3D=3D 0) {=0A+        printf=
("%d",0);=0A+    }else{=0A+        printf("%d",1);=0A+    }=0A+    convert_=
binary_rec(x&(mask-1), mask/2);=0A+    return 0;=0A+}=0A+*/=0A-- =0A2.17.1=
=0A=0A=0AFrom d92afdab2662a43d85220e2c96a46654d2e9ccc9 Mon Sep 17 00:00:00 =
2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 5 Feb 2022 11:08=
:24 -0500=0ASubject: [PATCH 4/5] Add reference in README.txt, change printe=
d prompt in=0A part1 main.c=0A=0A---=0A README.txt   | 7 +++++++=0A part1/m=
ain.c | 2 +-=0A 2 files changed, 8 insertions(+), 1 deletion(-)=0A=0Adiff -=
-git a/README.txt b/README.txt=0Aindex b4545fc..97f0c99 100644=0A--- a/READ=
ME.txt=0A+++ b/README.txt=0A@@ -45,3 +45,10 @@ script will look for lines t=
hat contain [ANSWER].=0A [0.4][ANSWER] git reset HEAD filename=0A =0A =0A+=
=0A+=0A+-------------------------------------------------------------------=
-------=0A+Reference=0A+=0A+For part1, Euclidean Algorithm, I referred to t=
his article:=0A+https://www.khanacademy.org/computing/computer-science/cryp=
tography/modarithmetic/a/the-euclidean-algorithm=0Adiff --git a/part1/main.=
c b/part1/main.c=0Aindex c012227..5164695 100644=0A--- a/part1/main.c=0A+++=
 b/part1/main.c=0A@@ -8,7 +8,7 @@ int main()=0A     printf("please input tw=
o positive integers: ");=0A     scanf("%d%d", &x,&y );=0A     printf("You t=
yped in %d and %d\n", x, y);=0A-    printf("your input average is %f\n",( (=
(float) x)+ ((float) y ) )/2);  =0A+    printf("The average is %f\n",( ((fl=
oat) x)+ ((float) y ) )/2);  =0A         =0A     if(whether_prime(x) =3D=3D=
 1) =0A         printf("%d is prime\n", x);=0A-- =0A2.17.1=0A=0A=0AFrom 465=
228ca078637d2d7df3504dfc6d70ecd65d653 Mon Sep 17 00:00:00 2001=0AFrom: Yixu=
an_Zou <yz4004@columbia.edu>=0ADate: Sat, 5 Feb 2022 11:18:56 -0500=0ASubje=
ct: [PATCH 5/5] delete unnecessary building code (recursive method) in=0A c=
onvert.c=0A=0A---=0A part2/convert.c | 55 ---------------------------------=
----------------=0A 1 file changed, 55 deletions(-)=0A=0Adiff --git a/part2=
/convert.c b/part2/convert.c=0Aindex e2159f8..a6b6240 100644=0A--- a/part2/=
convert.c=0A+++ b/part2/convert.c=0A@@ -47,58 +47,3 @@ int main()=0A     re=
turn 0;=0A }=0A =0A-/*=0A-int convert_binary(int x )=0A-{=0A-    //int x;=
=0A-    int tens =3D 1;=0A-    int result =3D 0;=0A-   while(x/2 !=3D 0){=
=0A-        =0A-       result +=3D x%2 * tens;=0A-       tens *=3D 10;=0A- =
      x =3D x/2;=0A-   }=0A-   // x =3D 0/1 after while=0A-   result +=3D x=
%2 * tens;  =0A-=0A-   return result;=0A-}=0A-=0A-int convert_binary_rec(in=
t x, int mask);=0A-=0A-int convert_binary(int x){=0A-    =0A-    if((x < 2)=
& (x>-2)){=0A-        printf("%d",x);=0A-        return 0;=0A-    }=0A-=0A-=
    // I wnat to know the size of mask=0A-    int mask =3D 1;=0A-    int y =
=3Dx;=0A-       =0A-    while(y > 1){=0A-        printf("%d",mask);=0A-    =
    y /=3D 2;=0A-        mask *=3D 2;=0A-    }=0A-    convert_binary_rec(x,=
 mask);=0A-    return 0; =0A-=0A-}=0A-=0A-int convert_binary_rec(int x, int=
 mask){=0A-        =0A-    if((x =3D=3D 0) | (mask =3D=3D 0) ) return 0;=0A=
-    =0A-=0A-    if( (x & mask) =3D=3D 0) {=0A-        printf("%d",0);=0A- =
   }else{=0A-        printf("%d",1);=0A-    }=0A-    convert_binary_rec(x&(=
mask-1), mask/2);=0A-    return 0;=0A-}=0A-*/=0A-- =0A2.17.1=0A=0A
--nFreZHaLTZJo0R7j--

From do.not.reply@cloud.cs.columbia.edu Sat Feb 19 23:20:24 2022
Date: Sat, 19 Feb 2022 23:20:24 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab2.mbox
Message-ID: <20220220042024.GA10194@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="ikeVEW9yuYc//A+q"
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 40273
Lines: 907


--ikeVEW9yuYc//A+q
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From d3c998e270303d85de5a202ae5a255d4ae38aefa Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 11:55:38 -0500
Subject: [PATCH 1/6] complete part1

---
 part1/Makefile |  77 +++++++++++++++++++++++++++
 part1/main.c   | 138 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 215 insertions(+)
 create mode 100644 part1/Makefile
 create mode 100644 part1/main.c

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..117cc26
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,77 @@
+# This Makefile should be used as a template for future Makefiles.
+# It's heavily commented, so hopefully you can understand what each
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+# Linking options:
+# -g for debugging info
+
+LDFLAGS = -g
+
+# List the libraries you need to link with in LDLIBS
+# For example, use "-lm" for the math library
+
+LDLIBS =
+
+# The 1st target gets built when you type "make".
+# It's usually your executable.  ("main" in this case.)
+#
+# Note that we did not specify the linking rule.
+# Instead, we rely on one of make's implicit rules:
+#
+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)
+#
+# Also note that make assumes that main depends on main.o,
+# so we can omit it if we want to.
+
+main: main.o 
+	gcc main.o -o isort
+# main.o depends not only on main.c, but also on myadd.h because
+# main.c includes myadd.h.  main.o will get recompiled if either
+# main.c or myadd.h get modified.
+#
+# make already knows main.o depends on main.c, so we can omit main.c
+# in the dependency list if we want to.
+#
+# make uses the following implicit rule to compile a .c file into a .o
+# file:
+#
+#     $(CC) -c $(CFLAGS) <the-.c-file>
+#
+
+main.o: main.c 
+
+# And myadd.o depends on myadd.c and myadd.h.
+
+# myadd.o: myadd.c myadd.h
+
+# Always provide the "clean" target that removes intermediate files.
+# What you remove depend on your choice of coding tools
+# (different editors generate different backup files for example).
+#
+# And the "clean" target is not a file name, so we tell make that
+# it's a "phony" target.
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
diff --git a/part1/main.c b/part1/main.c
new file mode 100644
index 0000000..27ddd60
--- /dev/null
+++ b/part1/main.c
@@ -0,0 +1,138 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+
+int *insertSort(int *a, int size);
+
+void sort_integer_array(int *begin, int *end, int ascending);
+
+int main(){
+
+    srandom(time(NULL));
+
+    // read array size from user
+    int size;
+    printf("Please input size here: ");
+    scanf("%d", &size);
+
+    // create array
+    // int a[size];
+    
+    int *a = (int *) malloc( sizeof(int) * size);
+    if (a == NULL) {
+         perror("malloc returned NULL");
+         exit(1);
+    }
+
+    int r;
+    for(int i=0; i<size; i++){
+
+        r = (int) (random()%100);
+        *(a+i) = r; 
+        printf("%d %d\n", r, *(a+i));
+    }
+
+
+    int *b =(int *)  malloc( sizeof(int) * size);
+    if (b == NULL) {
+         perror("malloc returned NULL");
+         exit(1);
+    }
+    for(int i=0; i<size; i++){
+
+        *(b+i) = *(a+i);
+    }
+
+    int *c = (int *) malloc( sizeof(int)* size);
+    if (c == NULL) {
+         perror("malloc returned NULL");
+         exit(1);
+    }
+    for(int i=0; i<=size; i++){
+        *(c+i) = *(a+i);
+    }
+
+    sort_integer_array(b, b+size, 1); // end b + size - 1
+
+    sort_integer_array(c, c+size, 0);
+
+
+    printf("original:");
+    for(int i=0; i<size; i++){
+        printf("%d  ", a[i]);
+    }
+    printf("\n");
+        
+    printf("ascending: ");
+    for(int i=0; i<size; i++){
+        printf("%d  ", b[i]);
+    }
+    printf("\n");
+
+    printf("descending: ");
+    for(int i=0; i<size; i++){
+        printf("%d  ", c[i]);
+    }
+    printf("\n");
+
+    free(a);
+    free(b);
+    free(c);
+
+    return 0;
+}
+
+
+
+ /* This function sorts an integer array.
+ 
+ begin points to the 1st element of the array.
+ end points to ONE PAST the last element of the array.
+ If ascending is 1, the array will be sorted in ascending order.
+ If ascending is 0, the array will be sorted in descending order.
+ */
+ void sort_integer_array(int *begin, int *end, int ascending) 
+ {
+ /* In here, you will call your real sorting function (your own
+ * or the qsort()). Basically, I want to make sure that you
+ * know how to translate the begin/end parameter to whatever
+ * is required for your sorting function.
+ */
+ 
+    
+    int index = 1;
+    int temp;
+    int current;
+    if( ascending){
+
+        while((begin+index) != end ){  // index < size
+
+            temp =*(begin+index);
+            // move current/curser to the place i, where a[i] < a[index] and a[i+1] > a[index]
+            current = index;
+            while((current >0) &  (*(begin + current-1) > temp)){
+                // not index - 1 in last row, but compare a[current-1] in condition, and use lazy &
+                *(begin + current) = *(begin + current-1); // put a[current-1] 1 digit back
+                current--;                 // current move forward
+            }
+        *(begin + current) = temp;
+        index++;
+        }
+    }else{
+        while((begin+index) != end){
+            temp = *(begin + index);
+            // move current/curser to the place i, where a[i] < a[index] and a[i+1] > a[index]
+            current = index;
+            while((current >0) &  (*(begin + current-1) < temp)){
+                // not index - 1 in last row, but compare a[current-1] in condition, and use lazy &
+                *(begin + current) = *(begin + current-1); // put a[current-1] 1 digit back
+                current--;                 // current move forward
+            }
+            *(begin + current) = temp;
+            index++;
+   
+        }
+    }
+
+}
-- 
2.17.1


From 14a807c2f789002ce63173f65b856eb88f519f76 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 21:04:01 -0500
Subject: [PATCH 2/6] part2 step1

---
 part2/Makefile | 77 ++++++++++++++++++++++++++++++++++++++++++++++++++
 part2/twecho.c |  6 ++++
 2 files changed, 83 insertions(+)
 create mode 100644 part2/Makefile

diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..4f96046
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,77 @@
+# This Makefile should be used as a template for future Makefiles.
+# It's heavily commented, so hopefully you can understand what each
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+# Linking options:
+# -g for debugging info
+
+LDFLAGS = -g
+
+# List the libraries you need to link with in LDLIBS
+# For example, use "-lm" for the math library
+
+LDLIBS =
+
+# The 1st target gets built when you type "make".
+# It's usually your executable.  ("main" in this case.)
+#
+# Note that we did not specify the linking rule.
+# Instead, we rely on one of make's implicit rules:
+#
+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)
+#
+# Also note that make assumes that main depends on main.o,
+# so we can omit it if we want to.
+
+main: twecho.o 
+	gcc twecho.o -o twecho
+# main.o depends not only on main.c, but also on myadd.h because
+# main.c includes myadd.h.  main.o will get recompiled if either
+# main.c or myadd.h get modified.
+#
+# make already knows main.o depends on main.c, so we can omit main.c
+# in the dependency list if we want to.
+#
+# make uses the following implicit rule to compile a .c file into a .o
+# file:
+#
+#     $(CC) -c $(CFLAGS) <the-.c-file>
+#
+
+twecho.o: twecho.c 
+
+# And myadd.o depends on myadd.c and myadd.h.
+
+# myadd.o: myadd.c myadd.h
+
+# Always provide the "clean" target that removes intermediate files.
+# What you remove depend on your choice of coding tools
+# (different editors generate different backup files for example).
+#
+# And the "clean" target is not a file name, so we tell make that
+# it's a "phony" target.
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
diff --git a/part2/twecho.c b/part2/twecho.c
index c70e975..741f7a5 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -10,6 +10,12 @@
 static char **duplicateArgs(int argc, char **argv)
 {
 
+/*
+    while(*argv){
+        printf("%s\n", *argv++);
+    } 
+*/
+    return argv;
 }
 
 static void freeDuplicatedArgs(char **copy)
-- 
2.17.1


From a399955d3253134fb2f380a0903180094256bece Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 21:42:55 -0500
Subject: [PATCH 3/6] Add reference for sort algorithm

---
 part1/main.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/part1/main.c b/part1/main.c
index 27ddd60..9a99813 100644
--- a/part1/main.c
+++ b/part1/main.c
@@ -2,9 +2,6 @@
 #include <stdlib.h>
 #include <time.h>
 
-
-int *insertSort(int *a, int size);
-
 void sort_integer_array(int *begin, int *end, int ascending);
 
 int main(){
@@ -24,16 +21,14 @@ int main(){
          perror("malloc returned NULL");
          exit(1);
     }
-
     int r;
     for(int i=0; i<size; i++){
 
         r = (int) (random()%100);
         *(a+i) = r; 
-        printf("%d %d\n", r, *(a+i));
+        //printf("%d %d\n", r, *(a+i));
     }
 
-
     int *b =(int *)  malloc( sizeof(int) * size);
     if (b == NULL) {
          perror("malloc returned NULL");
@@ -98,6 +93,11 @@ int main(){
  * or the qsort()). Basically, I want to make sure that you
  * know how to translate the begin/end parameter to whatever
  * is required for your sorting function.
+ *
+ *
+ * Insertion Sort. 
+ * From the lecture note of COMSW 3134
+ *
  */
  
     
-- 
2.17.1


From 35a35e52ad2bfe8de3a6637c8a9c9880ef8e4411 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 22:42:59 -0500
Subject: [PATCH 4/6] finishing part2 step2

---
 part2/twecho | Bin 0 -> 11392 bytes
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100755 part2/twecho

diff --git a/part2/twecho b/part2/twecho
new file mode 100755
index 0000000000000000000000000000000000000000..18e341b1f659368d3eee676f9fff61ac9ff6b5ca
GIT binary patch
literal 11392
zcmeHNeQ;FQb-!;{AFCBwEeL@GuDvD@e?_~J5FkP^TA{^Hj`#>c2_)dhYWGRnvf9<`
z2bQQwaD`pAG7fYchonx&NoPECrk=XZ)L}fHM25taq|?Z)lQJ=$QBvH>Hfhv2c4=%-
zf9Jk?q_>ZyacBCcujcK!=XXBtxgYPnbMMoaB0XDNnkKlo#l3>K$#M(nV8KeR2+<+h
zMHPNmh}%U4;4)ktO6;Upm20LRrRN4EyLOiaIO#1)k10n;RE4HAipdeL#WNKmAOW(Y
zSWnkT7BnC$Ob1mQ!-}#Uv1E5f*_}~#OlMSJOu2v5H@bEye@@y385O3aOJ&C!xj5CY
zC`V4(BejHJ%66ZI9mV-!i(e`3RPEhtTz0GYnX2xJP%_cCwk?#5HzgCP{7BPC``V_p
zZNY3h*ed%?{z><~ZN0K3nr|Ljig__E!braC+1FqB{9A<`Pi&mceCpTN?mp{k+(5Q`
zq57fAR%ixFXfFarm$Os@D20b^f+v6na5+mOfKq-&fCrq)3R_VE7Z}$V4dYrdoJpi|
z{UV#oB+Zl<iYAlkm@tgkNYv<0q@u~hArma=8`)emlQV{*iIljnr@M2r(Hd+Gt`SD}
zuB}Gg%$Ng-Y|hN=+PXQJPMN!+eMzz$7)qy<rD3U-RHPtX^3R$<YZf)k4$Tj*qx`Z&
z70JV@PkdkT{V=H(=X2`*Vf=)`J^p~SWSsenwH8il)E<{98_xFt$);_%{W&pX!z<Yd
z=v5oeZIgIH;iSv!mhiu~;k16aOxke!eW;IJ@#y2_hrI!zKQfVX%}(lL-}jtjGcmj7
zZir@AeFDF=w{@UK{2<BSoSH>hwSsu+`kRxIUq(EI^yY-*Tfz6AAOk8bzw9o&@_=6W
zg+6w9X2-6c<K=HbS3h2pm1N^T!qaU1zf}dqZ)$JrBFV-oIOx@nmusN<`m1{3ja(x_
zegQfZa?QTkss3Q?ZAYd5edj33c^>u`Nb&fZvmm|tUDsi+zjWQL7iRRArZ?%@%la$V
za}99#uyVM79Nx^|k&UBJ6Zw!nw()aR>!o-W=;Iqd4{o{!U7ptQ^K$v8!D|%G5en>`
zb8w0Nkovwi`=LQKjDB<B@Fl&FpB#@|8k^SiQ~FC&i0%CJx3AC6>V?S6`N(BCxToM`
zJaQQd#~1&AJnG|-NnM-N#|5d!p<akw8IN3n2Kbz1e)W80nv~yOQ`*))9+`%LHaXrq
zt;c?-kM~~HwI9|#FOIp!BGVeA8zNU8I_ET=(Y3Q^A9De<%TT+#A#$nqvAyUP;F$~O
zWakQpub$XvRmZLb3Wu+tpHpLpuV`PYJVSkYdj#!GQOJd#BILJK$d=>Cj6N2b^5AF2
z^L8tF)sOG+=!M=HecTUrN<XfH-8v-);APD7-@)Y>>g@EuH5rE#Ju;D3p`M?nVV4>g
zFfG=434bp9+3v!>gnPqSi>ua_%ca&t^fTeYweG@uJ$KP8dGwdAxu<{p0sKDl%Uq!4
zHMZ|5{I;j?URU8);n~HP^s#fAzW(+6TXYY7VPAM}cwhK|uyO9h{Ca!`x0dv$?lKK`
z@2YHIRTg=Hw%olzNBkaKPoSwMKwkxY5%e->9P~fXwO2uZgu(g^=ubfxV=!~*S{vwP
z(1$?j{Y6DPv{Ps!er@@JO3w+c(oZ<$EF<uD4=JcpT3?8jkdyw^_h)B2NZ04z;%m6S
zw)#QO5wU66hPzj<TtP6|cj5BGFU8M=Z1>_?gt%WPFzoX`>e^gW;kt;3EZ+|S{xRg$
zcKH@5mTf-;`~}FLw98#5r2@72BCd9fgGusEpa09QPG7_0?uajNysXoA=VRr%uldmm
z-Pb-=xz*Q^@wJD2&0*i2oxT9{px^29$oE7U#%(|R(8KGa^3e!<Gy)%f1UP@<d<nOb
zEKC<De!oh3)OJO@svZ`UpHktxY`MkCXCYOWDW3DQTO9Itug|6lI;C!2&aF<UB#3jK
zGfJ+uVd77fANlM-y+QHyiZbC`>a@zE_!*%q1%7^V?zU9n4Jr`Ecb8cLenw6xJtU{H
zaQn9^p7rqfmHoqbN(hfB$+s(ic<i%WTFxkbg_8fb;<+En{r?-`{if65ldAvEDEd54
zj8pM<@SJbow|Vm?19$fJ<x{zQU|n!cu(@e<UUDs8Y-tZRx7}r-;uCOaO_DW)KT|8<
zi@YKo4c>}@vc}4zH9@xEpYXE~9!eRyX!*G=w&U0BsigOkTl4%3p53m>ZA8i{|4f1v
zmn2v|4N_KCjtvtG%AX}`T*Cbr?blqrVBE*4TJEXvJWc|w;$LA>Np;V6P`g<6?lNdq
z{RlwWdwuv7Rn)Pv_mAP%Q}tb{e?WDAl>x=FYgBKj`Uk3Cr+T2Og@Tx+`kmfCr@GLH
zY4#q)Z<!{UcJFJ%xFplzjgnfKWOVP}lCN^f?C=f|Qz4n%-d9M?qwNH?-%GbnnOCD7
z`JnfCVist9Aj94~sre<7^S(opMcOdPi1*)#S)y$LIpX~_sV&uZf%zlv$4JtkJpgZG
z-ZV*W(NbWJdH;(ftF%7^IpIA7sH{nQ6wE2_!^8w7^R)LEF(JvE_I{a|X30F~eUg|~
zIooHvhspJ78QX;S8zfny<v_kKs{e{aU-!(ycSG6J)XA#tr0`9uiYlGN-=gk%swSxZ
zOdnvssPNnltitnka0_T6DeM|rGlbG?O7tkBb;zw?Ui&BHW0OXBt%jen4y&GnU0GPx
zD?DETQ~4~UelOI^|CpNhk5ToQtUd$2ydbNafL1K)gTaDt1N{}Qg`)B@i2ny9T22U7
z<!NYOHJ=1obRLklx)0T}>d7UOFYww^CY~X6XXg}LC->G-AlhmYxK8d^{55#h+AVId
zepqPht@?g+n-<)XTS?)b?<mjw=+&P3DtVUH_b6+zG)%6&#PW?O(?}VK6@{0=be-(6
zqL8YtlO6R@q1CE(>;FJ#3oWf(4K=FSQ?Q~^Pp21Jy(QjD;Vz*dT_*?Y6GCgS@ZCVP
zh1x1#UA5b{+_z9$RO!bf-nB%yeV?q}P~BaJv0EvstM7#z)1;~%OhPSCj4~0@s{FVh
z;;GZzzUpeS)xcKO%sFa@wpX#`-F3uPb2FGiP3x{Bi<;ZvCj_Cd4yM14_h)UJ<pV~W
z8VT?#0PR}9!rRe}ML}&-qZRcXjoo$Bm5zodI~&PqUHM!Xt_CFa^A3ou2kWtVOYD*$
zx<Kq5jh2(IT27YE<2LuWcd9Xhi)i$JOXDkOzou#L`)cqjPk3ong!0)8o!x~7VzCeo
z?Toc;>I82fl@F~8B~r0uK5h!Br<fb{`VzTpkqS0Q51O&TbTEcSaby*boBhE-I<d)(
z4x3q2U4o9b5^1Xn4Ozvq%Z_FZGm}Z;h{}>-wp_dx-Ck|lb1?q}*NQsN;(W-}Ql~%a
zdD@-5-(CMgPs`EHHwF%RK6P}@o{+0`;dfu$<8q;|hLP^?H*z@A+HPdbXxtdiWrPtM
zq|>o14$VlE9ZY9(effSme++DHX|Y~vfu^BcK4oqkFjHnG5d#~|#0EE7XPbehfk0C~
zPTFDznuas!oEgidGfg<1OQ!~8TdhV5j?-}5mZ9Uc?FQT%ebKBbaOgG=kU#lUHZhPg
z;{ke6&BMguOb<6odOm716$hA%4rJ%YmfcEOET1uA>12K=C5&`3PQA{WR<{xN0W(AM
zfIgGamhPU2F`Ue2MSsRLyYj=yL@b&!<KYb4lfr|UM9!2WMe~8~W5}{JKysu4MS+uk
zHhR#sdS~ER@_>r8RTx8QtR6I+&Re0VQAwl>5lat`+8UFcfGe_B(?wwlV>q3)uL}5-
z-N}l%C@`7m9nGN}N#kIS&NS^KpqfP#h6oL%a-n!4dmtOi=CHU^xom4|OK9{^TXS<;
zD3)E_vSwW<8SQHg4dWQKRm6FCtkFrCBj^e_U)yG1R&s9V#zOYS7>>qUpbLVbAhOyb
zZ5F|iY(ACGnvhy6MMN_L2j!UbVO`~itsw;%!-21wJ8NoWYjktnytr|{wc|c>7B_A_
z{{CQ>xp4wduV80!BXc=b5-%5LO5zoQ_W^caZc!;XKQ6{Sg7fNPyh?EXUW|JM=lR8W
zwc!0uF}^??DUk=eMU9v!iTmchcNP1oo!dVZ<9;!PSC6x}@!sd}HFlXBUk2KF17Z`n
zMcv$f%m!mt77N~o731~z4i&INvhEg31n-;dLbt#xRGq6A;|;=J66al_T^ldnx!s`?
z=Ut=|=iQ?d|Gi>Bac;r8v3W7x99V__NjYIrp?$7PAO+wJr;-AZc!vY0H!|t-zFDb@
zb*O0Ajq*59dsHYx)=G^35ODIt`*6~wGKxzpF^{K!mx}+Jz{wB4;5ga(YlYvCwB5wd
zS>PJh)kD0|2G6BbyOUB_cf-2+IdDzfxUSw(`g~r%zOTv3jq98;YpujO{5bGMG;ZpC
z;m5~X-~o1Oqu-MFjq7$Na6i^F&lj6C179R=yifN?oVDiZ&`t1%Z-PG!oZ5BXN6!Ke
z%)6bdy$F1vYpLM<Gz%^e4p02tP{#)1B5)d?{c3znWk4I+Qr{CVLGH)8ZE)Pb&nQ3q
z-Tofs=L6uR?;JM|CW6{^Za->(Q~XZ-M&JSE(@s_cUttGS{TDKx63^#YCWn`Be?KzC
z`7e`3Zpetyw@D-;Mm%i{B-4G-q!CAkl{KRI5u^@7!$}hfOK{!V_3fpV=&NYLh-Na;
zQ3LPz%qVi5=#Xi|^Fu?(I}96VKr>gQI+wl{zx+#OOU9O+;jIxPvaQQNqF3w+DO=Z`
zZQ-rmn~Np#11%t=n?^)e9`vrA!nm(zduO=E*uG`UXCk|dUExk7YEYD)bz|AQ>=Y7&
z|K&rj8IR_o$S3GCaYu*!`>*u{xfr|Qi?LHo-mK5U2&4ELu@TRvjlpOtPT!9y38ehe
zpnS$2F^#SIT<!GTm(42IR(50HlQa(`b+P0J=;BY_#V$oKJ355q4>Xst=pfgSRhyY%
z5lkUh4~9Ftn{v?s#bK`#?8_(c-wTPj2og6K%?^rSd^81r7R9DPN)DQtY$Ba1VhqSK
zW->|!sy3X=iJ<Iy5Y^y78f=a-#~>|BD5d2z1<gUV5C`LM!klGltw_s)>u4c5l!zfF
zn&luyPy}%|3}J->GyC!b(2S-AaO)^Gk?K!#J=)ioF%L3_f7LL#j!`Oc+y0*+$^dYy
z<DF&|&OeztGXc`Imydy=Ei2n|p2{>}S4N$mn+&(0Vz=jfmg!1XRMctT1^hjn-E#Y!
z_cG=9Ic;>NecND<LxQ>Z&nQPsFRFGaEup@%J@)sqd=|gh1kc%X9?g``&n<1s2iJ){
zfQ!ziIeyN!nesb?<7Yjl2VhTU-OO`d&NKiy6=(bwD#RgFXiV9j^LM5bN|D=l_W!7|
z?^Jr6=QGu9_DfKA+CL7A#+B1P-VZRvo4cqu=f41{-JbUiOgoCK>0N3SrcZ#i+fS&D
zGUa&L4f9OD;jriTH&Yia4qM@N8Tt!U?CtaS9;VK1hqM2GsqA_FI6q-ZYujF&_J0E*
zwa@mv|6$r=H%8rQ|2>C2?~|C);jg{$xG{DC70Ug2m^feM|7UaRGtcxVu&uS(^S<jj
z^#P6bpdt(NOn(lP)*iRd`!oK3!5I}luTQq)d8B;;sjxlo<4#jhD7!5(_sjN7DNncC
z&*iDA0d9vKupRR=s1U~ObKd7yhE9Fe9X1#5qDENr9AZ`2{w@d3_Drus&UL%$dey$u
zuT!@MfD<D>31!dELH6y`ZM=#7xccCDzr(=6iaTy%|C4&FMe3iuIPF&}duKoYnI3j1
zuknp#v2%T8KSUiWQu8^rm7h=xF95U^7tbfZf9UzZbC2p=84g(0?GESME-NlXrIh{m
NR#+PMIt(1F_#c<#3$*|M

literal 0
HcmV?d00001

-- 
2.17.1


From b127a0261a06feb9ce83dff6f2a7c2dc5491982e Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 23:14:24 -0500
Subject: [PATCH 5/6] finishing part2

---
 part2/twecho.c | 37 +++++++++++++++++++++++++++++++------
 1 file changed, 31 insertions(+), 6 deletions(-)

diff --git a/part2/twecho.c b/part2/twecho.c
index 741f7a5..7d835b1 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -9,18 +9,43 @@
 
 static char **duplicateArgs(int argc, char **argv)
 {
+       
+
+    // allocate & copy vertical array
+    char **a = malloc( sizeof(char *) * (argc -1)); 
+    //argv++;
+    int j = 1;
+    while( j<argc ){
+        //*a = *argv;
+
+        int len = strlen(argv[j]);
+        char *p = malloc( sizeof(char) * len);
+
+        int i = 0;
+        while(i < len){
+            *(p+i) = toupper( argv[j][i]); // p++
+            i++;
+        }
+        *(a+j)  = p; 
+
+        j++;
+        //a++;
+        //argv++;
+    }
+    return a;
 
-/*
-    while(*argv){
-        printf("%s\n", *argv++);
-    } 
-*/
-    return argv;
 }
 
 static void freeDuplicatedArgs(char **copy)
 {
 
+    //char *q = *copy;
+
+    while(*copy){
+
+        free(*copy++);
+    }
+    free(copy);
 }
 
 /*
-- 
2.17.1


From 0ebda97182471a193a16a6f2545a0bff4cf262ac Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 23:16:55 -0500
Subject: [PATCH 6/6] Modifying README

---
 README.txt | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/README.txt b/README.txt
index 66dfd3e..41ba02f 100644
--- a/README.txt
+++ b/README.txt
@@ -8,4 +8,11 @@ This file should contain:
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
-implemented or how you tried to fix your non-working code.
+implemented or how you tried to fix your non-working code. 
+
+Yixuan Zou
+yz4004
+lab2
+
+part1 works
+part2 works
-- 
2.17.1


--ikeVEW9yuYc//A+q
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab2.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom d3c998e270303d85de5a202ae5a255d4ae38aefa Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 11:55:38 =
-0500=0ASubject: [PATCH 1/6] complete part1=0A=0A---=0A part1/Makefile |  7=
7 +++++++++++++++++++++++++++=0A part1/main.c   | 138 +++++++++++++++++++++=
++++++++++++++++++++++++++++=0A 2 files changed, 215 insertions(+)=0A creat=
e mode 100644 part1/Makefile=0A create mode 100644 part1/main.c=0A=0Adiff -=
-git a/part1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 00000=
00..117cc26=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,77 @@=0A+# =
This Makefile should be used as a template for future Makefiles.=0A+# It's =
heavily commented, so hopefully you can understand what each=0A+# line does=
=2E=0A+=0A+# We'll use gcc for C compilation and g++ for C++ compilation=0A=
+=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+# Let's leave a place holder for add=
itional include directories=0A+=0A+INCLUDES =3D=0A+=0A+# Compilation option=
s:=0A+# -g for debugging info and -Wall enables all warnings=0A+=0A+CFLAGS =
  =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+# Li=
nking options:=0A+# -g for debugging info=0A+=0A+LDFLAGS =3D -g=0A+=0A+# Li=
st the libraries you need to link with in LDLIBS=0A+# For example, use "-lm=
" for the math library=0A+=0A+LDLIBS =3D=0A+=0A+# The 1st target gets built=
 when you type "make".=0A+# It's usually your executable.  ("main" in this =
case.)=0A+#=0A+# Note that we did not specify the linking rule.=0A+# Instea=
d, we rely on one of make's implicit rules:=0A+#=0A+#     $(CC) $(LDFLAGS) =
<all-dependent-.o-files> $(LDLIBS)=0A+#=0A+# Also note that make assumes th=
at main depends on main.o,=0A+# so we can omit it if we want to.=0A+=0A+mai=
n: main.o =0A+	gcc main.o -o isort=0A+# main.o depends not only on main.c, =
but also on myadd.h because=0A+# main.c includes myadd.h.  main.o will get =
recompiled if either=0A+# main.c or myadd.h get modified.=0A+#=0A+# make al=
ready knows main.o depends on main.c, so we can omit main.c=0A+# in the dep=
endency list if we want to.=0A+#=0A+# make uses the following implicit rule=
 to compile a .c file into a .o=0A+# file:=0A+#=0A+#     $(CC) -c $(CFLAGS)=
 <the-.c-file>=0A+#=0A+=0A+main.o: main.c =0A+=0A+# And myadd.o depends on =
myadd.c and myadd.h.=0A+=0A+# myadd.o: myadd.c myadd.h=0A+=0A+# Always prov=
ide the "clean" target that removes intermediate files.=0A+# What you remov=
e depend on your choice of coding tools=0A+# (different editors generate di=
fferent backup files for example).=0A+#=0A+# And the "clean" target is not =
a file name, so we tell make that=0A+# it's a "phony" target.=0A+=0A+.PHONY=
: clean=0A+clean:=0A+	rm -f *.o a.out core main=0A+=0A+# "all" target is us=
eful if your Makefile builds multiple programs.=0A+# Here we'll have it fir=
st do "clean", and rebuild the main target.=0A+=0A+.PHONY: all=0A+all: clea=
n main=0Adiff --git a/part1/main.c b/part1/main.c=0Anew file mode 100644=0A=
index 0000000..27ddd60=0A--- /dev/null=0A+++ b/part1/main.c=0A@@ -0,0 +1,13=
8 @@=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <time.h>=0A+=
=0A+=0A+int *insertSort(int *a, int size);=0A+=0A+void sort_integer_array(i=
nt *begin, int *end, int ascending);=0A+=0A+int main(){=0A+=0A+    srandom(=
time(NULL));=0A+=0A+    // read array size from user=0A+    int size;=0A+  =
  printf("Please input size here: ");=0A+    scanf("%d", &size);=0A+=0A+   =
 // create array=0A+    // int a[size];=0A+    =0A+    int *a =3D (int *) m=
alloc( sizeof(int) * size);=0A+    if (a =3D=3D NULL) {=0A+         perror(=
"malloc returned NULL");=0A+         exit(1);=0A+    }=0A+=0A+    int r;=0A=
+    for(int i=3D0; i<size; i++){=0A+=0A+        r =3D (int) (random()%100)=
;=0A+        *(a+i) =3D r; =0A+        printf("%d %d\n", r, *(a+i));=0A+   =
 }=0A+=0A+=0A+    int *b =3D(int *)  malloc( sizeof(int) * size);=0A+    if=
 (b =3D=3D NULL) {=0A+         perror("malloc returned NULL");=0A+         =
exit(1);=0A+    }=0A+    for(int i=3D0; i<size; i++){=0A+=0A+        *(b+i)=
 =3D *(a+i);=0A+    }=0A+=0A+    int *c =3D (int *) malloc( sizeof(int)* si=
ze);=0A+    if (c =3D=3D NULL) {=0A+         perror("malloc returned NULL")=
;=0A+         exit(1);=0A+    }=0A+    for(int i=3D0; i<=3Dsize; i++){=0A+ =
       *(c+i) =3D *(a+i);=0A+    }=0A+=0A+    sort_integer_array(b, b+size,=
 1); // end b + size - 1=0A+=0A+    sort_integer_array(c, c+size, 0);=0A+=
=0A+=0A+    printf("original:");=0A+    for(int i=3D0; i<size; i++){=0A+   =
     printf("%d  ", a[i]);=0A+    }=0A+    printf("\n");=0A+        =0A+   =
 printf("ascending: ");=0A+    for(int i=3D0; i<size; i++){=0A+        prin=
tf("%d  ", b[i]);=0A+    }=0A+    printf("\n");=0A+=0A+    printf("descendi=
ng: ");=0A+    for(int i=3D0; i<size; i++){=0A+        printf("%d  ", c[i])=
;=0A+    }=0A+    printf("\n");=0A+=0A+    free(a);=0A+    free(b);=0A+    =
free(c);=0A+=0A+    return 0;=0A+}=0A+=0A+=0A+=0A+ /* This function sorts a=
n integer array.=0A+ =0A+ begin points to the 1st element of the array.=0A+=
 end points to ONE PAST the last element of the array.=0A+ If ascending is =
1, the array will be sorted in ascending order.=0A+ If ascending is 0, the =
array will be sorted in descending order.=0A+ */=0A+ void sort_integer_arra=
y(int *begin, int *end, int ascending) =0A+ {=0A+ /* In here, you will call=
 your real sorting function (your own=0A+ * or the qsort()). Basically, I w=
ant to make sure that you=0A+ * know how to translate the begin/end paramet=
er to whatever=0A+ * is required for your sorting function.=0A+ */=0A+ =0A+=
    =0A+    int index =3D 1;=0A+    int temp;=0A+    int current;=0A+    if=
( ascending){=0A+=0A+        while((begin+index) !=3D end ){  // index < si=
ze=0A+=0A+            temp =3D*(begin+index);=0A+            // move curren=
t/curser to the place i, where a[i] < a[index] and a[i+1] > a[index]=0A+   =
         current =3D index;=0A+            while((current >0) &  (*(begin +=
 current-1) > temp)){=0A+                // not index - 1 in last row, but =
compare a[current-1] in condition, and use lazy &=0A+                *(begi=
n + current) =3D *(begin + current-1); // put a[current-1] 1 digit back=0A+=
                current--;                 // current move forward=0A+     =
       }=0A+        *(begin + current) =3D temp;=0A+        index++;=0A+   =
     }=0A+    }else{=0A+        while((begin+index) !=3D end){=0A+         =
   temp =3D *(begin + index);=0A+            // move current/curser to the =
place i, where a[i] < a[index] and a[i+1] > a[index]=0A+            current=
 =3D index;=0A+            while((current >0) &  (*(begin + current-1) < te=
mp)){=0A+                // not index - 1 in last row, but compare a[curren=
t-1] in condition, and use lazy &=0A+                *(begin + current) =3D=
 *(begin + current-1); // put a[current-1] 1 digit back=0A+                =
current--;                 // current move forward=0A+            }=0A+    =
        *(begin + current) =3D temp;=0A+            index++;=0A+   =0A+    =
    }=0A+    }=0A+=0A+}=0A-- =0A2.17.1=0A=0A=0AFrom 14a807c2f789002ce63173f=
65b856eb88f519f76 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@colum=
bia.edu>=0ADate: Sat, 19 Feb 2022 21:04:01 -0500=0ASubject: [PATCH 2/6] par=
t2 step1=0A=0A---=0A part2/Makefile | 77 ++++++++++++++++++++++++++++++++++=
++++++++++++++++=0A part2/twecho.c |  6 ++++=0A 2 files changed, 83 inserti=
ons(+)=0A create mode 100644 part2/Makefile=0A=0Adiff --git a/part2/Makefil=
e b/part2/Makefile=0Anew file mode 100644=0Aindex 0000000..4f96046=0A--- /d=
ev/null=0A+++ b/part2/Makefile=0A@@ -0,0 +1,77 @@=0A+# This Makefile should=
 be used as a template for future Makefiles.=0A+# It's heavily commented, s=
o hopefully you can understand what each=0A+# line does.=0A+=0A+# We'll use=
 gcc for C compilation and g++ for C++ compilation=0A+=0A+CC  =3D gcc=0A+CX=
X =3D g++=0A+=0A+# Let's leave a place holder for additional include direct=
ories=0A+=0A+INCLUDES =3D=0A+=0A+# Compilation options:=0A+# -g for debuggi=
ng info and -Wall enables all warnings=0A+=0A+CFLAGS   =3D -g -Wall $(INCLU=
DES)=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+# Linking options:=0A+# -g=
 for debugging info=0A+=0A+LDFLAGS =3D -g=0A+=0A+# List the libraries you n=
eed to link with in LDLIBS=0A+# For example, use "-lm" for the math library=
=0A+=0A+LDLIBS =3D=0A+=0A+# The 1st target gets built when you type "make".=
=0A+# It's usually your executable.  ("main" in this case.)=0A+#=0A+# Note =
that we did not specify the linking rule.=0A+# Instead, we rely on one of m=
ake's implicit rules:=0A+#=0A+#     $(CC) $(LDFLAGS) <all-dependent-.o-file=
s> $(LDLIBS)=0A+#=0A+# Also note that make assumes that main depends on mai=
n.o,=0A+# so we can omit it if we want to.=0A+=0A+main: twecho.o =0A+	gcc t=
wecho.o -o twecho=0A+# main.o depends not only on main.c, but also on myadd=
=2Eh because=0A+# main.c includes myadd.h.  main.o will get recompiled if e=
ither=0A+# main.c or myadd.h get modified.=0A+#=0A+# make already knows mai=
n.o depends on main.c, so we can omit main.c=0A+# in the dependency list if=
 we want to.=0A+#=0A+# make uses the following implicit rule to compile a .=
c file into a .o=0A+# file:=0A+#=0A+#     $(CC) -c $(CFLAGS) <the-.c-file>=
=0A+#=0A+=0A+twecho.o: twecho.c =0A+=0A+# And myadd.o depends on myadd.c an=
d myadd.h.=0A+=0A+# myadd.o: myadd.c myadd.h=0A+=0A+# Always provide the "c=
lean" target that removes intermediate files.=0A+# What you remove depend o=
n your choice of coding tools=0A+# (different editors generate different ba=
ckup files for example).=0A+#=0A+# And the "clean" target is not a file nam=
e, so we tell make that=0A+# it's a "phony" target.=0A+=0A+.PHONY: clean=0A=
+clean:=0A+	rm -f *.o a.out core main=0A+=0A+# "all" target is useful if yo=
ur Makefile builds multiple programs.=0A+# Here we'll have it first do "cle=
an", and rebuild the main target.=0A+=0A+.PHONY: all=0A+all: clean main=0Ad=
iff --git a/part2/twecho.c b/part2/twecho.c=0Aindex c70e975..741f7a5 100644=
=0A--- a/part2/twecho.c=0A+++ b/part2/twecho.c=0A@@ -10,6 +10,12 @@=0A stat=
ic char **duplicateArgs(int argc, char **argv)=0A {=0A =0A+/*=0A+    while(=
*argv){=0A+        printf("%s\n", *argv++);=0A+    } =0A+*/=0A+    return a=
rgv;=0A }=0A =0A static void freeDuplicatedArgs(char **copy)=0A-- =0A2.17.1=
=0A=0A=0AFrom a399955d3253134fb2f380a0903180094256bece Mon Sep 17 00:00:00 =
2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 21:4=
2:55 -0500=0ASubject: [PATCH 3/6] Add reference for sort algorithm=0A=0A---=
=0A part1/main.c | 12 ++++++------=0A 1 file changed, 6 insertions(+), 6 de=
letions(-)=0A=0Adiff --git a/part1/main.c b/part1/main.c=0Aindex 27ddd60..9=
a99813 100644=0A--- a/part1/main.c=0A+++ b/part1/main.c=0A@@ -2,9 +2,6 @@=
=0A #include <stdlib.h>=0A #include <time.h>=0A =0A-=0A-int *insertSort(int=
 *a, int size);=0A-=0A void sort_integer_array(int *begin, int *end, int as=
cending);=0A =0A int main(){=0A@@ -24,16 +21,14 @@ int main(){=0A          =
perror("malloc returned NULL");=0A          exit(1);=0A     }=0A-=0A     in=
t r;=0A     for(int i=3D0; i<size; i++){=0A =0A         r =3D (int) (random=
()%100);=0A         *(a+i) =3D r; =0A-        printf("%d %d\n", r, *(a+i));=
=0A+        //printf("%d %d\n", r, *(a+i));=0A     }=0A =0A-=0A     int *b =
=3D(int *)  malloc( sizeof(int) * size);=0A     if (b =3D=3D NULL) {=0A    =
      perror("malloc returned NULL");=0A@@ -98,6 +93,11 @@ int main(){=0A  =
* or the qsort()). Basically, I want to make sure that you=0A  * know how t=
o translate the begin/end parameter to whatever=0A  * is required for your =
sorting function.=0A+ *=0A+ *=0A+ * Insertion Sort. =0A+ * From the lecture=
 note of COMSW 3134=0A+ *=0A  */=0A  =0A     =0A-- =0A2.17.1=0A=0A=0AFrom 3=
5a35e52ad2bfe8de3a6637c8a9c9880ef8e4411 Mon Sep 17 00:00:00 2001=0AFrom: Yi=
xuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 22:42:59 -0500=0ASu=
bject: [PATCH 4/6] finishing part2 step2=0A=0A---=0A part2/twecho | Bin 0 -=
> 11392 bytes=0A 1 file changed, 0 insertions(+), 0 deletions(-)=0A create =
mode 100755 part2/twecho=0A=0Adiff --git a/part2/twecho b/part2/twecho=0Ane=
w file mode 100755=0Aindex 0000000000000000000000000000000000000000..18e341=
b1f659368d3eee676f9fff61ac9ff6b5ca=0AGIT binary patch=0Aliteral 11392=0Azcm=
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
-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 0=0AHcmV?d00001=0A=0A-- =0A2.=
17.1=0A=0A=0AFrom b127a0261a06feb9ce83dff6f2a7c2dc5491982e Mon Sep 17 00:00=
:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 =
23:14:24 -0500=0ASubject: [PATCH 5/6] finishing part2=0A=0A---=0A part2/twe=
cho.c | 37 +++++++++++++++++++++++++++++++------=0A 1 file changed, 31 inse=
rtions(+), 6 deletions(-)=0A=0Adiff --git a/part2/twecho.c b/part2/twecho.c=
=0Aindex 741f7a5..7d835b1 100644=0A--- a/part2/twecho.c=0A+++ b/part2/twech=
o.c=0A@@ -9,18 +9,43 @@=0A =0A static char **duplicateArgs(int argc, char *=
*argv)=0A {=0A+       =0A+=0A+    // allocate & copy vertical array=0A+    =
char **a =3D malloc( sizeof(char *) * (argc -1)); =0A+    //argv++;=0A+    =
int j =3D 1;=0A+    while( j<argc ){=0A+        //*a =3D *argv;=0A+=0A+    =
    int len =3D strlen(argv[j]);=0A+        char *p =3D malloc( sizeof(char=
) * len);=0A+=0A+        int i =3D 0;=0A+        while(i < len){=0A+       =
     *(p+i) =3D toupper( argv[j][i]); // p++=0A+            i++;=0A+       =
 }=0A+        *(a+j)  =3D p; =0A+=0A+        j++;=0A+        //a++;=0A+    =
    //argv++;=0A+    }=0A+    return a;=0A =0A-/*=0A-    while(*argv){=0A- =
       printf("%s\n", *argv++);=0A-    } =0A-*/=0A-    return argv;=0A }=0A=
 =0A static void freeDuplicatedArgs(char **copy)=0A {=0A =0A+    //char *q =
=3D *copy;=0A+=0A+    while(*copy){=0A+=0A+        free(*copy++);=0A+    }=
=0A+    free(copy);=0A }=0A =0A /*=0A-- =0A2.17.1=0A=0A=0AFrom 0ebda9718247=
1a193a16a6f2545a0bff4cf262ac Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <y=
z4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 23:16:55 -0500=0ASubject: [PAT=
CH 6/6] Modifying README=0A=0A---=0A README.txt | 9 ++++++++-=0A 1 file cha=
nged, 8 insertions(+), 1 deletion(-)=0A=0Adiff --git a/README.txt b/README.=
txt=0Aindex 66dfd3e..41ba02f 100644=0A--- a/README.txt=0A+++ b/README.txt=
=0A@@ -8,4 +8,11 @@ This file should contain:=0A The description should ind=
icate whether your solution for the part is=0A working or not.  You may als=
o want to include anything else you would=0A like to communicate to the gra=
der such as extra functionalities you=0A-implemented or how you tried to fi=
x your non-working code.=0A+implemented or how you tried to fix your non-wo=
rking code. =0A+=0A+Yixuan Zou=0A+yz4004=0A+lab2=0A+=0A+part1 works=0A+part=
2 works=0A-- =0A2.17.1=0A=0A
--ikeVEW9yuYc//A+q--

From do.not.reply@cloud.cs.columbia.edu Sat Feb 19 23:25:10 2022
Date: Sat, 19 Feb 2022 23:25:10 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab2.mbox
Message-ID: <20220220042510.GA19017@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="FL5UXtIhxfXey3p5"
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 53451
Lines: 1106


--FL5UXtIhxfXey3p5
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From d3c998e270303d85de5a202ae5a255d4ae38aefa Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 11:55:38 -0500
Subject: [PATCH 1/7] complete part1

---
 part1/Makefile |  77 +++++++++++++++++++++++++++
 part1/main.c   | 138 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 215 insertions(+)
 create mode 100644 part1/Makefile
 create mode 100644 part1/main.c

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..117cc26
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,77 @@
+# This Makefile should be used as a template for future Makefiles.
+# It's heavily commented, so hopefully you can understand what each
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+# Linking options:
+# -g for debugging info
+
+LDFLAGS = -g
+
+# List the libraries you need to link with in LDLIBS
+# For example, use "-lm" for the math library
+
+LDLIBS =
+
+# The 1st target gets built when you type "make".
+# It's usually your executable.  ("main" in this case.)
+#
+# Note that we did not specify the linking rule.
+# Instead, we rely on one of make's implicit rules:
+#
+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)
+#
+# Also note that make assumes that main depends on main.o,
+# so we can omit it if we want to.
+
+main: main.o 
+	gcc main.o -o isort
+# main.o depends not only on main.c, but also on myadd.h because
+# main.c includes myadd.h.  main.o will get recompiled if either
+# main.c or myadd.h get modified.
+#
+# make already knows main.o depends on main.c, so we can omit main.c
+# in the dependency list if we want to.
+#
+# make uses the following implicit rule to compile a .c file into a .o
+# file:
+#
+#     $(CC) -c $(CFLAGS) <the-.c-file>
+#
+
+main.o: main.c 
+
+# And myadd.o depends on myadd.c and myadd.h.
+
+# myadd.o: myadd.c myadd.h
+
+# Always provide the "clean" target that removes intermediate files.
+# What you remove depend on your choice of coding tools
+# (different editors generate different backup files for example).
+#
+# And the "clean" target is not a file name, so we tell make that
+# it's a "phony" target.
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
diff --git a/part1/main.c b/part1/main.c
new file mode 100644
index 0000000..27ddd60
--- /dev/null
+++ b/part1/main.c
@@ -0,0 +1,138 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+
+int *insertSort(int *a, int size);
+
+void sort_integer_array(int *begin, int *end, int ascending);
+
+int main(){
+
+    srandom(time(NULL));
+
+    // read array size from user
+    int size;
+    printf("Please input size here: ");
+    scanf("%d", &size);
+
+    // create array
+    // int a[size];
+    
+    int *a = (int *) malloc( sizeof(int) * size);
+    if (a == NULL) {
+         perror("malloc returned NULL");
+         exit(1);
+    }
+
+    int r;
+    for(int i=0; i<size; i++){
+
+        r = (int) (random()%100);
+        *(a+i) = r; 
+        printf("%d %d\n", r, *(a+i));
+    }
+
+
+    int *b =(int *)  malloc( sizeof(int) * size);
+    if (b == NULL) {
+         perror("malloc returned NULL");
+         exit(1);
+    }
+    for(int i=0; i<size; i++){
+
+        *(b+i) = *(a+i);
+    }
+
+    int *c = (int *) malloc( sizeof(int)* size);
+    if (c == NULL) {
+         perror("malloc returned NULL");
+         exit(1);
+    }
+    for(int i=0; i<=size; i++){
+        *(c+i) = *(a+i);
+    }
+
+    sort_integer_array(b, b+size, 1); // end b + size - 1
+
+    sort_integer_array(c, c+size, 0);
+
+
+    printf("original:");
+    for(int i=0; i<size; i++){
+        printf("%d  ", a[i]);
+    }
+    printf("\n");
+        
+    printf("ascending: ");
+    for(int i=0; i<size; i++){
+        printf("%d  ", b[i]);
+    }
+    printf("\n");
+
+    printf("descending: ");
+    for(int i=0; i<size; i++){
+        printf("%d  ", c[i]);
+    }
+    printf("\n");
+
+    free(a);
+    free(b);
+    free(c);
+
+    return 0;
+}
+
+
+
+ /* This function sorts an integer array.
+ 
+ begin points to the 1st element of the array.
+ end points to ONE PAST the last element of the array.
+ If ascending is 1, the array will be sorted in ascending order.
+ If ascending is 0, the array will be sorted in descending order.
+ */
+ void sort_integer_array(int *begin, int *end, int ascending) 
+ {
+ /* In here, you will call your real sorting function (your own
+ * or the qsort()). Basically, I want to make sure that you
+ * know how to translate the begin/end parameter to whatever
+ * is required for your sorting function.
+ */
+ 
+    
+    int index = 1;
+    int temp;
+    int current;
+    if( ascending){
+
+        while((begin+index) != end ){  // index < size
+
+            temp =*(begin+index);
+            // move current/curser to the place i, where a[i] < a[index] and a[i+1] > a[index]
+            current = index;
+            while((current >0) &  (*(begin + current-1) > temp)){
+                // not index - 1 in last row, but compare a[current-1] in condition, and use lazy &
+                *(begin + current) = *(begin + current-1); // put a[current-1] 1 digit back
+                current--;                 // current move forward
+            }
+        *(begin + current) = temp;
+        index++;
+        }
+    }else{
+        while((begin+index) != end){
+            temp = *(begin + index);
+            // move current/curser to the place i, where a[i] < a[index] and a[i+1] > a[index]
+            current = index;
+            while((current >0) &  (*(begin + current-1) < temp)){
+                // not index - 1 in last row, but compare a[current-1] in condition, and use lazy &
+                *(begin + current) = *(begin + current-1); // put a[current-1] 1 digit back
+                current--;                 // current move forward
+            }
+            *(begin + current) = temp;
+            index++;
+   
+        }
+    }
+
+}
-- 
2.17.1


From 14a807c2f789002ce63173f65b856eb88f519f76 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 21:04:01 -0500
Subject: [PATCH 2/7] part2 step1

---
 part2/Makefile | 77 ++++++++++++++++++++++++++++++++++++++++++++++++++
 part2/twecho.c |  6 ++++
 2 files changed, 83 insertions(+)
 create mode 100644 part2/Makefile

diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..4f96046
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,77 @@
+# This Makefile should be used as a template for future Makefiles.
+# It's heavily commented, so hopefully you can understand what each
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+# Linking options:
+# -g for debugging info
+
+LDFLAGS = -g
+
+# List the libraries you need to link with in LDLIBS
+# For example, use "-lm" for the math library
+
+LDLIBS =
+
+# The 1st target gets built when you type "make".
+# It's usually your executable.  ("main" in this case.)
+#
+# Note that we did not specify the linking rule.
+# Instead, we rely on one of make's implicit rules:
+#
+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)
+#
+# Also note that make assumes that main depends on main.o,
+# so we can omit it if we want to.
+
+main: twecho.o 
+	gcc twecho.o -o twecho
+# main.o depends not only on main.c, but also on myadd.h because
+# main.c includes myadd.h.  main.o will get recompiled if either
+# main.c or myadd.h get modified.
+#
+# make already knows main.o depends on main.c, so we can omit main.c
+# in the dependency list if we want to.
+#
+# make uses the following implicit rule to compile a .c file into a .o
+# file:
+#
+#     $(CC) -c $(CFLAGS) <the-.c-file>
+#
+
+twecho.o: twecho.c 
+
+# And myadd.o depends on myadd.c and myadd.h.
+
+# myadd.o: myadd.c myadd.h
+
+# Always provide the "clean" target that removes intermediate files.
+# What you remove depend on your choice of coding tools
+# (different editors generate different backup files for example).
+#
+# And the "clean" target is not a file name, so we tell make that
+# it's a "phony" target.
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
diff --git a/part2/twecho.c b/part2/twecho.c
index c70e975..741f7a5 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -10,6 +10,12 @@
 static char **duplicateArgs(int argc, char **argv)
 {
 
+/*
+    while(*argv){
+        printf("%s\n", *argv++);
+    } 
+*/
+    return argv;
 }
 
 static void freeDuplicatedArgs(char **copy)
-- 
2.17.1


From a399955d3253134fb2f380a0903180094256bece Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 21:42:55 -0500
Subject: [PATCH 3/7] Add reference for sort algorithm

---
 part1/main.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/part1/main.c b/part1/main.c
index 27ddd60..9a99813 100644
--- a/part1/main.c
+++ b/part1/main.c
@@ -2,9 +2,6 @@
 #include <stdlib.h>
 #include <time.h>
 
-
-int *insertSort(int *a, int size);
-
 void sort_integer_array(int *begin, int *end, int ascending);
 
 int main(){
@@ -24,16 +21,14 @@ int main(){
          perror("malloc returned NULL");
          exit(1);
     }
-
     int r;
     for(int i=0; i<size; i++){
 
         r = (int) (random()%100);
         *(a+i) = r; 
-        printf("%d %d\n", r, *(a+i));
+        //printf("%d %d\n", r, *(a+i));
     }
 
-
     int *b =(int *)  malloc( sizeof(int) * size);
     if (b == NULL) {
          perror("malloc returned NULL");
@@ -98,6 +93,11 @@ int main(){
  * or the qsort()). Basically, I want to make sure that you
  * know how to translate the begin/end parameter to whatever
  * is required for your sorting function.
+ *
+ *
+ * Insertion Sort. 
+ * From the lecture note of COMSW 3134
+ *
  */
  
     
-- 
2.17.1


From 35a35e52ad2bfe8de3a6637c8a9c9880ef8e4411 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 22:42:59 -0500
Subject: [PATCH 4/7] finishing part2 step2

---
 part2/twecho | Bin 0 -> 11392 bytes
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100755 part2/twecho

diff --git a/part2/twecho b/part2/twecho
new file mode 100755
index 0000000000000000000000000000000000000000..18e341b1f659368d3eee676f9fff61ac9ff6b5ca
GIT binary patch
literal 11392
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
NR#+PMIt(1F_#c<#3$*|M

literal 0
HcmV?d00001

-- 
2.17.1


From b127a0261a06feb9ce83dff6f2a7c2dc5491982e Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 23:14:24 -0500
Subject: [PATCH 5/7] finishing part2

---
 part2/twecho.c | 37 +++++++++++++++++++++++++++++++------
 1 file changed, 31 insertions(+), 6 deletions(-)

diff --git a/part2/twecho.c b/part2/twecho.c
index 741f7a5..7d835b1 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -9,18 +9,43 @@
 
 static char **duplicateArgs(int argc, char **argv)
 {
+       
+
+    // allocate & copy vertical array
+    char **a = malloc( sizeof(char *) * (argc -1)); 
+    //argv++;
+    int j = 1;
+    while( j<argc ){
+        //*a = *argv;
+
+        int len = strlen(argv[j]);
+        char *p = malloc( sizeof(char) * len);
+
+        int i = 0;
+        while(i < len){
+            *(p+i) = toupper( argv[j][i]); // p++
+            i++;
+        }
+        *(a+j)  = p; 
+
+        j++;
+        //a++;
+        //argv++;
+    }
+    return a;
 
-/*
-    while(*argv){
-        printf("%s\n", *argv++);
-    } 
-*/
-    return argv;
 }
 
 static void freeDuplicatedArgs(char **copy)
 {
 
+    //char *q = *copy;
+
+    while(*copy){
+
+        free(*copy++);
+    }
+    free(copy);
 }
 
 /*
-- 
2.17.1


From 0ebda97182471a193a16a6f2545a0bff4cf262ac Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 23:16:55 -0500
Subject: [PATCH 6/7] Modifying README

---
 README.txt | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/README.txt b/README.txt
index 66dfd3e..41ba02f 100644
--- a/README.txt
+++ b/README.txt
@@ -8,4 +8,11 @@ This file should contain:
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
-implemented or how you tried to fix your non-working code.
+implemented or how you tried to fix your non-working code. 
+
+Yixuan Zou
+yz4004
+lab2
+
+part1 works
+part2 works
-- 
2.17.1


From 1a61051652ab72d211a461d30e160d3cb39a45c1 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 23:24:39 -0500
Subject: [PATCH 7/7] remove *twecho

---
 part2/twecho | Bin 11392 -> 0 bytes
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100755 part2/twecho

diff --git a/part2/twecho b/part2/twecho
deleted file mode 100755
index 18e341b1f659368d3eee676f9fff61ac9ff6b5ca..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 11392
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
NR#+PMIt(1F_#c<#3$*|M

-- 
2.17.1


--FL5UXtIhxfXey3p5
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab2.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom d3c998e270303d85de5a202ae5a255d4ae38aefa Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 11:55:38 =
-0500=0ASubject: [PATCH 1/7] complete part1=0A=0A---=0A part1/Makefile |  7=
7 +++++++++++++++++++++++++++=0A part1/main.c   | 138 +++++++++++++++++++++=
++++++++++++++++++++++++++++=0A 2 files changed, 215 insertions(+)=0A creat=
e mode 100644 part1/Makefile=0A create mode 100644 part1/main.c=0A=0Adiff -=
-git a/part1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 00000=
00..117cc26=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,77 @@=0A+# =
This Makefile should be used as a template for future Makefiles.=0A+# It's =
heavily commented, so hopefully you can understand what each=0A+# line does=
=2E=0A+=0A+# We'll use gcc for C compilation and g++ for C++ compilation=0A=
+=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+# Let's leave a place holder for add=
itional include directories=0A+=0A+INCLUDES =3D=0A+=0A+# Compilation option=
s:=0A+# -g for debugging info and -Wall enables all warnings=0A+=0A+CFLAGS =
  =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+# Li=
nking options:=0A+# -g for debugging info=0A+=0A+LDFLAGS =3D -g=0A+=0A+# Li=
st the libraries you need to link with in LDLIBS=0A+# For example, use "-lm=
" for the math library=0A+=0A+LDLIBS =3D=0A+=0A+# The 1st target gets built=
 when you type "make".=0A+# It's usually your executable.  ("main" in this =
case.)=0A+#=0A+# Note that we did not specify the linking rule.=0A+# Instea=
d, we rely on one of make's implicit rules:=0A+#=0A+#     $(CC) $(LDFLAGS) =
<all-dependent-.o-files> $(LDLIBS)=0A+#=0A+# Also note that make assumes th=
at main depends on main.o,=0A+# so we can omit it if we want to.=0A+=0A+mai=
n: main.o =0A+	gcc main.o -o isort=0A+# main.o depends not only on main.c, =
but also on myadd.h because=0A+# main.c includes myadd.h.  main.o will get =
recompiled if either=0A+# main.c or myadd.h get modified.=0A+#=0A+# make al=
ready knows main.o depends on main.c, so we can omit main.c=0A+# in the dep=
endency list if we want to.=0A+#=0A+# make uses the following implicit rule=
 to compile a .c file into a .o=0A+# file:=0A+#=0A+#     $(CC) -c $(CFLAGS)=
 <the-.c-file>=0A+#=0A+=0A+main.o: main.c =0A+=0A+# And myadd.o depends on =
myadd.c and myadd.h.=0A+=0A+# myadd.o: myadd.c myadd.h=0A+=0A+# Always prov=
ide the "clean" target that removes intermediate files.=0A+# What you remov=
e depend on your choice of coding tools=0A+# (different editors generate di=
fferent backup files for example).=0A+#=0A+# And the "clean" target is not =
a file name, so we tell make that=0A+# it's a "phony" target.=0A+=0A+.PHONY=
: clean=0A+clean:=0A+	rm -f *.o a.out core main=0A+=0A+# "all" target is us=
eful if your Makefile builds multiple programs.=0A+# Here we'll have it fir=
st do "clean", and rebuild the main target.=0A+=0A+.PHONY: all=0A+all: clea=
n main=0Adiff --git a/part1/main.c b/part1/main.c=0Anew file mode 100644=0A=
index 0000000..27ddd60=0A--- /dev/null=0A+++ b/part1/main.c=0A@@ -0,0 +1,13=
8 @@=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <time.h>=0A+=
=0A+=0A+int *insertSort(int *a, int size);=0A+=0A+void sort_integer_array(i=
nt *begin, int *end, int ascending);=0A+=0A+int main(){=0A+=0A+    srandom(=
time(NULL));=0A+=0A+    // read array size from user=0A+    int size;=0A+  =
  printf("Please input size here: ");=0A+    scanf("%d", &size);=0A+=0A+   =
 // create array=0A+    // int a[size];=0A+    =0A+    int *a =3D (int *) m=
alloc( sizeof(int) * size);=0A+    if (a =3D=3D NULL) {=0A+         perror(=
"malloc returned NULL");=0A+         exit(1);=0A+    }=0A+=0A+    int r;=0A=
+    for(int i=3D0; i<size; i++){=0A+=0A+        r =3D (int) (random()%100)=
;=0A+        *(a+i) =3D r; =0A+        printf("%d %d\n", r, *(a+i));=0A+   =
 }=0A+=0A+=0A+    int *b =3D(int *)  malloc( sizeof(int) * size);=0A+    if=
 (b =3D=3D NULL) {=0A+         perror("malloc returned NULL");=0A+         =
exit(1);=0A+    }=0A+    for(int i=3D0; i<size; i++){=0A+=0A+        *(b+i)=
 =3D *(a+i);=0A+    }=0A+=0A+    int *c =3D (int *) malloc( sizeof(int)* si=
ze);=0A+    if (c =3D=3D NULL) {=0A+         perror("malloc returned NULL")=
;=0A+         exit(1);=0A+    }=0A+    for(int i=3D0; i<=3Dsize; i++){=0A+ =
       *(c+i) =3D *(a+i);=0A+    }=0A+=0A+    sort_integer_array(b, b+size,=
 1); // end b + size - 1=0A+=0A+    sort_integer_array(c, c+size, 0);=0A+=
=0A+=0A+    printf("original:");=0A+    for(int i=3D0; i<size; i++){=0A+   =
     printf("%d  ", a[i]);=0A+    }=0A+    printf("\n");=0A+        =0A+   =
 printf("ascending: ");=0A+    for(int i=3D0; i<size; i++){=0A+        prin=
tf("%d  ", b[i]);=0A+    }=0A+    printf("\n");=0A+=0A+    printf("descendi=
ng: ");=0A+    for(int i=3D0; i<size; i++){=0A+        printf("%d  ", c[i])=
;=0A+    }=0A+    printf("\n");=0A+=0A+    free(a);=0A+    free(b);=0A+    =
free(c);=0A+=0A+    return 0;=0A+}=0A+=0A+=0A+=0A+ /* This function sorts a=
n integer array.=0A+ =0A+ begin points to the 1st element of the array.=0A+=
 end points to ONE PAST the last element of the array.=0A+ If ascending is =
1, the array will be sorted in ascending order.=0A+ If ascending is 0, the =
array will be sorted in descending order.=0A+ */=0A+ void sort_integer_arra=
y(int *begin, int *end, int ascending) =0A+ {=0A+ /* In here, you will call=
 your real sorting function (your own=0A+ * or the qsort()). Basically, I w=
ant to make sure that you=0A+ * know how to translate the begin/end paramet=
er to whatever=0A+ * is required for your sorting function.=0A+ */=0A+ =0A+=
    =0A+    int index =3D 1;=0A+    int temp;=0A+    int current;=0A+    if=
( ascending){=0A+=0A+        while((begin+index) !=3D end ){  // index < si=
ze=0A+=0A+            temp =3D*(begin+index);=0A+            // move curren=
t/curser to the place i, where a[i] < a[index] and a[i+1] > a[index]=0A+   =
         current =3D index;=0A+            while((current >0) &  (*(begin +=
 current-1) > temp)){=0A+                // not index - 1 in last row, but =
compare a[current-1] in condition, and use lazy &=0A+                *(begi=
n + current) =3D *(begin + current-1); // put a[current-1] 1 digit back=0A+=
                current--;                 // current move forward=0A+     =
       }=0A+        *(begin + current) =3D temp;=0A+        index++;=0A+   =
     }=0A+    }else{=0A+        while((begin+index) !=3D end){=0A+         =
   temp =3D *(begin + index);=0A+            // move current/curser to the =
place i, where a[i] < a[index] and a[i+1] > a[index]=0A+            current=
 =3D index;=0A+            while((current >0) &  (*(begin + current-1) < te=
mp)){=0A+                // not index - 1 in last row, but compare a[curren=
t-1] in condition, and use lazy &=0A+                *(begin + current) =3D=
 *(begin + current-1); // put a[current-1] 1 digit back=0A+                =
current--;                 // current move forward=0A+            }=0A+    =
        *(begin + current) =3D temp;=0A+            index++;=0A+   =0A+    =
    }=0A+    }=0A+=0A+}=0A-- =0A2.17.1=0A=0A=0AFrom 14a807c2f789002ce63173f=
65b856eb88f519f76 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@colum=
bia.edu>=0ADate: Sat, 19 Feb 2022 21:04:01 -0500=0ASubject: [PATCH 2/7] par=
t2 step1=0A=0A---=0A part2/Makefile | 77 ++++++++++++++++++++++++++++++++++=
++++++++++++++++=0A part2/twecho.c |  6 ++++=0A 2 files changed, 83 inserti=
ons(+)=0A create mode 100644 part2/Makefile=0A=0Adiff --git a/part2/Makefil=
e b/part2/Makefile=0Anew file mode 100644=0Aindex 0000000..4f96046=0A--- /d=
ev/null=0A+++ b/part2/Makefile=0A@@ -0,0 +1,77 @@=0A+# This Makefile should=
 be used as a template for future Makefiles.=0A+# It's heavily commented, s=
o hopefully you can understand what each=0A+# line does.=0A+=0A+# We'll use=
 gcc for C compilation and g++ for C++ compilation=0A+=0A+CC  =3D gcc=0A+CX=
X =3D g++=0A+=0A+# Let's leave a place holder for additional include direct=
ories=0A+=0A+INCLUDES =3D=0A+=0A+# Compilation options:=0A+# -g for debuggi=
ng info and -Wall enables all warnings=0A+=0A+CFLAGS   =3D -g -Wall $(INCLU=
DES)=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+# Linking options:=0A+# -g=
 for debugging info=0A+=0A+LDFLAGS =3D -g=0A+=0A+# List the libraries you n=
eed to link with in LDLIBS=0A+# For example, use "-lm" for the math library=
=0A+=0A+LDLIBS =3D=0A+=0A+# The 1st target gets built when you type "make".=
=0A+# It's usually your executable.  ("main" in this case.)=0A+#=0A+# Note =
that we did not specify the linking rule.=0A+# Instead, we rely on one of m=
ake's implicit rules:=0A+#=0A+#     $(CC) $(LDFLAGS) <all-dependent-.o-file=
s> $(LDLIBS)=0A+#=0A+# Also note that make assumes that main depends on mai=
n.o,=0A+# so we can omit it if we want to.=0A+=0A+main: twecho.o =0A+	gcc t=
wecho.o -o twecho=0A+# main.o depends not only on main.c, but also on myadd=
=2Eh because=0A+# main.c includes myadd.h.  main.o will get recompiled if e=
ither=0A+# main.c or myadd.h get modified.=0A+#=0A+# make already knows mai=
n.o depends on main.c, so we can omit main.c=0A+# in the dependency list if=
 we want to.=0A+#=0A+# make uses the following implicit rule to compile a .=
c file into a .o=0A+# file:=0A+#=0A+#     $(CC) -c $(CFLAGS) <the-.c-file>=
=0A+#=0A+=0A+twecho.o: twecho.c =0A+=0A+# And myadd.o depends on myadd.c an=
d myadd.h.=0A+=0A+# myadd.o: myadd.c myadd.h=0A+=0A+# Always provide the "c=
lean" target that removes intermediate files.=0A+# What you remove depend o=
n your choice of coding tools=0A+# (different editors generate different ba=
ckup files for example).=0A+#=0A+# And the "clean" target is not a file nam=
e, so we tell make that=0A+# it's a "phony" target.=0A+=0A+.PHONY: clean=0A=
+clean:=0A+	rm -f *.o a.out core main=0A+=0A+# "all" target is useful if yo=
ur Makefile builds multiple programs.=0A+# Here we'll have it first do "cle=
an", and rebuild the main target.=0A+=0A+.PHONY: all=0A+all: clean main=0Ad=
iff --git a/part2/twecho.c b/part2/twecho.c=0Aindex c70e975..741f7a5 100644=
=0A--- a/part2/twecho.c=0A+++ b/part2/twecho.c=0A@@ -10,6 +10,12 @@=0A stat=
ic char **duplicateArgs(int argc, char **argv)=0A {=0A =0A+/*=0A+    while(=
*argv){=0A+        printf("%s\n", *argv++);=0A+    } =0A+*/=0A+    return a=
rgv;=0A }=0A =0A static void freeDuplicatedArgs(char **copy)=0A-- =0A2.17.1=
=0A=0A=0AFrom a399955d3253134fb2f380a0903180094256bece Mon Sep 17 00:00:00 =
2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 21:4=
2:55 -0500=0ASubject: [PATCH 3/7] Add reference for sort algorithm=0A=0A---=
=0A part1/main.c | 12 ++++++------=0A 1 file changed, 6 insertions(+), 6 de=
letions(-)=0A=0Adiff --git a/part1/main.c b/part1/main.c=0Aindex 27ddd60..9=
a99813 100644=0A--- a/part1/main.c=0A+++ b/part1/main.c=0A@@ -2,9 +2,6 @@=
=0A #include <stdlib.h>=0A #include <time.h>=0A =0A-=0A-int *insertSort(int=
 *a, int size);=0A-=0A void sort_integer_array(int *begin, int *end, int as=
cending);=0A =0A int main(){=0A@@ -24,16 +21,14 @@ int main(){=0A          =
perror("malloc returned NULL");=0A          exit(1);=0A     }=0A-=0A     in=
t r;=0A     for(int i=3D0; i<size; i++){=0A =0A         r =3D (int) (random=
()%100);=0A         *(a+i) =3D r; =0A-        printf("%d %d\n", r, *(a+i));=
=0A+        //printf("%d %d\n", r, *(a+i));=0A     }=0A =0A-=0A     int *b =
=3D(int *)  malloc( sizeof(int) * size);=0A     if (b =3D=3D NULL) {=0A    =
      perror("malloc returned NULL");=0A@@ -98,6 +93,11 @@ int main(){=0A  =
* or the qsort()). Basically, I want to make sure that you=0A  * know how t=
o translate the begin/end parameter to whatever=0A  * is required for your =
sorting function.=0A+ *=0A+ *=0A+ * Insertion Sort. =0A+ * From the lecture=
 note of COMSW 3134=0A+ *=0A  */=0A  =0A     =0A-- =0A2.17.1=0A=0A=0AFrom 3=
5a35e52ad2bfe8de3a6637c8a9c9880ef8e4411 Mon Sep 17 00:00:00 2001=0AFrom: Yi=
xuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 22:42:59 -0500=0ASu=
bject: [PATCH 4/7] finishing part2 step2=0A=0A---=0A part2/twecho | Bin 0 -=
> 11392 bytes=0A 1 file changed, 0 insertions(+), 0 deletions(-)=0A create =
mode 100755 part2/twecho=0A=0Adiff --git a/part2/twecho b/part2/twecho=0Ane=
w file mode 100755=0Aindex 0000000000000000000000000000000000000000..18e341=
b1f659368d3eee676f9fff61ac9ff6b5ca=0AGIT binary patch=0Aliteral 11392=0Azcm=
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
-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 0=0AHcmV?d00001=0A=0A-- =0A2.=
17.1=0A=0A=0AFrom b127a0261a06feb9ce83dff6f2a7c2dc5491982e Mon Sep 17 00:00=
:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 =
23:14:24 -0500=0ASubject: [PATCH 5/7] finishing part2=0A=0A---=0A part2/twe=
cho.c | 37 +++++++++++++++++++++++++++++++------=0A 1 file changed, 31 inse=
rtions(+), 6 deletions(-)=0A=0Adiff --git a/part2/twecho.c b/part2/twecho.c=
=0Aindex 741f7a5..7d835b1 100644=0A--- a/part2/twecho.c=0A+++ b/part2/twech=
o.c=0A@@ -9,18 +9,43 @@=0A =0A static char **duplicateArgs(int argc, char *=
*argv)=0A {=0A+       =0A+=0A+    // allocate & copy vertical array=0A+    =
char **a =3D malloc( sizeof(char *) * (argc -1)); =0A+    //argv++;=0A+    =
int j =3D 1;=0A+    while( j<argc ){=0A+        //*a =3D *argv;=0A+=0A+    =
    int len =3D strlen(argv[j]);=0A+        char *p =3D malloc( sizeof(char=
) * len);=0A+=0A+        int i =3D 0;=0A+        while(i < len){=0A+       =
     *(p+i) =3D toupper( argv[j][i]); // p++=0A+            i++;=0A+       =
 }=0A+        *(a+j)  =3D p; =0A+=0A+        j++;=0A+        //a++;=0A+    =
    //argv++;=0A+    }=0A+    return a;=0A =0A-/*=0A-    while(*argv){=0A- =
       printf("%s\n", *argv++);=0A-    } =0A-*/=0A-    return argv;=0A }=0A=
 =0A static void freeDuplicatedArgs(char **copy)=0A {=0A =0A+    //char *q =
=3D *copy;=0A+=0A+    while(*copy){=0A+=0A+        free(*copy++);=0A+    }=
=0A+    free(copy);=0A }=0A =0A /*=0A-- =0A2.17.1=0A=0A=0AFrom 0ebda9718247=
1a193a16a6f2545a0bff4cf262ac Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <y=
z4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 23:16:55 -0500=0ASubject: [PAT=
CH 6/7] Modifying README=0A=0A---=0A README.txt | 9 ++++++++-=0A 1 file cha=
nged, 8 insertions(+), 1 deletion(-)=0A=0Adiff --git a/README.txt b/README.=
txt=0Aindex 66dfd3e..41ba02f 100644=0A--- a/README.txt=0A+++ b/README.txt=
=0A@@ -8,4 +8,11 @@ This file should contain:=0A The description should ind=
icate whether your solution for the part is=0A working or not.  You may als=
o want to include anything else you would=0A like to communicate to the gra=
der such as extra functionalities you=0A-implemented or how you tried to fi=
x your non-working code.=0A+implemented or how you tried to fix your non-wo=
rking code. =0A+=0A+Yixuan Zou=0A+yz4004=0A+lab2=0A+=0A+part1 works=0A+part=
2 works=0A-- =0A2.17.1=0A=0A=0AFrom 1a61051652ab72d211a461d30e160d3cb39a45c=
1 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate:=
 Sat, 19 Feb 2022 23:24:39 -0500=0ASubject: [PATCH 7/7] remove *twecho=0A=
=0A---=0A part2/twecho | Bin 11392 -> 0 bytes=0A 1 file changed, 0 insertio=
ns(+), 0 deletions(-)=0A delete mode 100755 part2/twecho=0A=0Adiff --git a/=
part2/twecho b/part2/twecho=0Adeleted file mode 100755=0Aindex 18e341b1f659=
368d3eee676f9fff61ac9ff6b5ca..0000000000000000000000000000000000000000=0AGI=
T binary patch=0Aliteral 0=0AHcmV?d00001=0A=0Aliteral 11392=0AzcmeHNeQ;FQb-=
!;{AFCBwEeL@GuDvD@e?_~J5FkP^TA{^Hj`#>c2_)dhYWGRnvf9<`=0Az2bQQwaD`pAG7fYchon=
x&NoPECrk=3DXZ)L}fHM25taq|?Z)lQJ=3D$QBvH>Hfhv2c4=3D%-=0Azf9Jk?q_>ZyacBCcujc=
K!=3DXXBtxgYPnbMMoaB0XDNnkKlo#l3>K$#M(nV8KeR2+<+h=0AzMHPNmh}%U4;4)ktO6;Upm2=
0LRrRN4EyLOiaIO#1)k10n;RE4HAipdeL#WNKmAOW(Y=0AzSWnkT7BnC$Ob1mQ!-}#Uv1E5f*_}=
~#OlMSJOu2v5H@bEye@@y385O3aOJ&C!xj5CY=0AzC`V4(BejHJ%66ZI9mV-!i(e`3RPEhtTz0G=
YnX2xJP%_cCwk?#5HzgCP{7BPC``V_p=0AzZNY3h*ed%?{z><~ZN0K3nr|Ljig__E!braC+1FqB=
{9A<`Pi&mceCpTN?mp{k+(5Q`=0Azq57fAR%ixFXfFarm$Os@D20b^f+v6na5+mOfKq-&fCrq)3=
R_VE7Z}$V4dYrdoJpi|=0Az{UV#oB+Zl<iYAlkm@tgkNYv<0q@u~hArma=3D8`)emlQV{*iIljn=
r@M2r(Hd+Gt`SD}=0AzuB}Gg%$Ng-Y|hN=3D+PXQJPMN!+eMzz$7)qy<rD3U-RHPtX^3R$<YZf)=
k4$Tj*qx`Z&=0Az70JV@PkdkT{V=3DH(=3DX2`*Vf=3D)`J^p~SWSsenwH8il)E<{98_xFt$);_=
%{W&pX!z<Yd=0Az=3Dv5oeZIgIH;iSv!mhiu~;k16aOxke!eW;IJ@#y2_hrI!zKQfVX%}(lL-}j=
tjGcmj7=0AzZir@AeFDF=3Dw{@UK{2<BSoSH>hwSsu+`kRxIUq(EI^yY-*Tfz6AAOk8bzw9o&@_=
=3D6W=0Azg+6w9X2-6c<K=3DHbS3h2pm1N^T!qaU1zf}dqZ)$JrBFV-oIOx@nmusN<`m1{3ja(x=
_=0AzegQfZa?QTkss3Q?ZAYd5edj33c^>u`Nb&fZvmm|tUDsi+zjWQL7iRRArZ?%@%la$V=0Aza=
}99#uyVM79Nx^|k&UBJ6Zw!nw()aR>!o-W=3D;Iqd4{o{!U7ptQ^K$v8!D|%G5en>`=0Azb8w0N=
kovwi`=3DLQKjDB<B@Fl&FpB#@|8k^SiQ~FC&i0%CJx3AC6>V?S6`N(BCxToM`=0AzJaQQd#~1&=
AJnG|-NnM-N#|5d!p<akw8IN3n2Kbz1e)W80nv~yOQ`*))9+`%LHaXrq=0Azt;c?-kM~~HwI9|#=
FOIp!BGVeA8zNU8I_ET=3D(Y3Q^A9De<%TT+#A#$nqvAyUP;F$~O=0AzWakQpub$XvRmZLb3Wu+=
tpHpLpuV`PYJVSkYdj#!GQOJd#BILJK$d=3D>Cj6N2b^5AF2=0Az^L8tF)sOG+=3D!M=3DHecTU=
rN<XfH-8v-);APD7-@)Y>>g@EuH5rE#Ju;D3p`M?nVV4>g=0AzFfG=3D434bp9+3v!>gnPqSi>u=
a_%ca&t^fTeYweG@uJ$KP8dGwdAxu<{p0sKDl%Uq!4=0AzHMZ|5{I;j?URU8);n~HP^s#fAzW(+=
6TXYY7VPAM}cwhK|uyO9h{Ca!`x0dv$?lKK`=0Az@2YHIRTg=3DHw%olzNBkaKPoSwMKwkxY5%e=
-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
-AlhmYxK8d^{55#h+AVId=0AzepqPht@?g+n-<)XTS?)b?<mjw=3D+&P3DtVUH_b6+zG)%6&#PW=
?O(?}VK6@{0=3Dbe-(6=0AzqL8YtlO6R@q1CE(>;FJ#3oWf(4K=3DFSQ?Q~^Pp21Jy(QjD;Vz*d=
T_*?Y6GCgS@ZCVP=0Azh1x1#UA5b{+_z9$RO!bf-nB%yeV?q}P~BaJv0EvstM7#z)1;~%OhPSCj=
4~0@s{FVh=0Az;;GZzzUpeS)xcKO%sFa@wpX#`-F3uPb2FGiP3x{Bi<;ZvCj_Cd4yM14_h)UJ<p=
V~W=0Az8VT?#0PR}9!rRe}ML}&-qZRcXjoo$Bm5zodI~&PqUHM!Xt_CFa^A3ou2kWtVOYD*$=0A=
zx<Kq5jh2(IT27YE<2LuWcd9Xhi)i$JOXDkOzou#L`)cqjPk3ong!0)8o!x~7VzCeo=0Az?Toc;=
>I82fl@F~8B~r0uK5h!Br<fb{`VzTpkqS0Q51O&TbTEcSaby*boBhE-I<d)(=0Az4x3q2U4o9b5=
^1Xn4Ozvq%Z_FZGm}Z;h{}>-wp_dx-Ck|lb1?q}*NQsN;(W-}Ql~%a=0AzdD@-5-(CMgPs`EHHw=
F%RK6P}@o{+0`;dfu$<8q;|hLP^?H*z@A+HPdbXxtdiWrPtM=0Azq|>o14$VlE9ZY9(effSme++=
DHX|Y~vfu^BcK4oqkFjHnG5d#~|#0EE7XPbehfk0C~=0AzPTFDznuas!oEgidGfg<1OQ!~8TdhV=
5j?-}5mZ9Uc?FQT%ebKBbaOgG=3DkU#lUHZhPg=0Az;{ke6&BMguOb<6odOm716$hA%4rJ%Ymfc=
EOET1uA>12K=3DC5&`3PQA{WR<{xN0W(AM=0AzfIgGamhPU2F`Ue2MSsRLyYj=3DyL@b&!<KYb4=
lfr|UM9!2WMe~8~W5}{JKysu4MS+uk=0AzHhR#sdS~ER@_>r8RTx8QtR6I+&Re0VQAwl>5lat`+=
8UFcfGe_B(?wwlV>q3)uL}5-=0Az-N}l%C@`7m9nGN}N#kIS&NS^KpqfP#h6oL%a-n!4dmtOi=
=3DCHU^xom4|OK9{^TXS<;=0AzD3)E_vSwW<8SQHg4dWQKRm6FCtkFrCBj^e_U)yG1R&s9V#zOY=
S7>>qUpbLVbAhOyb=0AzZ5F|iY(ACGnvhy6MMN_L2j!UbVO`~itsw;%!-21wJ8NoWYjktnytr|{=
wc|c>7B_A_=0Az{{CQ>xp4wduV80!BXc=3Db5-%5LO5zoQ_W^caZc!;XKQ6{Sg7fNPyh?EXUW|J=
M=3DlR8W=0Azwc!0uF}^??DUk=3DeMU9v!iTmchcNP1oo!dVZ<9;!PSC6x}@!sd}HFlXBUk2KF1=
7Z`n=0AzMcv$f%m!mt77N~o731~z4i&INvhEg31n-;dLbt#xRGq6A;|;=3DJ66al_T^ldnx!s`?=
=0Az=3DUt=3D|=3DiQ?d|Gi>Bac;r8v3W7x99V__NjYIrp?$7PAO+wJr;-AZc!vY0H!|t-zFDb@=
=0Azb*O0Ajq*59dsHYx)=3DG^35ODIt`*6~wGKxzpF^{K!mx}+Jz{wB4;5ga(YlYvCwB5wd=0Az=
S>PJh)kD0|2G6BbyOUB_cf-2+IdDzfxUSw(`g~r%zOTv3jq98;YpujO{5bGMG;ZpC=0Az;m5~X-=
~o1Oqu-MFjq7$Na6i^F&lj6C179R=3DyifN?oVDiZ&`t1%Z-PG!oZ5BXN6!Ke=0Az%)6bdy$F1v=
YpLM<Gz%^e4p02tP{#)1B5)d?{c3znWk4I+Qr{CVLGH)8ZE)Pb&nQ3q=0Az-Tofs=3DL6uR?;JM=
|CW6{^Za->(Q~XZ-M&JSE(@s_cUttGS{TDKx63^#YCWn`Be?KzC=0Az`7e`3Zpetyw@D-;Mm%i{=
B-4G-q!CAkl{KRI5u^@7!$}hfOK{!V_3fpV=3D&NYLh-Na;=0AzQ3LPz%qVi5=3D#Xi|^Fu?(I}=
96VKr>gQI+wl{zx+#OOU9O+;jIxPvaQQNqF3w+DO=3DZ`=0AzZQ-rmn~Np#11%t=3Dn?^)e9`vr=
A!nm(zduO=3DE*uG`UXCk|dUExk7YEYD)bz|AQ>=3DY7&=0Az|K&rj8IR_o$S3GCaYu*!`>*u{x=
fr|Qi?LHo-mK5U2&4ELu@TRvjlpOtPT!9y38ehe=0AzpnS$2F^#SIT<!GTm(42IR(50HlQa(`b+=
P0J=3D;BY_#V$oKJ355q4>Xst=3DpfgSRhyY%=0Az5lkUh4~9Ftn{v?s#bK`#?8_(c-wTPj2og6=
K%?^rSd^81r7R9DPN)DQtY$Ba1VhqSK=0AzW->|!sy3X=3DiJ<Iy5Y^y78f=3Da-#~>|BD5d2z1=
<gUV5C`LM!klGltw_s)>u4c5l!zfF=0Azn&luyPy}%|3}J->GyC!b(2S-AaO)^Gk?K!#J=3D)io=
F%L3_f7LL#j!`Oc+y0*+$^dYy=0Az<DF&|&OeztGXc`Imydy=3DEi2n|p2{>}S4N$mn+&(0Vz=
=3Djfmg!1XRMctT1^hjn-E#Y!=0Az_cG=3D9Ic;>NecND<LxQ>Z&nQPsFRFGaEup@%J@)sqd=3D=
|gh1kc%X9?g``&n<1s2iJ){=0AzfQ!ziIeyN!nesb?<7Yjl2VhTU-OO`d&NKiy6=3D(bwD#RgFX=
iV9j^LM5bN|D=3Dl_W!7|=0Az?^Jr6=3DQGu9_DfKA+CL7A#+B1P-VZRvo4cqu=3Df41{-JbUiO=
goCK>0N3SrcZ#i+fS&D=0AzGUa&L4f9OD;jriTH&Yia4qM@N8Tt!U?CtaS9;VK1hqM2GsqA_FI6=
q-ZYujF&_J0E*=0Azwa@mv|6$r=3DH%8rQ|2>C2?~|C);jg{$xG{DC70Ug2m^feM|7UaRGtcxVu=
&uS(^S<jj=0Az^#P6bpdt(NOn(lP)*iRd`!oK3!5I}luTQq)d8B;;sjxlo<4#jhD7!5(_sjN7DN=
ncC=0Az&*iDA0d9vKupRR=3Ds1U~ObKd7yhE9Fe9X1#5qDENr9AZ`2{w@d3_Drus&UL%$dey$u=
=0AzuT!@MfD<D>31!dELH6y`ZM=3D#7xccCDzr(=3D6iaTy%|C4&FMe3iuIPF&}duKoYnI3j1=
=0Azuknp#v2%T8KSUiWQu8^rm7h=3DxF95U^7tbfZf9UzZbC2p=3D84g(0?GESME-NlXrIh{m=
=0ANR#+PMIt(1F_#c<#3$*|M=0A=0A-- =0A2.17.1=0A=0A
--FL5UXtIhxfXey3p5--

From do.not.reply@cloud.cs.columbia.edu Sat Feb 19 23:36:29 2022
Date: Sat, 19 Feb 2022 23:36:29 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab2.mbox
Message-ID: <20220220043629.GA2214@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="SLDf9lqlvOQaIe6s"
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 55797
Lines: 1165


--SLDf9lqlvOQaIe6s
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From d3c998e270303d85de5a202ae5a255d4ae38aefa Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 11:55:38 -0500
Subject: [PATCH 1/8] complete part1

---
 part1/Makefile |  77 +++++++++++++++++++++++++++
 part1/main.c   | 138 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 215 insertions(+)
 create mode 100644 part1/Makefile
 create mode 100644 part1/main.c

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..117cc26
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,77 @@
+# This Makefile should be used as a template for future Makefiles.
+# It's heavily commented, so hopefully you can understand what each
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+# Linking options:
+# -g for debugging info
+
+LDFLAGS = -g
+
+# List the libraries you need to link with in LDLIBS
+# For example, use "-lm" for the math library
+
+LDLIBS =
+
+# The 1st target gets built when you type "make".
+# It's usually your executable.  ("main" in this case.)
+#
+# Note that we did not specify the linking rule.
+# Instead, we rely on one of make's implicit rules:
+#
+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)
+#
+# Also note that make assumes that main depends on main.o,
+# so we can omit it if we want to.
+
+main: main.o 
+	gcc main.o -o isort
+# main.o depends not only on main.c, but also on myadd.h because
+# main.c includes myadd.h.  main.o will get recompiled if either
+# main.c or myadd.h get modified.
+#
+# make already knows main.o depends on main.c, so we can omit main.c
+# in the dependency list if we want to.
+#
+# make uses the following implicit rule to compile a .c file into a .o
+# file:
+#
+#     $(CC) -c $(CFLAGS) <the-.c-file>
+#
+
+main.o: main.c 
+
+# And myadd.o depends on myadd.c and myadd.h.
+
+# myadd.o: myadd.c myadd.h
+
+# Always provide the "clean" target that removes intermediate files.
+# What you remove depend on your choice of coding tools
+# (different editors generate different backup files for example).
+#
+# And the "clean" target is not a file name, so we tell make that
+# it's a "phony" target.
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
diff --git a/part1/main.c b/part1/main.c
new file mode 100644
index 0000000..27ddd60
--- /dev/null
+++ b/part1/main.c
@@ -0,0 +1,138 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+
+
+int *insertSort(int *a, int size);
+
+void sort_integer_array(int *begin, int *end, int ascending);
+
+int main(){
+
+    srandom(time(NULL));
+
+    // read array size from user
+    int size;
+    printf("Please input size here: ");
+    scanf("%d", &size);
+
+    // create array
+    // int a[size];
+    
+    int *a = (int *) malloc( sizeof(int) * size);
+    if (a == NULL) {
+         perror("malloc returned NULL");
+         exit(1);
+    }
+
+    int r;
+    for(int i=0; i<size; i++){
+
+        r = (int) (random()%100);
+        *(a+i) = r; 
+        printf("%d %d\n", r, *(a+i));
+    }
+
+
+    int *b =(int *)  malloc( sizeof(int) * size);
+    if (b == NULL) {
+         perror("malloc returned NULL");
+         exit(1);
+    }
+    for(int i=0; i<size; i++){
+
+        *(b+i) = *(a+i);
+    }
+
+    int *c = (int *) malloc( sizeof(int)* size);
+    if (c == NULL) {
+         perror("malloc returned NULL");
+         exit(1);
+    }
+    for(int i=0; i<=size; i++){
+        *(c+i) = *(a+i);
+    }
+
+    sort_integer_array(b, b+size, 1); // end b + size - 1
+
+    sort_integer_array(c, c+size, 0);
+
+
+    printf("original:");
+    for(int i=0; i<size; i++){
+        printf("%d  ", a[i]);
+    }
+    printf("\n");
+        
+    printf("ascending: ");
+    for(int i=0; i<size; i++){
+        printf("%d  ", b[i]);
+    }
+    printf("\n");
+
+    printf("descending: ");
+    for(int i=0; i<size; i++){
+        printf("%d  ", c[i]);
+    }
+    printf("\n");
+
+    free(a);
+    free(b);
+    free(c);
+
+    return 0;
+}
+
+
+
+ /* This function sorts an integer array.
+ 
+ begin points to the 1st element of the array.
+ end points to ONE PAST the last element of the array.
+ If ascending is 1, the array will be sorted in ascending order.
+ If ascending is 0, the array will be sorted in descending order.
+ */
+ void sort_integer_array(int *begin, int *end, int ascending) 
+ {
+ /* In here, you will call your real sorting function (your own
+ * or the qsort()). Basically, I want to make sure that you
+ * know how to translate the begin/end parameter to whatever
+ * is required for your sorting function.
+ */
+ 
+    
+    int index = 1;
+    int temp;
+    int current;
+    if( ascending){
+
+        while((begin+index) != end ){  // index < size
+
+            temp =*(begin+index);
+            // move current/curser to the place i, where a[i] < a[index] and a[i+1] > a[index]
+            current = index;
+            while((current >0) &  (*(begin + current-1) > temp)){
+                // not index - 1 in last row, but compare a[current-1] in condition, and use lazy &
+                *(begin + current) = *(begin + current-1); // put a[current-1] 1 digit back
+                current--;                 // current move forward
+            }
+        *(begin + current) = temp;
+        index++;
+        }
+    }else{
+        while((begin+index) != end){
+            temp = *(begin + index);
+            // move current/curser to the place i, where a[i] < a[index] and a[i+1] > a[index]
+            current = index;
+            while((current >0) &  (*(begin + current-1) < temp)){
+                // not index - 1 in last row, but compare a[current-1] in condition, and use lazy &
+                *(begin + current) = *(begin + current-1); // put a[current-1] 1 digit back
+                current--;                 // current move forward
+            }
+            *(begin + current) = temp;
+            index++;
+   
+        }
+    }
+
+}
-- 
2.17.1


From 14a807c2f789002ce63173f65b856eb88f519f76 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 21:04:01 -0500
Subject: [PATCH 2/8] part2 step1

---
 part2/Makefile | 77 ++++++++++++++++++++++++++++++++++++++++++++++++++
 part2/twecho.c |  6 ++++
 2 files changed, 83 insertions(+)
 create mode 100644 part2/Makefile

diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..4f96046
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,77 @@
+# This Makefile should be used as a template for future Makefiles.
+# It's heavily commented, so hopefully you can understand what each
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+# Linking options:
+# -g for debugging info
+
+LDFLAGS = -g
+
+# List the libraries you need to link with in LDLIBS
+# For example, use "-lm" for the math library
+
+LDLIBS =
+
+# The 1st target gets built when you type "make".
+# It's usually your executable.  ("main" in this case.)
+#
+# Note that we did not specify the linking rule.
+# Instead, we rely on one of make's implicit rules:
+#
+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)
+#
+# Also note that make assumes that main depends on main.o,
+# so we can omit it if we want to.
+
+main: twecho.o 
+	gcc twecho.o -o twecho
+# main.o depends not only on main.c, but also on myadd.h because
+# main.c includes myadd.h.  main.o will get recompiled if either
+# main.c or myadd.h get modified.
+#
+# make already knows main.o depends on main.c, so we can omit main.c
+# in the dependency list if we want to.
+#
+# make uses the following implicit rule to compile a .c file into a .o
+# file:
+#
+#     $(CC) -c $(CFLAGS) <the-.c-file>
+#
+
+twecho.o: twecho.c 
+
+# And myadd.o depends on myadd.c and myadd.h.
+
+# myadd.o: myadd.c myadd.h
+
+# Always provide the "clean" target that removes intermediate files.
+# What you remove depend on your choice of coding tools
+# (different editors generate different backup files for example).
+#
+# And the "clean" target is not a file name, so we tell make that
+# it's a "phony" target.
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
diff --git a/part2/twecho.c b/part2/twecho.c
index c70e975..741f7a5 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -10,6 +10,12 @@
 static char **duplicateArgs(int argc, char **argv)
 {
 
+/*
+    while(*argv){
+        printf("%s\n", *argv++);
+    } 
+*/
+    return argv;
 }
 
 static void freeDuplicatedArgs(char **copy)
-- 
2.17.1


From a399955d3253134fb2f380a0903180094256bece Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 21:42:55 -0500
Subject: [PATCH 3/8] Add reference for sort algorithm

---
 part1/main.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/part1/main.c b/part1/main.c
index 27ddd60..9a99813 100644
--- a/part1/main.c
+++ b/part1/main.c
@@ -2,9 +2,6 @@
 #include <stdlib.h>
 #include <time.h>
 
-
-int *insertSort(int *a, int size);
-
 void sort_integer_array(int *begin, int *end, int ascending);
 
 int main(){
@@ -24,16 +21,14 @@ int main(){
          perror("malloc returned NULL");
          exit(1);
     }
-
     int r;
     for(int i=0; i<size; i++){
 
         r = (int) (random()%100);
         *(a+i) = r; 
-        printf("%d %d\n", r, *(a+i));
+        //printf("%d %d\n", r, *(a+i));
     }
 
-
     int *b =(int *)  malloc( sizeof(int) * size);
     if (b == NULL) {
          perror("malloc returned NULL");
@@ -98,6 +93,11 @@ int main(){
  * or the qsort()). Basically, I want to make sure that you
  * know how to translate the begin/end parameter to whatever
  * is required for your sorting function.
+ *
+ *
+ * Insertion Sort. 
+ * From the lecture note of COMSW 3134
+ *
  */
  
     
-- 
2.17.1


From 35a35e52ad2bfe8de3a6637c8a9c9880ef8e4411 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 22:42:59 -0500
Subject: [PATCH 4/8] finishing part2 step2

---
 part2/twecho | Bin 0 -> 11392 bytes
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100755 part2/twecho

diff --git a/part2/twecho b/part2/twecho
new file mode 100755
index 0000000000000000000000000000000000000000..18e341b1f659368d3eee676f9fff61ac9ff6b5ca
GIT binary patch
literal 11392
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
NR#+PMIt(1F_#c<#3$*|M

literal 0
HcmV?d00001

-- 
2.17.1


From b127a0261a06feb9ce83dff6f2a7c2dc5491982e Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 23:14:24 -0500
Subject: [PATCH 5/8] finishing part2

---
 part2/twecho.c | 37 +++++++++++++++++++++++++++++++------
 1 file changed, 31 insertions(+), 6 deletions(-)

diff --git a/part2/twecho.c b/part2/twecho.c
index 741f7a5..7d835b1 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -9,18 +9,43 @@
 
 static char **duplicateArgs(int argc, char **argv)
 {
+       
+
+    // allocate & copy vertical array
+    char **a = malloc( sizeof(char *) * (argc -1)); 
+    //argv++;
+    int j = 1;
+    while( j<argc ){
+        //*a = *argv;
+
+        int len = strlen(argv[j]);
+        char *p = malloc( sizeof(char) * len);
+
+        int i = 0;
+        while(i < len){
+            *(p+i) = toupper( argv[j][i]); // p++
+            i++;
+        }
+        *(a+j)  = p; 
+
+        j++;
+        //a++;
+        //argv++;
+    }
+    return a;
 
-/*
-    while(*argv){
-        printf("%s\n", *argv++);
-    } 
-*/
-    return argv;
 }
 
 static void freeDuplicatedArgs(char **copy)
 {
 
+    //char *q = *copy;
+
+    while(*copy){
+
+        free(*copy++);
+    }
+    free(copy);
 }
 
 /*
-- 
2.17.1


From 0ebda97182471a193a16a6f2545a0bff4cf262ac Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 23:16:55 -0500
Subject: [PATCH 6/8] Modifying README

---
 README.txt | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/README.txt b/README.txt
index 66dfd3e..41ba02f 100644
--- a/README.txt
+++ b/README.txt
@@ -8,4 +8,11 @@ This file should contain:
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
-implemented or how you tried to fix your non-working code.
+implemented or how you tried to fix your non-working code. 
+
+Yixuan Zou
+yz4004
+lab2
+
+part1 works
+part2 works
-- 
2.17.1


From 1a61051652ab72d211a461d30e160d3cb39a45c1 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 23:24:39 -0500
Subject: [PATCH 7/8] remove *twecho

---
 part2/twecho | Bin 11392 -> 0 bytes
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100755 part2/twecho

diff --git a/part2/twecho b/part2/twecho
deleted file mode 100755
index 18e341b1f659368d3eee676f9fff61ac9ff6b5ca..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 11392
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
NR#+PMIt(1F_#c<#3$*|M

-- 
2.17.1


From 07690b0374a1202ad4a53aa711de5e35aa599679 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Sat, 19 Feb 2022 23:35:49 -0500
Subject: [PATCH 8/8] add malloc return checks in part2/twecho

---
 part2/twecho.c | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/part2/twecho.c b/part2/twecho.c
index 7d835b1..ad13829 100644
--- a/part2/twecho.c
+++ b/part2/twecho.c
@@ -12,7 +12,13 @@ static char **duplicateArgs(int argc, char **argv)
        
 
     // allocate & copy vertical array
-    char **a = malloc( sizeof(char *) * (argc -1)); 
+    char **a = malloc( sizeof(char *) * (argc -1));
+
+    if (a == NULL) {
+        perror("malloc returned NULL");
+        exit(1);
+        }
+
     //argv++;
     int j = 1;
     while( j<argc ){
@@ -20,6 +26,10 @@ static char **duplicateArgs(int argc, char **argv)
 
         int len = strlen(argv[j]);
         char *p = malloc( sizeof(char) * len);
+        if (p == NULL) {
+        perror("malloc returned NULL");
+        exit(1);
+        }
 
         int i = 0;
         while(i < len){
-- 
2.17.1


--SLDf9lqlvOQaIe6s
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab2.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom d3c998e270303d85de5a202ae5a255d4ae38aefa Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 11:55:38 =
-0500=0ASubject: [PATCH 1/8] complete part1=0A=0A---=0A part1/Makefile |  7=
7 +++++++++++++++++++++++++++=0A part1/main.c   | 138 +++++++++++++++++++++=
++++++++++++++++++++++++++++=0A 2 files changed, 215 insertions(+)=0A creat=
e mode 100644 part1/Makefile=0A create mode 100644 part1/main.c=0A=0Adiff -=
-git a/part1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 00000=
00..117cc26=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,77 @@=0A+# =
This Makefile should be used as a template for future Makefiles.=0A+# It's =
heavily commented, so hopefully you can understand what each=0A+# line does=
=2E=0A+=0A+# We'll use gcc for C compilation and g++ for C++ compilation=0A=
+=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+# Let's leave a place holder for add=
itional include directories=0A+=0A+INCLUDES =3D=0A+=0A+# Compilation option=
s:=0A+# -g for debugging info and -Wall enables all warnings=0A+=0A+CFLAGS =
  =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+# Li=
nking options:=0A+# -g for debugging info=0A+=0A+LDFLAGS =3D -g=0A+=0A+# Li=
st the libraries you need to link with in LDLIBS=0A+# For example, use "-lm=
" for the math library=0A+=0A+LDLIBS =3D=0A+=0A+# The 1st target gets built=
 when you type "make".=0A+# It's usually your executable.  ("main" in this =
case.)=0A+#=0A+# Note that we did not specify the linking rule.=0A+# Instea=
d, we rely on one of make's implicit rules:=0A+#=0A+#     $(CC) $(LDFLAGS) =
<all-dependent-.o-files> $(LDLIBS)=0A+#=0A+# Also note that make assumes th=
at main depends on main.o,=0A+# so we can omit it if we want to.=0A+=0A+mai=
n: main.o =0A+	gcc main.o -o isort=0A+# main.o depends not only on main.c, =
but also on myadd.h because=0A+# main.c includes myadd.h.  main.o will get =
recompiled if either=0A+# main.c or myadd.h get modified.=0A+#=0A+# make al=
ready knows main.o depends on main.c, so we can omit main.c=0A+# in the dep=
endency list if we want to.=0A+#=0A+# make uses the following implicit rule=
 to compile a .c file into a .o=0A+# file:=0A+#=0A+#     $(CC) -c $(CFLAGS)=
 <the-.c-file>=0A+#=0A+=0A+main.o: main.c =0A+=0A+# And myadd.o depends on =
myadd.c and myadd.h.=0A+=0A+# myadd.o: myadd.c myadd.h=0A+=0A+# Always prov=
ide the "clean" target that removes intermediate files.=0A+# What you remov=
e depend on your choice of coding tools=0A+# (different editors generate di=
fferent backup files for example).=0A+#=0A+# And the "clean" target is not =
a file name, so we tell make that=0A+# it's a "phony" target.=0A+=0A+.PHONY=
: clean=0A+clean:=0A+	rm -f *.o a.out core main=0A+=0A+# "all" target is us=
eful if your Makefile builds multiple programs.=0A+# Here we'll have it fir=
st do "clean", and rebuild the main target.=0A+=0A+.PHONY: all=0A+all: clea=
n main=0Adiff --git a/part1/main.c b/part1/main.c=0Anew file mode 100644=0A=
index 0000000..27ddd60=0A--- /dev/null=0A+++ b/part1/main.c=0A@@ -0,0 +1,13=
8 @@=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <time.h>=0A+=
=0A+=0A+int *insertSort(int *a, int size);=0A+=0A+void sort_integer_array(i=
nt *begin, int *end, int ascending);=0A+=0A+int main(){=0A+=0A+    srandom(=
time(NULL));=0A+=0A+    // read array size from user=0A+    int size;=0A+  =
  printf("Please input size here: ");=0A+    scanf("%d", &size);=0A+=0A+   =
 // create array=0A+    // int a[size];=0A+    =0A+    int *a =3D (int *) m=
alloc( sizeof(int) * size);=0A+    if (a =3D=3D NULL) {=0A+         perror(=
"malloc returned NULL");=0A+         exit(1);=0A+    }=0A+=0A+    int r;=0A=
+    for(int i=3D0; i<size; i++){=0A+=0A+        r =3D (int) (random()%100)=
;=0A+        *(a+i) =3D r; =0A+        printf("%d %d\n", r, *(a+i));=0A+   =
 }=0A+=0A+=0A+    int *b =3D(int *)  malloc( sizeof(int) * size);=0A+    if=
 (b =3D=3D NULL) {=0A+         perror("malloc returned NULL");=0A+         =
exit(1);=0A+    }=0A+    for(int i=3D0; i<size; i++){=0A+=0A+        *(b+i)=
 =3D *(a+i);=0A+    }=0A+=0A+    int *c =3D (int *) malloc( sizeof(int)* si=
ze);=0A+    if (c =3D=3D NULL) {=0A+         perror("malloc returned NULL")=
;=0A+         exit(1);=0A+    }=0A+    for(int i=3D0; i<=3Dsize; i++){=0A+ =
       *(c+i) =3D *(a+i);=0A+    }=0A+=0A+    sort_integer_array(b, b+size,=
 1); // end b + size - 1=0A+=0A+    sort_integer_array(c, c+size, 0);=0A+=
=0A+=0A+    printf("original:");=0A+    for(int i=3D0; i<size; i++){=0A+   =
     printf("%d  ", a[i]);=0A+    }=0A+    printf("\n");=0A+        =0A+   =
 printf("ascending: ");=0A+    for(int i=3D0; i<size; i++){=0A+        prin=
tf("%d  ", b[i]);=0A+    }=0A+    printf("\n");=0A+=0A+    printf("descendi=
ng: ");=0A+    for(int i=3D0; i<size; i++){=0A+        printf("%d  ", c[i])=
;=0A+    }=0A+    printf("\n");=0A+=0A+    free(a);=0A+    free(b);=0A+    =
free(c);=0A+=0A+    return 0;=0A+}=0A+=0A+=0A+=0A+ /* This function sorts a=
n integer array.=0A+ =0A+ begin points to the 1st element of the array.=0A+=
 end points to ONE PAST the last element of the array.=0A+ If ascending is =
1, the array will be sorted in ascending order.=0A+ If ascending is 0, the =
array will be sorted in descending order.=0A+ */=0A+ void sort_integer_arra=
y(int *begin, int *end, int ascending) =0A+ {=0A+ /* In here, you will call=
 your real sorting function (your own=0A+ * or the qsort()). Basically, I w=
ant to make sure that you=0A+ * know how to translate the begin/end paramet=
er to whatever=0A+ * is required for your sorting function.=0A+ */=0A+ =0A+=
    =0A+    int index =3D 1;=0A+    int temp;=0A+    int current;=0A+    if=
( ascending){=0A+=0A+        while((begin+index) !=3D end ){  // index < si=
ze=0A+=0A+            temp =3D*(begin+index);=0A+            // move curren=
t/curser to the place i, where a[i] < a[index] and a[i+1] > a[index]=0A+   =
         current =3D index;=0A+            while((current >0) &  (*(begin +=
 current-1) > temp)){=0A+                // not index - 1 in last row, but =
compare a[current-1] in condition, and use lazy &=0A+                *(begi=
n + current) =3D *(begin + current-1); // put a[current-1] 1 digit back=0A+=
                current--;                 // current move forward=0A+     =
       }=0A+        *(begin + current) =3D temp;=0A+        index++;=0A+   =
     }=0A+    }else{=0A+        while((begin+index) !=3D end){=0A+         =
   temp =3D *(begin + index);=0A+            // move current/curser to the =
place i, where a[i] < a[index] and a[i+1] > a[index]=0A+            current=
 =3D index;=0A+            while((current >0) &  (*(begin + current-1) < te=
mp)){=0A+                // not index - 1 in last row, but compare a[curren=
t-1] in condition, and use lazy &=0A+                *(begin + current) =3D=
 *(begin + current-1); // put a[current-1] 1 digit back=0A+                =
current--;                 // current move forward=0A+            }=0A+    =
        *(begin + current) =3D temp;=0A+            index++;=0A+   =0A+    =
    }=0A+    }=0A+=0A+}=0A-- =0A2.17.1=0A=0A=0AFrom 14a807c2f789002ce63173f=
65b856eb88f519f76 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@colum=
bia.edu>=0ADate: Sat, 19 Feb 2022 21:04:01 -0500=0ASubject: [PATCH 2/8] par=
t2 step1=0A=0A---=0A part2/Makefile | 77 ++++++++++++++++++++++++++++++++++=
++++++++++++++++=0A part2/twecho.c |  6 ++++=0A 2 files changed, 83 inserti=
ons(+)=0A create mode 100644 part2/Makefile=0A=0Adiff --git a/part2/Makefil=
e b/part2/Makefile=0Anew file mode 100644=0Aindex 0000000..4f96046=0A--- /d=
ev/null=0A+++ b/part2/Makefile=0A@@ -0,0 +1,77 @@=0A+# This Makefile should=
 be used as a template for future Makefiles.=0A+# It's heavily commented, s=
o hopefully you can understand what each=0A+# line does.=0A+=0A+# We'll use=
 gcc for C compilation and g++ for C++ compilation=0A+=0A+CC  =3D gcc=0A+CX=
X =3D g++=0A+=0A+# Let's leave a place holder for additional include direct=
ories=0A+=0A+INCLUDES =3D=0A+=0A+# Compilation options:=0A+# -g for debuggi=
ng info and -Wall enables all warnings=0A+=0A+CFLAGS   =3D -g -Wall $(INCLU=
DES)=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+# Linking options:=0A+# -g=
 for debugging info=0A+=0A+LDFLAGS =3D -g=0A+=0A+# List the libraries you n=
eed to link with in LDLIBS=0A+# For example, use "-lm" for the math library=
=0A+=0A+LDLIBS =3D=0A+=0A+# The 1st target gets built when you type "make".=
=0A+# It's usually your executable.  ("main" in this case.)=0A+#=0A+# Note =
that we did not specify the linking rule.=0A+# Instead, we rely on one of m=
ake's implicit rules:=0A+#=0A+#     $(CC) $(LDFLAGS) <all-dependent-.o-file=
s> $(LDLIBS)=0A+#=0A+# Also note that make assumes that main depends on mai=
n.o,=0A+# so we can omit it if we want to.=0A+=0A+main: twecho.o =0A+	gcc t=
wecho.o -o twecho=0A+# main.o depends not only on main.c, but also on myadd=
=2Eh because=0A+# main.c includes myadd.h.  main.o will get recompiled if e=
ither=0A+# main.c or myadd.h get modified.=0A+#=0A+# make already knows mai=
n.o depends on main.c, so we can omit main.c=0A+# in the dependency list if=
 we want to.=0A+#=0A+# make uses the following implicit rule to compile a .=
c file into a .o=0A+# file:=0A+#=0A+#     $(CC) -c $(CFLAGS) <the-.c-file>=
=0A+#=0A+=0A+twecho.o: twecho.c =0A+=0A+# And myadd.o depends on myadd.c an=
d myadd.h.=0A+=0A+# myadd.o: myadd.c myadd.h=0A+=0A+# Always provide the "c=
lean" target that removes intermediate files.=0A+# What you remove depend o=
n your choice of coding tools=0A+# (different editors generate different ba=
ckup files for example).=0A+#=0A+# And the "clean" target is not a file nam=
e, so we tell make that=0A+# it's a "phony" target.=0A+=0A+.PHONY: clean=0A=
+clean:=0A+	rm -f *.o a.out core main=0A+=0A+# "all" target is useful if yo=
ur Makefile builds multiple programs.=0A+# Here we'll have it first do "cle=
an", and rebuild the main target.=0A+=0A+.PHONY: all=0A+all: clean main=0Ad=
iff --git a/part2/twecho.c b/part2/twecho.c=0Aindex c70e975..741f7a5 100644=
=0A--- a/part2/twecho.c=0A+++ b/part2/twecho.c=0A@@ -10,6 +10,12 @@=0A stat=
ic char **duplicateArgs(int argc, char **argv)=0A {=0A =0A+/*=0A+    while(=
*argv){=0A+        printf("%s\n", *argv++);=0A+    } =0A+*/=0A+    return a=
rgv;=0A }=0A =0A static void freeDuplicatedArgs(char **copy)=0A-- =0A2.17.1=
=0A=0A=0AFrom a399955d3253134fb2f380a0903180094256bece Mon Sep 17 00:00:00 =
2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 21:4=
2:55 -0500=0ASubject: [PATCH 3/8] Add reference for sort algorithm=0A=0A---=
=0A part1/main.c | 12 ++++++------=0A 1 file changed, 6 insertions(+), 6 de=
letions(-)=0A=0Adiff --git a/part1/main.c b/part1/main.c=0Aindex 27ddd60..9=
a99813 100644=0A--- a/part1/main.c=0A+++ b/part1/main.c=0A@@ -2,9 +2,6 @@=
=0A #include <stdlib.h>=0A #include <time.h>=0A =0A-=0A-int *insertSort(int=
 *a, int size);=0A-=0A void sort_integer_array(int *begin, int *end, int as=
cending);=0A =0A int main(){=0A@@ -24,16 +21,14 @@ int main(){=0A          =
perror("malloc returned NULL");=0A          exit(1);=0A     }=0A-=0A     in=
t r;=0A     for(int i=3D0; i<size; i++){=0A =0A         r =3D (int) (random=
()%100);=0A         *(a+i) =3D r; =0A-        printf("%d %d\n", r, *(a+i));=
=0A+        //printf("%d %d\n", r, *(a+i));=0A     }=0A =0A-=0A     int *b =
=3D(int *)  malloc( sizeof(int) * size);=0A     if (b =3D=3D NULL) {=0A    =
      perror("malloc returned NULL");=0A@@ -98,6 +93,11 @@ int main(){=0A  =
* or the qsort()). Basically, I want to make sure that you=0A  * know how t=
o translate the begin/end parameter to whatever=0A  * is required for your =
sorting function.=0A+ *=0A+ *=0A+ * Insertion Sort. =0A+ * From the lecture=
 note of COMSW 3134=0A+ *=0A  */=0A  =0A     =0A-- =0A2.17.1=0A=0A=0AFrom 3=
5a35e52ad2bfe8de3a6637c8a9c9880ef8e4411 Mon Sep 17 00:00:00 2001=0AFrom: Yi=
xuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 22:42:59 -0500=0ASu=
bject: [PATCH 4/8] finishing part2 step2=0A=0A---=0A part2/twecho | Bin 0 -=
> 11392 bytes=0A 1 file changed, 0 insertions(+), 0 deletions(-)=0A create =
mode 100755 part2/twecho=0A=0Adiff --git a/part2/twecho b/part2/twecho=0Ane=
w file mode 100755=0Aindex 0000000000000000000000000000000000000000..18e341=
b1f659368d3eee676f9fff61ac9ff6b5ca=0AGIT binary patch=0Aliteral 11392=0Azcm=
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
-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 0=0AHcmV?d00001=0A=0A-- =0A2.=
17.1=0A=0A=0AFrom b127a0261a06feb9ce83dff6f2a7c2dc5491982e Mon Sep 17 00:00=
:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 =
23:14:24 -0500=0ASubject: [PATCH 5/8] finishing part2=0A=0A---=0A part2/twe=
cho.c | 37 +++++++++++++++++++++++++++++++------=0A 1 file changed, 31 inse=
rtions(+), 6 deletions(-)=0A=0Adiff --git a/part2/twecho.c b/part2/twecho.c=
=0Aindex 741f7a5..7d835b1 100644=0A--- a/part2/twecho.c=0A+++ b/part2/twech=
o.c=0A@@ -9,18 +9,43 @@=0A =0A static char **duplicateArgs(int argc, char *=
*argv)=0A {=0A+       =0A+=0A+    // allocate & copy vertical array=0A+    =
char **a =3D malloc( sizeof(char *) * (argc -1)); =0A+    //argv++;=0A+    =
int j =3D 1;=0A+    while( j<argc ){=0A+        //*a =3D *argv;=0A+=0A+    =
    int len =3D strlen(argv[j]);=0A+        char *p =3D malloc( sizeof(char=
) * len);=0A+=0A+        int i =3D 0;=0A+        while(i < len){=0A+       =
     *(p+i) =3D toupper( argv[j][i]); // p++=0A+            i++;=0A+       =
 }=0A+        *(a+j)  =3D p; =0A+=0A+        j++;=0A+        //a++;=0A+    =
    //argv++;=0A+    }=0A+    return a;=0A =0A-/*=0A-    while(*argv){=0A- =
       printf("%s\n", *argv++);=0A-    } =0A-*/=0A-    return argv;=0A }=0A=
 =0A static void freeDuplicatedArgs(char **copy)=0A {=0A =0A+    //char *q =
=3D *copy;=0A+=0A+    while(*copy){=0A+=0A+        free(*copy++);=0A+    }=
=0A+    free(copy);=0A }=0A =0A /*=0A-- =0A2.17.1=0A=0A=0AFrom 0ebda9718247=
1a193a16a6f2545a0bff4cf262ac Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <y=
z4004@columbia.edu>=0ADate: Sat, 19 Feb 2022 23:16:55 -0500=0ASubject: [PAT=
CH 6/8] Modifying README=0A=0A---=0A README.txt | 9 ++++++++-=0A 1 file cha=
nged, 8 insertions(+), 1 deletion(-)=0A=0Adiff --git a/README.txt b/README.=
txt=0Aindex 66dfd3e..41ba02f 100644=0A--- a/README.txt=0A+++ b/README.txt=
=0A@@ -8,4 +8,11 @@ This file should contain:=0A The description should ind=
icate whether your solution for the part is=0A working or not.  You may als=
o want to include anything else you would=0A like to communicate to the gra=
der such as extra functionalities you=0A-implemented or how you tried to fi=
x your non-working code.=0A+implemented or how you tried to fix your non-wo=
rking code. =0A+=0A+Yixuan Zou=0A+yz4004=0A+lab2=0A+=0A+part1 works=0A+part=
2 works=0A-- =0A2.17.1=0A=0A=0AFrom 1a61051652ab72d211a461d30e160d3cb39a45c=
1 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate:=
 Sat, 19 Feb 2022 23:24:39 -0500=0ASubject: [PATCH 7/8] remove *twecho=0A=
=0A---=0A part2/twecho | Bin 11392 -> 0 bytes=0A 1 file changed, 0 insertio=
ns(+), 0 deletions(-)=0A delete mode 100755 part2/twecho=0A=0Adiff --git a/=
part2/twecho b/part2/twecho=0Adeleted file mode 100755=0Aindex 18e341b1f659=
368d3eee676f9fff61ac9ff6b5ca..0000000000000000000000000000000000000000=0AGI=
T binary patch=0Aliteral 0=0AHcmV?d00001=0A=0Aliteral 11392=0AzcmeHNeQ;FQb-=
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
-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
-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
=0ANR#+PMIt(1F_#c<#3$*|M=0A=0A-- =0A2.17.1=0A=0A=0AFrom 07690b0374a1202ad4a=
53aa711de5e35aa599679 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@c=
olumbia.edu>=0ADate: Sat, 19 Feb 2022 23:35:49 -0500=0ASubject: [PATCH 8/8]=
 add malloc return checks in part2/twecho=0A=0A---=0A part2/twecho.c | 12 +=
++++++++++-=0A 1 file changed, 11 insertions(+), 1 deletion(-)=0A=0Adiff --=
git a/part2/twecho.c b/part2/twecho.c=0Aindex 7d835b1..ad13829 100644=0A---=
 a/part2/twecho.c=0A+++ b/part2/twecho.c=0A@@ -12,7 +12,13 @@ static char *=
*duplicateArgs(int argc, char **argv)=0A        =0A =0A     // allocate & c=
opy vertical array=0A-    char **a =3D malloc( sizeof(char *) * (argc -1));=
 =0A+    char **a =3D malloc( sizeof(char *) * (argc -1));=0A+=0A+    if (a=
 =3D=3D NULL) {=0A+        perror("malloc returned NULL");=0A+        exit(=
1);=0A+        }=0A+=0A     //argv++;=0A     int j =3D 1;=0A     while( j<a=
rgc ){=0A@@ -20,6 +26,10 @@ static char **duplicateArgs(int argc, char **ar=
gv)=0A =0A         int len =3D strlen(argv[j]);=0A         char *p =3D mall=
oc( sizeof(char) * len);=0A+        if (p =3D=3D NULL) {=0A+        perror(=
"malloc returned NULL");=0A+        exit(1);=0A+        }=0A =0A         in=
t i =3D 0;=0A         while(i < len){=0A-- =0A2.17.1=0A=0A
--SLDf9lqlvOQaIe6s--

From do.not.reply@cloud.cs.columbia.edu Tue Mar  8 17:33:35 2022
Date: Tue, 8 Mar 2022 17:33:35 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab3.mbox
Message-ID: <20220308223335.GA10184@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="XsQoSWH+UP9D9v3l"
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 29646
Lines: 730


--XsQoSWH+UP9D9v3l
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: 8bit

From 35143dc731c7ecc21e5d5c814d90f3134d810810 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 8 Mar 2022 13:04:25 -0500
Subject: [PATCH 1/4] finish part1 a

---
 part1/Makefile |  80 +++++++++++++++++++++++++++++++
 part1/mylist.c | 124 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 204 insertions(+)
 create mode 100644 part1/Makefile
 create mode 100644 part1/mylist.c

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..8d1df78
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,80 @@
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+# Linking options:
+# -g for debugging info
+
+LDFLAGS = -g
+
+# List the libraries you need to link with in LDLIBS
+# For example, use "-lm" for the math library
+
+LDLIBS =
+
+# The 1st target gets built when you type "make".
+# It's usually your executable.  ("main" in this case.)
+#
+# Note that we did not specify the linking rule.
+# Instead, we rely on one of make's implicit rules:
+#
+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)
+#
+# Also note that make assumes that main depends on main.o,
+# so we can omit it if we want to.
+
+main: mylist.o mylist-test.o
+	gcc mylist.o mylist-test.o -o main 
+# main.o depends not only on main.c, but also on myadd.h because
+# main.c includes myadd.h.  main.o will get recompiled if either
+# main.c or myadd.h get modified.
+#
+# make already knows main.o depends on main.c, so we can omit main.c
+# in the dependency list if we want to.
+#
+# make uses the following implicit rule to compile a .c file into a .o
+# file:
+#
+#     $(CC) -c $(CFLAGS) <the-.c-file>
+#
+
+mylist-test.o: mylist-test.c mylist.h 
+	gcc -c mylist-test.c -o  mylist-test.o
+
+mylist.o: mylist.c mylist.h
+	gcc -c mylist.c -o mylist.o
+
+# And myadd.o depends on myadd.c and myadd.h.
+
+# myadd.o: myadd.c myadd.h
+
+# Always provide the "clean" target that removes intermediate files.
+# What you remove depend on your choice of coding tools
+# (different editors generate different backup files for example).
+#
+# And the "clean" target is not a file name, so we tell make that
+# it's a "phony" target.
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
+
diff --git a/part1/mylist.c b/part1/mylist.c
new file mode 100644
index 0000000..2f644a3
--- /dev/null
+++ b/part1/mylist.c
@@ -0,0 +1,124 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "mylist.h"
+
+struct Node *addFront(struct List *list, void *data) {
+
+    struct Node *node = malloc(sizeof(data) + sizeof(list) );
+    if (!node) {
+        return NULL;
+    }
+
+    node->data = data;
+    node->next = list->head;
+    list->head = node;
+    return node;
+}
+
+void traverseList(struct List *list, void (*f)(void*)) {
+    
+    struct Node* head1 = list->head;
+
+    while (head1 != NULL) {
+        f(head1->data); // (*f)(head1->data)
+        head1 = head1->next;
+    }
+}
+
+void flipSignDouble(void* data) {
+
+    //double* data1 = data;
+
+    //double temp = (*data1) * (-1);
+    //// double temp = double(*data) * (-1); wrong ! data double  dereference 
+    //*data1 = temp;
+
+    double* data1 = data;
+    *data1 = (*data1) * (-1); 
+}
+
+int compareDouble(const void* data1, const void* data2) {
+
+    double d1 = *(double*)data1;
+    double d2 = *(double*)data2;
+
+    if (d1 == d2) {
+        return 0;
+    }
+    else {
+        return 1;
+    }
+}
+
+struct Node* findNode(struct List* list, const void* dataSought, int (*compar)(const void*, const void*)) {
+
+    struct Node* head1 = list->head;
+    while (head1 != NULL) {
+        if (!compar(head1->data, dataSought)) {
+            return head1;
+        }
+
+        head1 = head1->next;
+    }
+    return NULL;
+
+}
+
+void* popFront(struct List* list) {
+
+    struct Node* temp = list->head;
+    if (temp == NULL) {
+        return NULL;
+    }
+    void* data = list->head->data;
+    list->head = temp->next; //list->head = temp->next;
+
+    free(temp);
+    return data;
+}
+
+void removeAllNodes(struct List* list) {
+
+    while (popFront(list) != NULL) {
+
+    }
+}
+
+
+struct Node* addAfter(struct List* list, struct Node* prevNode, void* data) {
+
+    struct Node* node = malloc(sizeof(data) + sizeof(list));
+    if (!node) {
+        return NULL;
+    }
+
+    node->data = data;
+
+    if (prevNode != NULL) { // !prevNode fails
+        node->next = NULL;
+        prevNode->next = node;
+    }
+    else {
+        node->next = list->head;
+        list->head = node;
+    }
+    return node;
+
+
+}
+
+void reverseList(struct List* list) {
+
+    struct Node* prv = NULL;
+    struct Node* cur = list->head;
+    struct Node* nxt;
+
+    while (cur) {
+        nxt = cur->next;
+        cur->next = prv;
+        prv = cur;
+        cur = nxt;
+    }
+    list->head = prv;
+
+}
-- 
2.17.1


From f122cb4c2ff5969198e9e55348dfe25387beb76f Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 8 Mar 2022 13:09:38 -0500
Subject: [PATCH 2/4] modifiy README.txt for part1 a)

---
 README.txt | 54 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/README.txt b/README.txt
index 66dfd3e..d9c90cb 100644
--- a/README.txt
+++ b/README.txt
@@ -9,3 +9,57 @@ The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+
+Yixuan Zou
+yz4004
+lab3
+
+----------------------------part1 (a)--------------------------
+
+yz4004@clac ~/cs3157/lab3/part1 $ valgrind --leak-check=yes ./main
+==22154== Memcheck, a memory error detector
+==22154== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==22154== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
+==22154== Command: ./main
+==22154==
+testing addFront(): 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0
+testing flipSignDouble(): -9.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0
+testing flipSignDouble() again: 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0
+testing findNode(): OK
+popped 9.0, the rest is: [ 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 8.0, the rest is: [ 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 7.0, the rest is: [ 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 6.0, the rest is: [ 5.0 4.0 3.0 2.0 1.0 ]
+popped 5.0, the rest is: [ 4.0 3.0 2.0 1.0 ]
+popped 4.0, the rest is: [ 3.0 2.0 1.0 ]
+popped 3.0, the rest is: [ 2.0 1.0 ]
+popped 2.0, the rest is: [ 1.0 ]
+popped 1.0, the rest is: [ ]
+testing addAfter(): 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0
+popped 1.0, and reversed the rest: [ 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 ]
+popped 9.0, and reversed the rest: [ 2.0 3.0 4.0 5.0 6.0 7.0 8.0 ]
+popped 2.0, and reversed the rest: [ 8.0 7.0 6.0 5.0 4.0 3.0 ]
+popped 8.0, and reversed the rest: [ 3.0 4.0 5.0 6.0 7.0 ]
+popped 3.0, and reversed the rest: [ 7.0 6.0 5.0 4.0 ]
+popped 7.0, and reversed the rest: [ 4.0 5.0 6.0 ]
+popped 4.0, and reversed the rest: [ 6.0 5.0 ]
+popped 6.0, and reversed the rest: [ 5.0 ]
+popped 5.0, and reversed the rest: [ ]
+==22154==
+==22154== HEAP SUMMARY:
+==22154==     in use at exit: 0 bytes in 0 blocks
+==22154==   total heap usage: 19 allocs, 19 frees, 1,312 bytes allocated
+==22154==
+==22154== All heap blocks were freed -- no leaks are possible
+==22154==
+==22154== For counts of detected and suppressed errors, rerun with: -v
+==22154== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+
+
+
+
+----------------------------part1 (b)--------------------------
+
+
+----------------------------part (a)--------------------------
+----------------------------part (a)--------------------------
-- 
2.17.1


From 1f5be0e91d10fd0c542d491646c090e354f14fa0 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 8 Mar 2022 13:48:38 -0500
Subject: [PATCH 3/4] finish part1 b

---
 README.txt     | 59 ++++++++++++++++++++++++++++++++++++++++++++++++--
 part1/Makefile |  7 ++++--
 2 files changed, 62 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index d9c90cb..fd196b6 100644
--- a/README.txt
+++ b/README.txt
@@ -60,6 +60,61 @@ popped 5.0, and reversed the rest: [ ]
 
 ----------------------------part1 (b)--------------------------
 
+yz4004@clac ~/cs3157/lab3/part1 $ make clean
+rm -f *.o a.out core main
+yz4004@clac ~/cs3157/lab3/part1 $ clear
+yz4004@clac ~/cs3157/lab3/part1 $ make
+gcc -c mylist.c -o mylist.o
+ar rcs libmylist.a mylist.o
+gcc -c mylist-test.c -o  mylist-test.o
+gcc  mylist-test.o -o main -L. -lmylist
+yz4004@clac ~/cs3157/lab3/part1 $ valgrind --leak-check=yes ./main
+==24171== Memcheck, a memory error detector
+==24171== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==24171== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
+==24171== Command: ./main
+==24171==
+testing addFront(): 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0
+testing flipSignDouble(): -9.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0
+testing flipSignDouble() again: 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0
+testing findNode(): OK
+popped 9.0, the rest is: [ 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 8.0, the rest is: [ 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 7.0, the rest is: [ 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 6.0, the rest is: [ 5.0 4.0 3.0 2.0 1.0 ]
+popped 5.0, the rest is: [ 4.0 3.0 2.0 1.0 ]
+popped 4.0, the rest is: [ 3.0 2.0 1.0 ]
+popped 3.0, the rest is: [ 2.0 1.0 ]
+popped 2.0, the rest is: [ 1.0 ]
+popped 1.0, the rest is: [ ]
+testing addAfter(): 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0
+popped 1.0, and reversed the rest: [ 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 ]
+popped 9.0, and reversed the rest: [ 2.0 3.0 4.0 5.0 6.0 7.0 8.0 ]
+popped 2.0, and reversed the rest: [ 8.0 7.0 6.0 5.0 4.0 3.0 ]
+popped 8.0, and reversed the rest: [ 3.0 4.0 5.0 6.0 7.0 ]
+popped 3.0, and reversed the rest: [ 7.0 6.0 5.0 4.0 ]
+popped 7.0, and reversed the rest: [ 4.0 5.0 6.0 ]
+popped 4.0, and reversed the rest: [ 6.0 5.0 ]
+popped 6.0, and reversed the rest: [ 5.0 ]
+popped 5.0, and reversed the rest: [ ]
+==24171==
+==24171== HEAP SUMMARY:
+==24171==     in use at exit: 0 bytes in 0 blocks
+==24171==   total heap usage: 19 allocs, 19 frees, 1,312 bytes allocated
+==24171==
+==24171== All heap blocks were freed -- no leaks are possible
+==24171==
+==24171== For counts of detected and suppressed errors, rerun with: -v
+==24171== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+
+----------------------------part2 --------------------------  
+
+
+
+
+
+
+
+
+
 
-----------------------------part (a)--------------------------
-----------------------------part (a)--------------------------
diff --git a/part1/Makefile b/part1/Makefile
index 8d1df78..6f93eff 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -36,8 +36,8 @@ LDLIBS =
 # Also note that make assumes that main depends on main.o,
 # so we can omit it if we want to.
 
-main: mylist.o mylist-test.o
-	gcc mylist.o mylist-test.o -o main 
+main: libmylist.a  mylist-test.o
+	gcc  mylist-test.o -o main -L. -lmylist 
 # main.o depends not only on main.c, but also on myadd.h because
 # main.c includes myadd.h.  main.o will get recompiled if either
 # main.c or myadd.h get modified.
@@ -57,6 +57,9 @@ mylist-test.o: mylist-test.c mylist.h
 mylist.o: mylist.c mylist.h
 	gcc -c mylist.c -o mylist.o
 
+libmylist.a: mylist.o
+	ar rcs libmylist.a mylist.o
+
 # And myadd.o depends on myadd.c and myadd.h.
 
 # myadd.o: myadd.c myadd.h
-- 
2.17.1


From adf064a9ad450cf7fa2d0892191742fc6b58dfe1 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 8 Mar 2022 17:31:24 -0500
Subject: [PATCH 4/4] part2

---
 part2/Makefile  | 30 ++++++++++++++++++++++++++++++
 part2/revecho.c | 42 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 72 insertions(+)
 create mode 100644 part2/Makefile
 create mode 100644 part2/revecho.c

diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..dde3b17
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,30 @@
+CC  = gcc
+CXX = g++
+
+INCLUDES =
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+LDFLAGS = -g
+
+LDLIBS =
+
+main:  revecho.o
+	gcc  revecho.o -o main  -lmylist -L../part1 
+
+revecho.o:  revecho.c  
+	gcc -c  revecho.c -o  revecho.o -I../part1 
+
+# libmylist.a: mylist.o
+# 	ar rcs libmylist.a mylist.o
+
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+.PHONY: all
+all: clean main
+
+
diff --git a/part2/revecho.c b/part2/revecho.c
new file mode 100644
index 0000000..34eb22a
--- /dev/null
+++ b/part2/revecho.c
@@ -0,0 +1,42 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "mylist.h"
+
+int main(int argc, char **argv) {
+
+
+    if (argc <= 1)
+        return 1;
+
+    argv++;
+
+    // initialize list
+    struct List list;
+    initList(&list);
+
+
+    printf("%s \n","here");
+
+    while (*argv) 
+    {
+        // printf("%s \n", *argv);
+        addFront(&list, *argv++);
+
+    }
+
+    reverseList(&list);
+  
+
+    char *p;
+
+    struct Node* cur = list.head;
+    while (cur) {
+
+        p =  cur->data;
+
+        printf("%s", p);
+        cur = cur->data;
+
+    }
+    return 0;
+}
-- 
2.17.1


--XsQoSWH+UP9D9v3l
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab3.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 35143dc731c7ecc21e5d5c814d90f3134d810810 Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Tue, 8 Mar 2022 13:04:25 -=
0500=0ASubject: [PATCH 1/4] finish part1 a=0A=0A---=0A part1/Makefile |  80=
 +++++++++++++++++++++++++++++++=0A part1/mylist.c | 124 ++++++++++++++++++=
+++++++++++++++++++++++++++++++=0A 2 files changed, 204 insertions(+)=0A cr=
eate mode 100644 part1/Makefile=0A create mode 100644 part1/mylist.c=0A=0Ad=
iff --git a/part1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex =
0000000..8d1df78=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,80 @@=
=0A+# line does.=0A+=0A+# We'll use gcc for C compilation and g++ for C++ c=
ompilation=0A+=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+# Let's leave a place h=
older for additional include directories=0A+=0A+INCLUDES =3D=0A+=0A+# Compi=
lation options:=0A+# -g for debugging info and -Wall enables all warnings=
=0A+=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g -Wall $(INCLUD=
ES)=0A+=0A+# Linking options:=0A+# -g for debugging info=0A+=0A+LDFLAGS =3D=
 -g=0A+=0A+# List the libraries you need to link with in LDLIBS=0A+# For ex=
ample, use "-lm" for the math library=0A+=0A+LDLIBS =3D=0A+=0A+# The 1st ta=
rget gets built when you type "make".=0A+# It's usually your executable.  (=
"main" in this case.)=0A+#=0A+# Note that we did not specify the linking ru=
le.=0A+# Instead, we rely on one of make's implicit rules:=0A+#=0A+#     $(=
CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)=0A+#=0A+# Also note that =
make assumes that main depends on main.o,=0A+# so we can omit it if we want=
 to.=0A+=0A+main: mylist.o mylist-test.o=0A+	gcc mylist.o mylist-test.o -o =
main =0A+# main.o depends not only on main.c, but also on myadd.h because=
=0A+# main.c includes myadd.h.  main.o will get recompiled if either=0A+# m=
ain.c or myadd.h get modified.=0A+#=0A+# make already knows main.o depends =
on main.c, so we can omit main.c=0A+# in the dependency list if we want to.=
=0A+#=0A+# make uses the following implicit rule to compile a .c file into =
a .o=0A+# file:=0A+#=0A+#     $(CC) -c $(CFLAGS) <the-.c-file>=0A+#=0A+=0A+=
mylist-test.o: mylist-test.c mylist.h =0A+	gcc -c mylist-test.c -o  mylist-=
test.o=0A+=0A+mylist.o: mylist.c mylist.h=0A+	gcc -c mylist.c -o mylist.o=
=0A+=0A+# And myadd.o depends on myadd.c and myadd.h.=0A+=0A+# myadd.o: mya=
dd.c myadd.h=0A+=0A+# Always provide the "clean" target that removes interm=
ediate files.=0A+# What you remove depend on your choice of coding tools=0A=
+# (different editors generate different backup files for example).=0A+#=0A=
+# And the "clean" target is not a file name, so we tell make that=0A+# it'=
s a "phony" target.=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.o a.out core=
 main=0A+=0A+# "all" target is useful if your Makefile builds multiple prog=
rams.=0A+# Here we'll have it first do "clean", and rebuild the main target=
=2E=0A+=0A+.PHONY: all=0A+all: clean main=0A+=0Adiff --git a/part1/mylist.c=
 b/part1/mylist.c=0Anew file mode 100644=0Aindex 0000000..2f644a3=0A--- /de=
v/null=0A+++ b/part1/mylist.c=0A@@ -0,0 +1,124 @@=0A+#include <stdio.h>=0A+=
#include <stdlib.h>=0A+#include "mylist.h"=0A+=0A+struct Node *addFront(str=
uct List *list, void *data) {=0A+=0A+    struct Node *node =3D malloc(sizeo=
f(data) + sizeof(list) );=0A+    if (!node) {=0A+        return NULL;=0A+  =
  }=0A+=0A+    node->data =3D data;=0A+    node->next =3D list->head;=0A+  =
  list->head =3D node;=0A+    return node;=0A+}=0A+=0A+void traverseList(st=
ruct List *list, void (*f)(void*)) {=0A+    =0A+    struct Node* head1 =3D =
list->head;=0A+=0A+    while (head1 !=3D NULL) {=0A+        f(head1->data);=
 // (*f)(head1->data)=0A+        head1 =3D head1->next;=0A+    }=0A+}=0A+=
=0A+void flipSignDouble(void* data) {=0A+=0A+    //double* data1 =3D data;=
=0A+=0A+    //double temp =3D (*data1) * (-1);=0A+    //// double temp =3D =
=EF=BC=88double=EF=BC=89(*data) * (-1); wrong ! data =E8=A6=81=E5=85=88=E8=
=BD=AC=E6=8D=A2=E6=88=90double=E6=8C=87=E9=92=88 =E8=80=8C=E4=B8=8D=E6=98=
=AF dereference =E5=90=8E=E5=86=8D=E8=BD=AC=0A+    //*data1 =3D temp;=0A+=
=0A+    double* data1 =3D data;=0A+    *data1 =3D (*data1) * (-1); =0A+}=0A=
+=0A+int compareDouble(const void* data1, const void* data2) {=0A+=0A+    d=
ouble d1 =3D *(double*)data1;=0A+    double d2 =3D *(double*)data2;=0A+=0A+=
    if (d1 =3D=3D d2) {=0A+        return 0;=0A+    }=0A+    else {=0A+    =
    return 1;=0A+    }=0A+}=0A+=0A+struct Node* findNode(struct List* list,=
 const void* dataSought, int (*compar)(const void*, const void*)) {=0A+=0A+=
    struct Node* head1 =3D list->head;=0A+    while (head1 !=3D NULL) {=0A+=
        if (!compar(head1->data, dataSought)) {=0A+            return head1=
;=0A+        }=0A+=0A+        head1 =3D head1->next;=0A+    }=0A+    return=
 NULL;=0A+=0A+}=0A+=0A+void* popFront(struct List* list) {=0A+=0A+    struc=
t Node* temp =3D list->head;=0A+    if (temp =3D=3D NULL) {=0A+        retu=
rn NULL;=0A+    }=0A+    void* data =3D list->head->data;=0A+    list->head=
 =3D temp->next; //list->head =3D temp->next;=0A+=0A+    free(temp);=0A+   =
 return data;=0A+}=0A+=0A+void removeAllNodes(struct List* list) {=0A+=0A+ =
   while (popFront(list) !=3D NULL) {=0A+=0A+    }=0A+}=0A+=0A+=0A+struct N=
ode* addAfter(struct List* list, struct Node* prevNode, void* data) {=0A+=
=0A+    struct Node* node =3D malloc(sizeof(data) + sizeof(list));=0A+    i=
f (!node) {=0A+        return NULL;=0A+    }=0A+=0A+    node->data =3D data=
;=0A+=0A+    if (prevNode !=3D NULL) { // !prevNode fails=0A+        node->=
next =3D NULL;=0A+        prevNode->next =3D node;=0A+    }=0A+    else {=
=0A+        node->next =3D list->head;=0A+        list->head =3D node;=0A+ =
   }=0A+    return node;=0A+=0A+=0A+}=0A+=0A+void reverseList(struct List* =
list) {=0A+=0A+    struct Node* prv =3D NULL;=0A+    struct Node* cur =3D l=
ist->head;=0A+    struct Node* nxt;=0A+=0A+    while (cur) {=0A+        nxt=
 =3D cur->next;=0A+        cur->next =3D prv;=0A+        prv =3D cur;=0A+  =
      cur =3D nxt;=0A+    }=0A+    list->head =3D prv;=0A+=0A+}=0A-- =0A2.1=
7.1=0A=0A=0AFrom f122cb4c2ff5969198e9e55348dfe25387beb76f Mon Sep 17 00:00:=
00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Tue, 8 Mar 2022 13=
:09:38 -0500=0ASubject: [PATCH 2/4] modifiy README.txt for part1 a)=0A=0A--=
-=0A README.txt | 54 ++++++++++++++++++++++++++++++++++++++++++++++++++++++=
=0A 1 file changed, 54 insertions(+)=0A=0Adiff --git a/README.txt b/README.=
txt=0Aindex 66dfd3e..d9c90cb 100644=0A--- a/README.txt=0A+++ b/README.txt=
=0A@@ -9,3 +9,57 @@ The description should indicate whether your solution f=
or the part is=0A working or not.  You may also want to include anything el=
se you would=0A like to communicate to the grader such as extra functionali=
ties you=0A implemented or how you tried to fix your non-working code.=0A+=
=0A+Yixuan Zou=0A+yz4004=0A+lab3=0A+=0A+----------------------------part1 (=
a)--------------------------=0A+=0A+yz4004@clac ~/cs3157/lab3/part1 $ valgr=
ind --leak-check=3Dyes ./main=0A+=3D=3D22154=3D=3D Memcheck, a memory error=
 detector=0A+=3D=3D22154=3D=3D Copyright (C) 2002-2017, and GNU GPL'd, by J=
ulian Seward et al.=0A+=3D=3D22154=3D=3D Using Valgrind-3.13.0 and LibVEX; =
rerun with -h for copyright info=0A+=3D=3D22154=3D=3D Command: ./main=0A+=
=3D=3D22154=3D=3D=0A+testing addFront(): 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.=
0=0A+testing flipSignDouble(): -9.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0=
=0A+testing flipSignDouble() again: 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0=0A+=
testing findNode(): OK=0A+popped 9.0, the rest is: [ 8.0 7.0 6.0 5.0 4.0 3.=
0 2.0 1.0 ]=0A+popped 8.0, the rest is: [ 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]=0A+=
popped 7.0, the rest is: [ 6.0 5.0 4.0 3.0 2.0 1.0 ]=0A+popped 6.0, the res=
t is: [ 5.0 4.0 3.0 2.0 1.0 ]=0A+popped 5.0, the rest is: [ 4.0 3.0 2.0 1.0=
 ]=0A+popped 4.0, the rest is: [ 3.0 2.0 1.0 ]=0A+popped 3.0, the rest is: =
[ 2.0 1.0 ]=0A+popped 2.0, the rest is: [ 1.0 ]=0A+popped 1.0, the rest is:=
 [ ]=0A+testing addAfter(): 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0=0A+popped 1=
=2E0, and reversed the rest: [ 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 ]=0A+popped =
9.0, and reversed the rest: [ 2.0 3.0 4.0 5.0 6.0 7.0 8.0 ]=0A+popped 2.0, =
and reversed the rest: [ 8.0 7.0 6.0 5.0 4.0 3.0 ]=0A+popped 8.0, and rever=
sed the rest: [ 3.0 4.0 5.0 6.0 7.0 ]=0A+popped 3.0, and reversed the rest:=
 [ 7.0 6.0 5.0 4.0 ]=0A+popped 7.0, and reversed the rest: [ 4.0 5.0 6.0 ]=
=0A+popped 4.0, and reversed the rest: [ 6.0 5.0 ]=0A+popped 6.0, and rever=
sed the rest: [ 5.0 ]=0A+popped 5.0, and reversed the rest: [ ]=0A+=3D=3D22=
154=3D=3D=0A+=3D=3D22154=3D=3D HEAP SUMMARY:=0A+=3D=3D22154=3D=3D     in us=
e at exit: 0 bytes in 0 blocks=0A+=3D=3D22154=3D=3D   total heap usage: 19 =
allocs, 19 frees, 1,312 bytes allocated=0A+=3D=3D22154=3D=3D=0A+=3D=3D22154=
=3D=3D All heap blocks were freed -- no leaks are possible=0A+=3D=3D22154=
=3D=3D=0A+=3D=3D22154=3D=3D For counts of detected and suppressed errors, r=
erun with: -v=0A+=3D=3D22154=3D=3D ERROR SUMMARY: 0 errors from 0 contexts =
(suppressed: 0 from 0)=0A+=0A+=0A+=0A+=0A+----------------------------part1=
 (b)--------------------------=0A+=0A+=0A+----------------------------part =
(a)--------------------------=0A+----------------------------part (a)------=
--------------------=0A-- =0A2.17.1=0A=0A=0AFrom 1f5be0e91d10fd0c542d491646=
c090e354f14fa0 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia=
=2Eedu>=0ADate: Tue, 8 Mar 2022 13:48:38 -0500=0ASubject: [PATCH 3/4] finis=
h part1 b=0A=0A---=0A README.txt     | 59 +++++++++++++++++++++++++++++++++=
+++++++++++++++--=0A part1/Makefile |  7 ++++--=0A 2 files changed, 62 inse=
rtions(+), 4 deletions(-)=0A=0Adiff --git a/README.txt b/README.txt=0Aindex=
 d9c90cb..fd196b6 100644=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -60,6 +=
60,61 @@ popped 5.0, and reversed the rest: [ ]=0A =0A --------------------=
--------part1 (b)--------------------------=0A =0A+yz4004@clac ~/cs3157/lab=
3/part1 $ make clean=0A+rm -f *.o a.out core main=0A+yz4004@clac ~/cs3157/l=
ab3/part1 $ clear=0A+yz4004@clac ~/cs3157/lab3/part1 $ make=0A+gcc -c mylis=
t.c -o mylist.o=0A+ar rcs libmylist.a mylist.o=0A+gcc -c mylist-test.c -o  =
mylist-test.o=0A+gcc  mylist-test.o -o main -L. -lmylist=0A+yz4004@clac ~/c=
s3157/lab3/part1 $ valgrind --leak-check=3Dyes ./main=0A+=3D=3D24171=3D=3D =
Memcheck, a memory error detector=0A+=3D=3D24171=3D=3D Copyright (C) 2002-2=
017, and GNU GPL'd, by Julian Seward et al.=0A+=3D=3D24171=3D=3D Using Valg=
rind-3.13.0 and LibVEX; rerun with -h for copyright info=0A+=3D=3D24171=3D=
=3D Command: ./main=0A+=3D=3D24171=3D=3D=0A+testing addFront(): 9.0 8.0 7.0=
 6.0 5.0 4.0 3.0 2.0 1.0=0A+testing flipSignDouble(): -9.0 -8.0 -7.0 -6.0 -=
5.0 -4.0 -3.0 -2.0 -1.0=0A+testing flipSignDouble() again: 9.0 8.0 7.0 6.0 =
5.0 4.0 3.0 2.0 1.0=0A+testing findNode(): OK=0A+popped 9.0, the rest is: [=
 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]=0A+popped 8.0, the rest is: [ 7.0 6.0 5.=
0 4.0 3.0 2.0 1.0 ]=0A+popped 7.0, the rest is: [ 6.0 5.0 4.0 3.0 2.0 1.0 ]=
=0A+popped 6.0, the rest is: [ 5.0 4.0 3.0 2.0 1.0 ]=0A+popped 5.0, the res=
t is: [ 4.0 3.0 2.0 1.0 ]=0A+popped 4.0, the rest is: [ 3.0 2.0 1.0 ]=0A+po=
pped 3.0, the rest is: [ 2.0 1.0 ]=0A+popped 2.0, the rest is: [ 1.0 ]=0A+p=
opped 1.0, the rest is: [ ]=0A+testing addAfter(): 1.0 2.0 3.0 4.0 5.0 6.0 =
7.0 8.0 9.0=0A+popped 1.0, and reversed the rest: [ 9.0 8.0 7.0 6.0 5.0 4.0=
 3.0 2.0 ]=0A+popped 9.0, and reversed the rest: [ 2.0 3.0 4.0 5.0 6.0 7.0 =
8.0 ]=0A+popped 2.0, and reversed the rest: [ 8.0 7.0 6.0 5.0 4.0 3.0 ]=0A+=
popped 8.0, and reversed the rest: [ 3.0 4.0 5.0 6.0 7.0 ]=0A+popped 3.0, a=
nd reversed the rest: [ 7.0 6.0 5.0 4.0 ]=0A+popped 7.0, and reversed the r=
est: [ 4.0 5.0 6.0 ]=0A+popped 4.0, and reversed the rest: [ 6.0 5.0 ]=0A+p=
opped 6.0, and reversed the rest: [ 5.0 ]=0A+popped 5.0, and reversed the r=
est: [ ]=0A+=3D=3D24171=3D=3D=0A+=3D=3D24171=3D=3D HEAP SUMMARY:=0A+=3D=3D2=
4171=3D=3D     in use at exit: 0 bytes in 0 blocks=0A+=3D=3D24171=3D=3D   t=
otal heap usage: 19 allocs, 19 frees, 1,312 bytes allocated=0A+=3D=3D24171=
=3D=3D=0A+=3D=3D24171=3D=3D All heap blocks were freed -- no leaks are poss=
ible=0A+=3D=3D24171=3D=3D=0A+=3D=3D24171=3D=3D For counts of detected and s=
uppressed errors, rerun with: -v=0A+=3D=3D24171=3D=3D ERROR SUMMARY: 0 erro=
rs from 0 contexts (suppressed: 0 from 0)=0A+=0A+--------------------------=
--part2 --------------------------  =0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A=
 =0A-----------------------------part (a)--------------------------=0A-----=
------------------------part (a)--------------------------=0Adiff --git a/p=
art1/Makefile b/part1/Makefile=0Aindex 8d1df78..6f93eff 100644=0A--- a/part=
1/Makefile=0A+++ b/part1/Makefile=0A@@ -36,8 +36,8 @@ LDLIBS =3D=0A # Also =
note that make assumes that main depends on main.o,=0A # so we can omit it =
if we want to.=0A =0A-main: mylist.o mylist-test.o=0A-	gcc mylist.o mylist-=
test.o -o main =0A+main: libmylist.a  mylist-test.o=0A+	gcc  mylist-test.o =
-o main -L. -lmylist =0A # main.o depends not only on main.c, but also on m=
yadd.h because=0A # main.c includes myadd.h.  main.o will get recompiled if=
 either=0A # main.c or myadd.h get modified.=0A@@ -57,6 +57,9 @@ mylist-tes=
t.o: mylist-test.c mylist.h=0A mylist.o: mylist.c mylist.h=0A 	gcc -c mylis=
t.c -o mylist.o=0A =0A+libmylist.a: mylist.o=0A+	ar rcs libmylist.a mylist.=
o=0A+=0A # And myadd.o depends on myadd.c and myadd.h.=0A =0A # myadd.o: my=
add.c myadd.h=0A-- =0A2.17.1=0A=0A=0AFrom adf064a9ad450cf7fa2d0892191742fc6=
b58dfe1 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=
=0ADate: Tue, 8 Mar 2022 17:31:24 -0500=0ASubject: [PATCH 4/4] part2=0A=0A-=
--=0A part2/Makefile  | 30 ++++++++++++++++++++++++++++++=0A part2/revecho.=
c | 42 ++++++++++++++++++++++++++++++++++++++++++=0A 2 files changed, 72 in=
sertions(+)=0A create mode 100644 part2/Makefile=0A create mode 100644 part=
2/revecho.c=0A=0Adiff --git a/part2/Makefile b/part2/Makefile=0Anew file mo=
de 100644=0Aindex 0000000..dde3b17=0A--- /dev/null=0A+++ b/part2/Makefile=
=0A@@ -0,0 +1,30 @@=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+INCLUDES =3D=0A+=
=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=
=0A+=0A+LDFLAGS =3D -g=0A+=0A+LDLIBS =3D=0A+=0A+main:  revecho.o=0A+	gcc  r=
evecho.o -o main  -lmylist -L../part1 =0A+=0A+revecho.o:  revecho.c  =0A+	g=
cc -c  revecho.c -o  revecho.o -I../part1 =0A+=0A+# libmylist.a: mylist.o=
=0A+# 	ar rcs libmylist.a mylist.o=0A+=0A+=0A+.PHONY: clean=0A+clean:=0A+	r=
m -f *.o a.out core main=0A+=0A+.PHONY: all=0A+all: clean main=0A+=0A+=0Adi=
ff --git a/part2/revecho.c b/part2/revecho.c=0Anew file mode 100644=0Aindex=
 0000000..34eb22a=0A--- /dev/null=0A+++ b/part2/revecho.c=0A@@ -0,0 +1,42 @=
@=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include "mylist.h"=0A+=
=0A+int main(int argc, char **argv) {=0A+=0A+=0A+    if (argc <=3D 1)=0A+  =
      return 1;=0A+=0A+    argv++;=0A+=0A+    // initialize list=0A+    str=
uct List list;=0A+    initList(&list);=0A+=0A+=0A+    printf("%s \n","here"=
);=0A+=0A+    while (*argv) =0A+    {=0A+        // printf("%s \n", *argv);=
=0A+        addFront(&list, *argv++);=0A+=0A+    }=0A+=0A+    reverseList(&=
list);=0A+  =0A+=0A+    char *p;=0A+=0A+    struct Node* cur =3D list.head;=
=0A+    while (cur) {=0A+=0A+        p =3D  cur->data;=0A+=0A+        print=
f("%s", p);=0A+        cur =3D cur->data;=0A+=0A+    }=0A+    return 0;=0A+=
}=0A-- =0A2.17.1=0A=0A
--XsQoSWH+UP9D9v3l--

From do.not.reply@cloud.cs.columbia.edu Tue Mar  8 22:02:40 2022
Date: Tue, 8 Mar 2022 22:02:40 -0500
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab3.mbox
Message-ID: <20220309030240.GA28321@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="2oS5YaxWCcQjTEyO"
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 35646
Lines: 898


--2oS5YaxWCcQjTEyO
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: 8bit

From 35143dc731c7ecc21e5d5c814d90f3134d810810 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 8 Mar 2022 13:04:25 -0500
Subject: [PATCH 1/5] finish part1 a

---
 part1/Makefile |  80 +++++++++++++++++++++++++++++++
 part1/mylist.c | 124 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 204 insertions(+)
 create mode 100644 part1/Makefile
 create mode 100644 part1/mylist.c

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..8d1df78
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,80 @@
+# line does.
+
+# We'll use gcc for C compilation and g++ for C++ compilation
+
+CC  = gcc
+CXX = g++
+
+# Let's leave a place holder for additional include directories
+
+INCLUDES =
+
+# Compilation options:
+# -g for debugging info and -Wall enables all warnings
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+# Linking options:
+# -g for debugging info
+
+LDFLAGS = -g
+
+# List the libraries you need to link with in LDLIBS
+# For example, use "-lm" for the math library
+
+LDLIBS =
+
+# The 1st target gets built when you type "make".
+# It's usually your executable.  ("main" in this case.)
+#
+# Note that we did not specify the linking rule.
+# Instead, we rely on one of make's implicit rules:
+#
+#     $(CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)
+#
+# Also note that make assumes that main depends on main.o,
+# so we can omit it if we want to.
+
+main: mylist.o mylist-test.o
+	gcc mylist.o mylist-test.o -o main 
+# main.o depends not only on main.c, but also on myadd.h because
+# main.c includes myadd.h.  main.o will get recompiled if either
+# main.c or myadd.h get modified.
+#
+# make already knows main.o depends on main.c, so we can omit main.c
+# in the dependency list if we want to.
+#
+# make uses the following implicit rule to compile a .c file into a .o
+# file:
+#
+#     $(CC) -c $(CFLAGS) <the-.c-file>
+#
+
+mylist-test.o: mylist-test.c mylist.h 
+	gcc -c mylist-test.c -o  mylist-test.o
+
+mylist.o: mylist.c mylist.h
+	gcc -c mylist.c -o mylist.o
+
+# And myadd.o depends on myadd.c and myadd.h.
+
+# myadd.o: myadd.c myadd.h
+
+# Always provide the "clean" target that removes intermediate files.
+# What you remove depend on your choice of coding tools
+# (different editors generate different backup files for example).
+#
+# And the "clean" target is not a file name, so we tell make that
+# it's a "phony" target.
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+# "all" target is useful if your Makefile builds multiple programs.
+# Here we'll have it first do "clean", and rebuild the main target.
+
+.PHONY: all
+all: clean main
+
diff --git a/part1/mylist.c b/part1/mylist.c
new file mode 100644
index 0000000..2f644a3
--- /dev/null
+++ b/part1/mylist.c
@@ -0,0 +1,124 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "mylist.h"
+
+struct Node *addFront(struct List *list, void *data) {
+
+    struct Node *node = malloc(sizeof(data) + sizeof(list) );
+    if (!node) {
+        return NULL;
+    }
+
+    node->data = data;
+    node->next = list->head;
+    list->head = node;
+    return node;
+}
+
+void traverseList(struct List *list, void (*f)(void*)) {
+    
+    struct Node* head1 = list->head;
+
+    while (head1 != NULL) {
+        f(head1->data); // (*f)(head1->data)
+        head1 = head1->next;
+    }
+}
+
+void flipSignDouble(void* data) {
+
+    //double* data1 = data;
+
+    //double temp = (*data1) * (-1);
+    //// double temp = double(*data) * (-1); wrong ! data double  dereference 
+    //*data1 = temp;
+
+    double* data1 = data;
+    *data1 = (*data1) * (-1); 
+}
+
+int compareDouble(const void* data1, const void* data2) {
+
+    double d1 = *(double*)data1;
+    double d2 = *(double*)data2;
+
+    if (d1 == d2) {
+        return 0;
+    }
+    else {
+        return 1;
+    }
+}
+
+struct Node* findNode(struct List* list, const void* dataSought, int (*compar)(const void*, const void*)) {
+
+    struct Node* head1 = list->head;
+    while (head1 != NULL) {
+        if (!compar(head1->data, dataSought)) {
+            return head1;
+        }
+
+        head1 = head1->next;
+    }
+    return NULL;
+
+}
+
+void* popFront(struct List* list) {
+
+    struct Node* temp = list->head;
+    if (temp == NULL) {
+        return NULL;
+    }
+    void* data = list->head->data;
+    list->head = temp->next; //list->head = temp->next;
+
+    free(temp);
+    return data;
+}
+
+void removeAllNodes(struct List* list) {
+
+    while (popFront(list) != NULL) {
+
+    }
+}
+
+
+struct Node* addAfter(struct List* list, struct Node* prevNode, void* data) {
+
+    struct Node* node = malloc(sizeof(data) + sizeof(list));
+    if (!node) {
+        return NULL;
+    }
+
+    node->data = data;
+
+    if (prevNode != NULL) { // !prevNode fails
+        node->next = NULL;
+        prevNode->next = node;
+    }
+    else {
+        node->next = list->head;
+        list->head = node;
+    }
+    return node;
+
+
+}
+
+void reverseList(struct List* list) {
+
+    struct Node* prv = NULL;
+    struct Node* cur = list->head;
+    struct Node* nxt;
+
+    while (cur) {
+        nxt = cur->next;
+        cur->next = prv;
+        prv = cur;
+        cur = nxt;
+    }
+    list->head = prv;
+
+}
-- 
2.17.1


From f122cb4c2ff5969198e9e55348dfe25387beb76f Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 8 Mar 2022 13:09:38 -0500
Subject: [PATCH 2/5] modifiy README.txt for part1 a)

---
 README.txt | 54 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 54 insertions(+)

diff --git a/README.txt b/README.txt
index 66dfd3e..d9c90cb 100644
--- a/README.txt
+++ b/README.txt
@@ -9,3 +9,57 @@ The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+
+Yixuan Zou
+yz4004
+lab3
+
+----------------------------part1 (a)--------------------------
+
+yz4004@clac ~/cs3157/lab3/part1 $ valgrind --leak-check=yes ./main
+==22154== Memcheck, a memory error detector
+==22154== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==22154== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
+==22154== Command: ./main
+==22154==
+testing addFront(): 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0
+testing flipSignDouble(): -9.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0
+testing flipSignDouble() again: 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0
+testing findNode(): OK
+popped 9.0, the rest is: [ 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 8.0, the rest is: [ 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 7.0, the rest is: [ 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 6.0, the rest is: [ 5.0 4.0 3.0 2.0 1.0 ]
+popped 5.0, the rest is: [ 4.0 3.0 2.0 1.0 ]
+popped 4.0, the rest is: [ 3.0 2.0 1.0 ]
+popped 3.0, the rest is: [ 2.0 1.0 ]
+popped 2.0, the rest is: [ 1.0 ]
+popped 1.0, the rest is: [ ]
+testing addAfter(): 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0
+popped 1.0, and reversed the rest: [ 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 ]
+popped 9.0, and reversed the rest: [ 2.0 3.0 4.0 5.0 6.0 7.0 8.0 ]
+popped 2.0, and reversed the rest: [ 8.0 7.0 6.0 5.0 4.0 3.0 ]
+popped 8.0, and reversed the rest: [ 3.0 4.0 5.0 6.0 7.0 ]
+popped 3.0, and reversed the rest: [ 7.0 6.0 5.0 4.0 ]
+popped 7.0, and reversed the rest: [ 4.0 5.0 6.0 ]
+popped 4.0, and reversed the rest: [ 6.0 5.0 ]
+popped 6.0, and reversed the rest: [ 5.0 ]
+popped 5.0, and reversed the rest: [ ]
+==22154==
+==22154== HEAP SUMMARY:
+==22154==     in use at exit: 0 bytes in 0 blocks
+==22154==   total heap usage: 19 allocs, 19 frees, 1,312 bytes allocated
+==22154==
+==22154== All heap blocks were freed -- no leaks are possible
+==22154==
+==22154== For counts of detected and suppressed errors, rerun with: -v
+==22154== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+
+
+
+
+----------------------------part1 (b)--------------------------
+
+
+----------------------------part (a)--------------------------
+----------------------------part (a)--------------------------
-- 
2.17.1


From 1f5be0e91d10fd0c542d491646c090e354f14fa0 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 8 Mar 2022 13:48:38 -0500
Subject: [PATCH 3/5] finish part1 b

---
 README.txt     | 59 ++++++++++++++++++++++++++++++++++++++++++++++++--
 part1/Makefile |  7 ++++--
 2 files changed, 62 insertions(+), 4 deletions(-)

diff --git a/README.txt b/README.txt
index d9c90cb..fd196b6 100644
--- a/README.txt
+++ b/README.txt
@@ -60,6 +60,61 @@ popped 5.0, and reversed the rest: [ ]
 
 ----------------------------part1 (b)--------------------------
 
+yz4004@clac ~/cs3157/lab3/part1 $ make clean
+rm -f *.o a.out core main
+yz4004@clac ~/cs3157/lab3/part1 $ clear
+yz4004@clac ~/cs3157/lab3/part1 $ make
+gcc -c mylist.c -o mylist.o
+ar rcs libmylist.a mylist.o
+gcc -c mylist-test.c -o  mylist-test.o
+gcc  mylist-test.o -o main -L. -lmylist
+yz4004@clac ~/cs3157/lab3/part1 $ valgrind --leak-check=yes ./main
+==24171== Memcheck, a memory error detector
+==24171== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==24171== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
+==24171== Command: ./main
+==24171==
+testing addFront(): 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0
+testing flipSignDouble(): -9.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0
+testing flipSignDouble() again: 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0
+testing findNode(): OK
+popped 9.0, the rest is: [ 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 8.0, the rest is: [ 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 7.0, the rest is: [ 6.0 5.0 4.0 3.0 2.0 1.0 ]
+popped 6.0, the rest is: [ 5.0 4.0 3.0 2.0 1.0 ]
+popped 5.0, the rest is: [ 4.0 3.0 2.0 1.0 ]
+popped 4.0, the rest is: [ 3.0 2.0 1.0 ]
+popped 3.0, the rest is: [ 2.0 1.0 ]
+popped 2.0, the rest is: [ 1.0 ]
+popped 1.0, the rest is: [ ]
+testing addAfter(): 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0
+popped 1.0, and reversed the rest: [ 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 ]
+popped 9.0, and reversed the rest: [ 2.0 3.0 4.0 5.0 6.0 7.0 8.0 ]
+popped 2.0, and reversed the rest: [ 8.0 7.0 6.0 5.0 4.0 3.0 ]
+popped 8.0, and reversed the rest: [ 3.0 4.0 5.0 6.0 7.0 ]
+popped 3.0, and reversed the rest: [ 7.0 6.0 5.0 4.0 ]
+popped 7.0, and reversed the rest: [ 4.0 5.0 6.0 ]
+popped 4.0, and reversed the rest: [ 6.0 5.0 ]
+popped 6.0, and reversed the rest: [ 5.0 ]
+popped 5.0, and reversed the rest: [ ]
+==24171==
+==24171== HEAP SUMMARY:
+==24171==     in use at exit: 0 bytes in 0 blocks
+==24171==   total heap usage: 19 allocs, 19 frees, 1,312 bytes allocated
+==24171==
+==24171== All heap blocks were freed -- no leaks are possible
+==24171==
+==24171== For counts of detected and suppressed errors, rerun with: -v
+==24171== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+
+----------------------------part2 --------------------------  
+
+
+
+
+
+
+
+
+
 
-----------------------------part (a)--------------------------
-----------------------------part (a)--------------------------
diff --git a/part1/Makefile b/part1/Makefile
index 8d1df78..6f93eff 100644
--- a/part1/Makefile
+++ b/part1/Makefile
@@ -36,8 +36,8 @@ LDLIBS =
 # Also note that make assumes that main depends on main.o,
 # so we can omit it if we want to.
 
-main: mylist.o mylist-test.o
-	gcc mylist.o mylist-test.o -o main 
+main: libmylist.a  mylist-test.o
+	gcc  mylist-test.o -o main -L. -lmylist 
 # main.o depends not only on main.c, but also on myadd.h because
 # main.c includes myadd.h.  main.o will get recompiled if either
 # main.c or myadd.h get modified.
@@ -57,6 +57,9 @@ mylist-test.o: mylist-test.c mylist.h
 mylist.o: mylist.c mylist.h
 	gcc -c mylist.c -o mylist.o
 
+libmylist.a: mylist.o
+	ar rcs libmylist.a mylist.o
+
 # And myadd.o depends on myadd.c and myadd.h.
 
 # myadd.o: myadd.c myadd.h
-- 
2.17.1


From adf064a9ad450cf7fa2d0892191742fc6b58dfe1 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 8 Mar 2022 17:31:24 -0500
Subject: [PATCH 4/5] part2

---
 part2/Makefile  | 30 ++++++++++++++++++++++++++++++
 part2/revecho.c | 42 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 72 insertions(+)
 create mode 100644 part2/Makefile
 create mode 100644 part2/revecho.c

diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..dde3b17
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,30 @@
+CC  = gcc
+CXX = g++
+
+INCLUDES =
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+LDFLAGS = -g
+
+LDLIBS =
+
+main:  revecho.o
+	gcc  revecho.o -o main  -lmylist -L../part1 
+
+revecho.o:  revecho.c  
+	gcc -c  revecho.c -o  revecho.o -I../part1 
+
+# libmylist.a: mylist.o
+# 	ar rcs libmylist.a mylist.o
+
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+.PHONY: all
+all: clean main
+
+
diff --git a/part2/revecho.c b/part2/revecho.c
new file mode 100644
index 0000000..34eb22a
--- /dev/null
+++ b/part2/revecho.c
@@ -0,0 +1,42 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "mylist.h"
+
+int main(int argc, char **argv) {
+
+
+    if (argc <= 1)
+        return 1;
+
+    argv++;
+
+    // initialize list
+    struct List list;
+    initList(&list);
+
+
+    printf("%s \n","here");
+
+    while (*argv) 
+    {
+        // printf("%s \n", *argv);
+        addFront(&list, *argv++);
+
+    }
+
+    reverseList(&list);
+  
+
+    char *p;
+
+    struct Node* cur = list.head;
+    while (cur) {
+
+        p =  cur->data;
+
+        printf("%s", p);
+        cur = cur->data;
+
+    }
+    return 0;
+}
-- 
2.17.1


From 3e1aafbfd1374fe51373217c347c874880a19358 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 8 Mar 2022 22:01:32 -0500
Subject: [PATCH 5/5] finish part2

---
 README.txt      | 19 ++++++++++++++++++
 part2/revecho.c | 53 ++++++++++++++++++++++++++++++++++---------------
 2 files changed, 56 insertions(+), 16 deletions(-)

diff --git a/README.txt b/README.txt
index fd196b6..1909513 100644
--- a/README.txt
+++ b/README.txt
@@ -111,6 +111,25 @@ popped 5.0, and reversed the rest: [ ]
 
 
 
+yz4004@clac ~/cs3157/lab3/part2 $ valgrind --leak-check=yes ./main hello world dude
+==19050== Memcheck, a memory error detector
+==19050== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==19050== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
+==19050== Command: ./main hello world dude
+==19050==
+dude
+world
+hello
+
+dude found==19050==
+==19050== HEAP SUMMARY:
+==19050==     in use at exit: 0 bytes in 0 blocks
+==19050==   total heap usage: 4 allocs, 4 frees, 1,072 bytes allocated
+==19050==
+==19050== All heap blocks were freed -- no leaks are possible
+==19050==
+==19050== For counts of detected and suppressed errors, rerun with: -v
+==19050== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
 
 
 
diff --git a/part2/revecho.c b/part2/revecho.c
index 34eb22a..f7a5aa5 100644
--- a/part2/revecho.c
+++ b/part2/revecho.c
@@ -1,11 +1,10 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include "mylist.h"
-
+#include <string.h>
+void free_list(struct Node* head);
 int main(int argc, char **argv) {
-
-
-    if (argc <= 1)
+        if (argc <= 1)
         return 1;
 
     argv++;
@@ -15,28 +14,50 @@ int main(int argc, char **argv) {
     initList(&list);
 
 
-    printf("%s \n","here");
 
-    while (*argv) 
-    {
-        // printf("%s \n", *argv);
+    while (*argv) {
+        //printf("%s \n", *argv);
         addFront(&list, *argv++);
 
     }
 
-    reverseList(&list);
-  
+    //reverseList(&list);
+    struct Node* cur = list.head;
+
+    char* p;
 
-    char *p;
+    int indicator = 1;
 
-    struct Node* cur = list.head;
     while (cur) {
 
-        p =  cur->data;
+        p = (char*) (cur->data);
 
-        printf("%s", p);
-        cur = cur->data;
+        if (indicator != 0) {
+            indicator = strcmp(p, "dude");
+        }
 
+        printf("%s \n", p);
+        cur = cur->next;
+
+    }
+
+    if (indicator == 0) {
+        printf("\ndude found");
+
+    }
+    else {
+        printf("\ndude not found");
+    }
+    free_list(list.head);
+	return 0;
+}
+
+void free_list(struct Node* head) {
+    if (!head) {
+        return;
+    }
+    else {
+        free_list(head->next);
+        free(head);
     }
-    return 0;
 }
-- 
2.17.1


--2oS5YaxWCcQjTEyO
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab3.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 35143dc731c7ecc21e5d5c814d90f3134d810810 Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Tue, 8 Mar 2022 13:04:25 -=
0500=0ASubject: [PATCH 1/5] finish part1 a=0A=0A---=0A part1/Makefile |  80=
 +++++++++++++++++++++++++++++++=0A part1/mylist.c | 124 ++++++++++++++++++=
+++++++++++++++++++++++++++++++=0A 2 files changed, 204 insertions(+)=0A cr=
eate mode 100644 part1/Makefile=0A create mode 100644 part1/mylist.c=0A=0Ad=
iff --git a/part1/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex =
0000000..8d1df78=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,80 @@=
=0A+# line does.=0A+=0A+# We'll use gcc for C compilation and g++ for C++ c=
ompilation=0A+=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+# Let's leave a place h=
older for additional include directories=0A+=0A+INCLUDES =3D=0A+=0A+# Compi=
lation options:=0A+# -g for debugging info and -Wall enables all warnings=
=0A+=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g -Wall $(INCLUD=
ES)=0A+=0A+# Linking options:=0A+# -g for debugging info=0A+=0A+LDFLAGS =3D=
 -g=0A+=0A+# List the libraries you need to link with in LDLIBS=0A+# For ex=
ample, use "-lm" for the math library=0A+=0A+LDLIBS =3D=0A+=0A+# The 1st ta=
rget gets built when you type "make".=0A+# It's usually your executable.  (=
"main" in this case.)=0A+#=0A+# Note that we did not specify the linking ru=
le.=0A+# Instead, we rely on one of make's implicit rules:=0A+#=0A+#     $(=
CC) $(LDFLAGS) <all-dependent-.o-files> $(LDLIBS)=0A+#=0A+# Also note that =
make assumes that main depends on main.o,=0A+# so we can omit it if we want=
 to.=0A+=0A+main: mylist.o mylist-test.o=0A+	gcc mylist.o mylist-test.o -o =
main =0A+# main.o depends not only on main.c, but also on myadd.h because=
=0A+# main.c includes myadd.h.  main.o will get recompiled if either=0A+# m=
ain.c or myadd.h get modified.=0A+#=0A+# make already knows main.o depends =
on main.c, so we can omit main.c=0A+# in the dependency list if we want to.=
=0A+#=0A+# make uses the following implicit rule to compile a .c file into =
a .o=0A+# file:=0A+#=0A+#     $(CC) -c $(CFLAGS) <the-.c-file>=0A+#=0A+=0A+=
mylist-test.o: mylist-test.c mylist.h =0A+	gcc -c mylist-test.c -o  mylist-=
test.o=0A+=0A+mylist.o: mylist.c mylist.h=0A+	gcc -c mylist.c -o mylist.o=
=0A+=0A+# And myadd.o depends on myadd.c and myadd.h.=0A+=0A+# myadd.o: mya=
dd.c myadd.h=0A+=0A+# Always provide the "clean" target that removes interm=
ediate files.=0A+# What you remove depend on your choice of coding tools=0A=
+# (different editors generate different backup files for example).=0A+#=0A=
+# And the "clean" target is not a file name, so we tell make that=0A+# it'=
s a "phony" target.=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.o a.out core=
 main=0A+=0A+# "all" target is useful if your Makefile builds multiple prog=
rams.=0A+# Here we'll have it first do "clean", and rebuild the main target=
=2E=0A+=0A+.PHONY: all=0A+all: clean main=0A+=0Adiff --git a/part1/mylist.c=
 b/part1/mylist.c=0Anew file mode 100644=0Aindex 0000000..2f644a3=0A--- /de=
v/null=0A+++ b/part1/mylist.c=0A@@ -0,0 +1,124 @@=0A+#include <stdio.h>=0A+=
#include <stdlib.h>=0A+#include "mylist.h"=0A+=0A+struct Node *addFront(str=
uct List *list, void *data) {=0A+=0A+    struct Node *node =3D malloc(sizeo=
f(data) + sizeof(list) );=0A+    if (!node) {=0A+        return NULL;=0A+  =
  }=0A+=0A+    node->data =3D data;=0A+    node->next =3D list->head;=0A+  =
  list->head =3D node;=0A+    return node;=0A+}=0A+=0A+void traverseList(st=
ruct List *list, void (*f)(void*)) {=0A+    =0A+    struct Node* head1 =3D =
list->head;=0A+=0A+    while (head1 !=3D NULL) {=0A+        f(head1->data);=
 // (*f)(head1->data)=0A+        head1 =3D head1->next;=0A+    }=0A+}=0A+=
=0A+void flipSignDouble(void* data) {=0A+=0A+    //double* data1 =3D data;=
=0A+=0A+    //double temp =3D (*data1) * (-1);=0A+    //// double temp =3D =
=EF=BC=88double=EF=BC=89(*data) * (-1); wrong ! data =E8=A6=81=E5=85=88=E8=
=BD=AC=E6=8D=A2=E6=88=90double=E6=8C=87=E9=92=88 =E8=80=8C=E4=B8=8D=E6=98=
=AF dereference =E5=90=8E=E5=86=8D=E8=BD=AC=0A+    //*data1 =3D temp;=0A+=
=0A+    double* data1 =3D data;=0A+    *data1 =3D (*data1) * (-1); =0A+}=0A=
+=0A+int compareDouble(const void* data1, const void* data2) {=0A+=0A+    d=
ouble d1 =3D *(double*)data1;=0A+    double d2 =3D *(double*)data2;=0A+=0A+=
    if (d1 =3D=3D d2) {=0A+        return 0;=0A+    }=0A+    else {=0A+    =
    return 1;=0A+    }=0A+}=0A+=0A+struct Node* findNode(struct List* list,=
 const void* dataSought, int (*compar)(const void*, const void*)) {=0A+=0A+=
    struct Node* head1 =3D list->head;=0A+    while (head1 !=3D NULL) {=0A+=
        if (!compar(head1->data, dataSought)) {=0A+            return head1=
;=0A+        }=0A+=0A+        head1 =3D head1->next;=0A+    }=0A+    return=
 NULL;=0A+=0A+}=0A+=0A+void* popFront(struct List* list) {=0A+=0A+    struc=
t Node* temp =3D list->head;=0A+    if (temp =3D=3D NULL) {=0A+        retu=
rn NULL;=0A+    }=0A+    void* data =3D list->head->data;=0A+    list->head=
 =3D temp->next; //list->head =3D temp->next;=0A+=0A+    free(temp);=0A+   =
 return data;=0A+}=0A+=0A+void removeAllNodes(struct List* list) {=0A+=0A+ =
   while (popFront(list) !=3D NULL) {=0A+=0A+    }=0A+}=0A+=0A+=0A+struct N=
ode* addAfter(struct List* list, struct Node* prevNode, void* data) {=0A+=
=0A+    struct Node* node =3D malloc(sizeof(data) + sizeof(list));=0A+    i=
f (!node) {=0A+        return NULL;=0A+    }=0A+=0A+    node->data =3D data=
;=0A+=0A+    if (prevNode !=3D NULL) { // !prevNode fails=0A+        node->=
next =3D NULL;=0A+        prevNode->next =3D node;=0A+    }=0A+    else {=
=0A+        node->next =3D list->head;=0A+        list->head =3D node;=0A+ =
   }=0A+    return node;=0A+=0A+=0A+}=0A+=0A+void reverseList(struct List* =
list) {=0A+=0A+    struct Node* prv =3D NULL;=0A+    struct Node* cur =3D l=
ist->head;=0A+    struct Node* nxt;=0A+=0A+    while (cur) {=0A+        nxt=
 =3D cur->next;=0A+        cur->next =3D prv;=0A+        prv =3D cur;=0A+  =
      cur =3D nxt;=0A+    }=0A+    list->head =3D prv;=0A+=0A+}=0A-- =0A2.1=
7.1=0A=0A=0AFrom f122cb4c2ff5969198e9e55348dfe25387beb76f Mon Sep 17 00:00:=
00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Tue, 8 Mar 2022 13=
:09:38 -0500=0ASubject: [PATCH 2/5] modifiy README.txt for part1 a)=0A=0A--=
-=0A README.txt | 54 ++++++++++++++++++++++++++++++++++++++++++++++++++++++=
=0A 1 file changed, 54 insertions(+)=0A=0Adiff --git a/README.txt b/README.=
txt=0Aindex 66dfd3e..d9c90cb 100644=0A--- a/README.txt=0A+++ b/README.txt=
=0A@@ -9,3 +9,57 @@ The description should indicate whether your solution f=
or the part is=0A working or not.  You may also want to include anything el=
se you would=0A like to communicate to the grader such as extra functionali=
ties you=0A implemented or how you tried to fix your non-working code.=0A+=
=0A+Yixuan Zou=0A+yz4004=0A+lab3=0A+=0A+----------------------------part1 (=
a)--------------------------=0A+=0A+yz4004@clac ~/cs3157/lab3/part1 $ valgr=
ind --leak-check=3Dyes ./main=0A+=3D=3D22154=3D=3D Memcheck, a memory error=
 detector=0A+=3D=3D22154=3D=3D Copyright (C) 2002-2017, and GNU GPL'd, by J=
ulian Seward et al.=0A+=3D=3D22154=3D=3D Using Valgrind-3.13.0 and LibVEX; =
rerun with -h for copyright info=0A+=3D=3D22154=3D=3D Command: ./main=0A+=
=3D=3D22154=3D=3D=0A+testing addFront(): 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.=
0=0A+testing flipSignDouble(): -9.0 -8.0 -7.0 -6.0 -5.0 -4.0 -3.0 -2.0 -1.0=
=0A+testing flipSignDouble() again: 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0=0A+=
testing findNode(): OK=0A+popped 9.0, the rest is: [ 8.0 7.0 6.0 5.0 4.0 3.=
0 2.0 1.0 ]=0A+popped 8.0, the rest is: [ 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]=0A+=
popped 7.0, the rest is: [ 6.0 5.0 4.0 3.0 2.0 1.0 ]=0A+popped 6.0, the res=
t is: [ 5.0 4.0 3.0 2.0 1.0 ]=0A+popped 5.0, the rest is: [ 4.0 3.0 2.0 1.0=
 ]=0A+popped 4.0, the rest is: [ 3.0 2.0 1.0 ]=0A+popped 3.0, the rest is: =
[ 2.0 1.0 ]=0A+popped 2.0, the rest is: [ 1.0 ]=0A+popped 1.0, the rest is:=
 [ ]=0A+testing addAfter(): 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0=0A+popped 1=
=2E0, and reversed the rest: [ 9.0 8.0 7.0 6.0 5.0 4.0 3.0 2.0 ]=0A+popped =
9.0, and reversed the rest: [ 2.0 3.0 4.0 5.0 6.0 7.0 8.0 ]=0A+popped 2.0, =
and reversed the rest: [ 8.0 7.0 6.0 5.0 4.0 3.0 ]=0A+popped 8.0, and rever=
sed the rest: [ 3.0 4.0 5.0 6.0 7.0 ]=0A+popped 3.0, and reversed the rest:=
 [ 7.0 6.0 5.0 4.0 ]=0A+popped 7.0, and reversed the rest: [ 4.0 5.0 6.0 ]=
=0A+popped 4.0, and reversed the rest: [ 6.0 5.0 ]=0A+popped 6.0, and rever=
sed the rest: [ 5.0 ]=0A+popped 5.0, and reversed the rest: [ ]=0A+=3D=3D22=
154=3D=3D=0A+=3D=3D22154=3D=3D HEAP SUMMARY:=0A+=3D=3D22154=3D=3D     in us=
e at exit: 0 bytes in 0 blocks=0A+=3D=3D22154=3D=3D   total heap usage: 19 =
allocs, 19 frees, 1,312 bytes allocated=0A+=3D=3D22154=3D=3D=0A+=3D=3D22154=
=3D=3D All heap blocks were freed -- no leaks are possible=0A+=3D=3D22154=
=3D=3D=0A+=3D=3D22154=3D=3D For counts of detected and suppressed errors, r=
erun with: -v=0A+=3D=3D22154=3D=3D ERROR SUMMARY: 0 errors from 0 contexts =
(suppressed: 0 from 0)=0A+=0A+=0A+=0A+=0A+----------------------------part1=
 (b)--------------------------=0A+=0A+=0A+----------------------------part =
(a)--------------------------=0A+----------------------------part (a)------=
--------------------=0A-- =0A2.17.1=0A=0A=0AFrom 1f5be0e91d10fd0c542d491646=
c090e354f14fa0 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia=
=2Eedu>=0ADate: Tue, 8 Mar 2022 13:48:38 -0500=0ASubject: [PATCH 3/5] finis=
h part1 b=0A=0A---=0A README.txt     | 59 +++++++++++++++++++++++++++++++++=
+++++++++++++++--=0A part1/Makefile |  7 ++++--=0A 2 files changed, 62 inse=
rtions(+), 4 deletions(-)=0A=0Adiff --git a/README.txt b/README.txt=0Aindex=
 d9c90cb..fd196b6 100644=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -60,6 +=
60,61 @@ popped 5.0, and reversed the rest: [ ]=0A =0A --------------------=
--------part1 (b)--------------------------=0A =0A+yz4004@clac ~/cs3157/lab=
3/part1 $ make clean=0A+rm -f *.o a.out core main=0A+yz4004@clac ~/cs3157/l=
ab3/part1 $ clear=0A+yz4004@clac ~/cs3157/lab3/part1 $ make=0A+gcc -c mylis=
t.c -o mylist.o=0A+ar rcs libmylist.a mylist.o=0A+gcc -c mylist-test.c -o  =
mylist-test.o=0A+gcc  mylist-test.o -o main -L. -lmylist=0A+yz4004@clac ~/c=
s3157/lab3/part1 $ valgrind --leak-check=3Dyes ./main=0A+=3D=3D24171=3D=3D =
Memcheck, a memory error detector=0A+=3D=3D24171=3D=3D Copyright (C) 2002-2=
017, and GNU GPL'd, by Julian Seward et al.=0A+=3D=3D24171=3D=3D Using Valg=
rind-3.13.0 and LibVEX; rerun with -h for copyright info=0A+=3D=3D24171=3D=
=3D Command: ./main=0A+=3D=3D24171=3D=3D=0A+testing addFront(): 9.0 8.0 7.0=
 6.0 5.0 4.0 3.0 2.0 1.0=0A+testing flipSignDouble(): -9.0 -8.0 -7.0 -6.0 -=
5.0 -4.0 -3.0 -2.0 -1.0=0A+testing flipSignDouble() again: 9.0 8.0 7.0 6.0 =
5.0 4.0 3.0 2.0 1.0=0A+testing findNode(): OK=0A+popped 9.0, the rest is: [=
 8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0 ]=0A+popped 8.0, the rest is: [ 7.0 6.0 5.=
0 4.0 3.0 2.0 1.0 ]=0A+popped 7.0, the rest is: [ 6.0 5.0 4.0 3.0 2.0 1.0 ]=
=0A+popped 6.0, the rest is: [ 5.0 4.0 3.0 2.0 1.0 ]=0A+popped 5.0, the res=
t is: [ 4.0 3.0 2.0 1.0 ]=0A+popped 4.0, the rest is: [ 3.0 2.0 1.0 ]=0A+po=
pped 3.0, the rest is: [ 2.0 1.0 ]=0A+popped 2.0, the rest is: [ 1.0 ]=0A+p=
opped 1.0, the rest is: [ ]=0A+testing addAfter(): 1.0 2.0 3.0 4.0 5.0 6.0 =
7.0 8.0 9.0=0A+popped 1.0, and reversed the rest: [ 9.0 8.0 7.0 6.0 5.0 4.0=
 3.0 2.0 ]=0A+popped 9.0, and reversed the rest: [ 2.0 3.0 4.0 5.0 6.0 7.0 =
8.0 ]=0A+popped 2.0, and reversed the rest: [ 8.0 7.0 6.0 5.0 4.0 3.0 ]=0A+=
popped 8.0, and reversed the rest: [ 3.0 4.0 5.0 6.0 7.0 ]=0A+popped 3.0, a=
nd reversed the rest: [ 7.0 6.0 5.0 4.0 ]=0A+popped 7.0, and reversed the r=
est: [ 4.0 5.0 6.0 ]=0A+popped 4.0, and reversed the rest: [ 6.0 5.0 ]=0A+p=
opped 6.0, and reversed the rest: [ 5.0 ]=0A+popped 5.0, and reversed the r=
est: [ ]=0A+=3D=3D24171=3D=3D=0A+=3D=3D24171=3D=3D HEAP SUMMARY:=0A+=3D=3D2=
4171=3D=3D     in use at exit: 0 bytes in 0 blocks=0A+=3D=3D24171=3D=3D   t=
otal heap usage: 19 allocs, 19 frees, 1,312 bytes allocated=0A+=3D=3D24171=
=3D=3D=0A+=3D=3D24171=3D=3D All heap blocks were freed -- no leaks are poss=
ible=0A+=3D=3D24171=3D=3D=0A+=3D=3D24171=3D=3D For counts of detected and s=
uppressed errors, rerun with: -v=0A+=3D=3D24171=3D=3D ERROR SUMMARY: 0 erro=
rs from 0 contexts (suppressed: 0 from 0)=0A+=0A+--------------------------=
--part2 --------------------------  =0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A=
 =0A-----------------------------part (a)--------------------------=0A-----=
------------------------part (a)--------------------------=0Adiff --git a/p=
art1/Makefile b/part1/Makefile=0Aindex 8d1df78..6f93eff 100644=0A--- a/part=
1/Makefile=0A+++ b/part1/Makefile=0A@@ -36,8 +36,8 @@ LDLIBS =3D=0A # Also =
note that make assumes that main depends on main.o,=0A # so we can omit it =
if we want to.=0A =0A-main: mylist.o mylist-test.o=0A-	gcc mylist.o mylist-=
test.o -o main =0A+main: libmylist.a  mylist-test.o=0A+	gcc  mylist-test.o =
-o main -L. -lmylist =0A # main.o depends not only on main.c, but also on m=
yadd.h because=0A # main.c includes myadd.h.  main.o will get recompiled if=
 either=0A # main.c or myadd.h get modified.=0A@@ -57,6 +57,9 @@ mylist-tes=
t.o: mylist-test.c mylist.h=0A mylist.o: mylist.c mylist.h=0A 	gcc -c mylis=
t.c -o mylist.o=0A =0A+libmylist.a: mylist.o=0A+	ar rcs libmylist.a mylist.=
o=0A+=0A # And myadd.o depends on myadd.c and myadd.h.=0A =0A # myadd.o: my=
add.c myadd.h=0A-- =0A2.17.1=0A=0A=0AFrom adf064a9ad450cf7fa2d0892191742fc6=
b58dfe1 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=
=0ADate: Tue, 8 Mar 2022 17:31:24 -0500=0ASubject: [PATCH 4/5] part2=0A=0A-=
--=0A part2/Makefile  | 30 ++++++++++++++++++++++++++++++=0A part2/revecho.=
c | 42 ++++++++++++++++++++++++++++++++++++++++++=0A 2 files changed, 72 in=
sertions(+)=0A create mode 100644 part2/Makefile=0A create mode 100644 part=
2/revecho.c=0A=0Adiff --git a/part2/Makefile b/part2/Makefile=0Anew file mo=
de 100644=0Aindex 0000000..dde3b17=0A--- /dev/null=0A+++ b/part2/Makefile=
=0A@@ -0,0 +1,30 @@=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+INCLUDES =3D=0A+=
=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=
=0A+=0A+LDFLAGS =3D -g=0A+=0A+LDLIBS =3D=0A+=0A+main:  revecho.o=0A+	gcc  r=
evecho.o -o main  -lmylist -L../part1 =0A+=0A+revecho.o:  revecho.c  =0A+	g=
cc -c  revecho.c -o  revecho.o -I../part1 =0A+=0A+# libmylist.a: mylist.o=
=0A+# 	ar rcs libmylist.a mylist.o=0A+=0A+=0A+.PHONY: clean=0A+clean:=0A+	r=
m -f *.o a.out core main=0A+=0A+.PHONY: all=0A+all: clean main=0A+=0A+=0Adi=
ff --git a/part2/revecho.c b/part2/revecho.c=0Anew file mode 100644=0Aindex=
 0000000..34eb22a=0A--- /dev/null=0A+++ b/part2/revecho.c=0A@@ -0,0 +1,42 @=
@=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include "mylist.h"=0A+=
=0A+int main(int argc, char **argv) {=0A+=0A+=0A+    if (argc <=3D 1)=0A+  =
      return 1;=0A+=0A+    argv++;=0A+=0A+    // initialize list=0A+    str=
uct List list;=0A+    initList(&list);=0A+=0A+=0A+    printf("%s \n","here"=
);=0A+=0A+    while (*argv) =0A+    {=0A+        // printf("%s \n", *argv);=
=0A+        addFront(&list, *argv++);=0A+=0A+    }=0A+=0A+    reverseList(&=
list);=0A+  =0A+=0A+    char *p;=0A+=0A+    struct Node* cur =3D list.head;=
=0A+    while (cur) {=0A+=0A+        p =3D  cur->data;=0A+=0A+        print=
f("%s", p);=0A+        cur =3D cur->data;=0A+=0A+    }=0A+    return 0;=0A+=
}=0A-- =0A2.17.1=0A=0A=0AFrom 3e1aafbfd1374fe51373217c347c874880a19358 Mon =
Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Tue, =
8 Mar 2022 22:01:32 -0500=0ASubject: [PATCH 5/5] finish part2=0A=0A---=0A R=
EADME.txt      | 19 ++++++++++++++++++=0A part2/revecho.c | 53 ++++++++++++=
++++++++++++++++++++++---------------=0A 2 files changed, 56 insertions(+),=
 16 deletions(-)=0A=0Adiff --git a/README.txt b/README.txt=0Aindex fd196b6.=
=2E1909513 100644=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -111,6 +111,25=
 @@ popped 5.0, and reversed the rest: [ ]=0A =0A =0A =0A+yz4004@clac ~/cs3=
157/lab3/part2 $ valgrind --leak-check=3Dyes ./main hello world dude=0A+=3D=
=3D19050=3D=3D Memcheck, a memory error detector=0A+=3D=3D19050=3D=3D Copyr=
ight (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.=0A+=3D=3D19050=
=3D=3D Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info=
=0A+=3D=3D19050=3D=3D Command: ./main hello world dude=0A+=3D=3D19050=3D=3D=
=0A+dude=0A+world=0A+hello=0A+=0A+dude found=3D=3D19050=3D=3D=0A+=3D=3D1905=
0=3D=3D HEAP SUMMARY:=0A+=3D=3D19050=3D=3D     in use at exit: 0 bytes in 0=
 blocks=0A+=3D=3D19050=3D=3D   total heap usage: 4 allocs, 4 frees, 1,072 b=
ytes allocated=0A+=3D=3D19050=3D=3D=0A+=3D=3D19050=3D=3D All heap blocks we=
re freed -- no leaks are possible=0A+=3D=3D19050=3D=3D=0A+=3D=3D19050=3D=3D=
 For counts of detected and suppressed errors, rerun with: -v=0A+=3D=3D1905=
0=3D=3D ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)=0A =
=0A =0A =0Adiff --git a/part2/revecho.c b/part2/revecho.c=0Aindex 34eb22a..=
f7a5aa5 100644=0A--- a/part2/revecho.c=0A+++ b/part2/revecho.c=0A@@ -1,11 +=
1,10 @@=0A #include <stdio.h>=0A #include <stdlib.h>=0A #include "mylist.h"=
=0A-=0A+#include <string.h>=0A+void free_list(struct Node* head);=0A int ma=
in(int argc, char **argv) {=0A-=0A-=0A-    if (argc <=3D 1)=0A+        if (=
argc <=3D 1)=0A         return 1;=0A =0A     argv++;=0A@@ -15,28 +14,50 @@ =
int main(int argc, char **argv) {=0A     initList(&list);=0A =0A =0A-    pr=
intf("%s \n","here");=0A =0A-    while (*argv) =0A-    {=0A-        // prin=
tf("%s \n", *argv);=0A+    while (*argv) {=0A+        //printf("%s \n", *ar=
gv);=0A         addFront(&list, *argv++);=0A =0A     }=0A =0A-    reverseLi=
st(&list);=0A-  =0A+    //reverseList(&list);=0A+    struct Node* cur =3D l=
ist.head;=0A+=0A+    char* p;=0A =0A-    char *p;=0A+    int indicator =3D =
1;=0A =0A-    struct Node* cur =3D list.head;=0A     while (cur) {=0A =0A- =
       p =3D  cur->data;=0A+        p =3D (char*) (cur->data);=0A =0A-     =
   printf("%s", p);=0A-        cur =3D cur->data;=0A+        if (indicator =
!=3D 0) {=0A+            indicator =3D strcmp(p, "dude");=0A+        }=0A =
=0A+        printf("%s \n", p);=0A+        cur =3D cur->next;=0A+=0A+    }=
=0A+=0A+    if (indicator =3D=3D 0) {=0A+        printf("\ndude found");=0A=
+=0A+    }=0A+    else {=0A+        printf("\ndude not found");=0A+    }=0A=
+    free_list(list.head);=0A+	return 0;=0A+}=0A+=0A+void free_list(struct =
Node* head) {=0A+    if (!head) {=0A+        return;=0A+    }=0A+    else {=
=0A+        free_list(head->next);=0A+        free(head);=0A     }=0A-    r=
eturn 0;=0A }=0A-- =0A2.17.1=0A=0A
--2oS5YaxWCcQjTEyO--

From do.not.reply@cloud.cs.columbia.edu Tue Mar 22 22:08:32 2022
Date: Tue, 22 Mar 2022 22:08:32 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab4.mbox
Message-ID: <20220323020832.GA29991@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="+QahgC5+KEYLbs62"
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 29760
Lines: 750


--+QahgC5+KEYLbs62
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: 8bit

From ce3ef4533af53689a5693675867c22eb9504a4af Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 22 Mar 2022 05:51:42 -0400
Subject: [PATCH 1/5] finishing part1 b

---
 part1/mdb-lookup.c | 181 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 181 insertions(+)
 create mode 100644 part1/mdb-lookup.c

diff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c
new file mode 100644
index 0000000..a3b7532
--- /dev/null
+++ b/part1/mdb-lookup.c
@@ -0,0 +1,181 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include "mylist.h"
+#include "mdb.h"
+#include <string.h>
+
+
+
+void free_list(struct Node* head) {
+    if (!head) {
+        return;
+    }
+    else {
+        free_list(head->next);
+        free(head->data);
+        free(head);
+    }
+}
+
+
+void traverseList_looking_up(struct List *list, char * string) {
+
+    struct Node* cur = list->head;
+    int i = 1;
+    while (cur != NULL) {
+        struct MdbRec* d = cur-> data;
+
+        if (strstr(d->name, string) || strstr(d->msg, string)) {
+            printf("%3d {%s} said {%s}\n", i,d->name, d->msg);
+        }
+
+       // else{
+       //     printf("%s  \n", d->name);
+       // }
+        i++;
+        cur = cur->next;
+    }
+
+}
+
+
+int main( int argc, char** argv)
+{
+        
+
+    // printf("%s\n%s\n",argv[0], argv[1]);
+
+
+    // argv++;
+
+
+    if (argc != 2) {
+        fprintf(stderr, "%s\n", "usage:  mdb-lookup <file_name>");
+        exit(1);
+    }
+
+    char* filename = argv[1];
+    FILE* fp = fopen(filename, "r");
+
+    if (fp == NULL) {
+        perror(filename);
+        exit(1);
+    }
+
+
+    // initialize list
+    struct List list;
+    initList(&list);
+
+
+    struct Node* node = list.head;
+
+    struct MdbRec* record = malloc(40);
+
+
+    // size_t fread(void *p, size_t size, size_t n, FILE *file);
+    // char buffer[40];
+    while (fread(record, 40, 1, fp)) {
+
+        
+
+        node = addAfter(&list, node, record);
+
+        //printf("%s %s \n", record->name, record->msg);
+        //printf("%s %s \n", ((struct MdbRec*)(node->data))->name, ((struct MdbRec*)(node->data))->msg);
+    
+    
+        //struct MdbRec* record = malloc(40);
+        record = (struct MdbRec*) malloc(40);
+    }
+    free(record);
+
+
+/*    
+    struct MdbRec* record1 = malloc(40);
+   
+    fread(record1, 40, 1, fp);
+
+    struct Node* node1 = addAfter(&list, NULL, record1);
+
+    struct MdbRec* record2 = malloc(40);
+
+    fread(record2, 40, 1, fp);
+
+    struct Node* node2 = addAfter(&list, node1, record2);
+
+    printf("%s\n", (*(struct MdbRec *)(list.head->data)).name);
+
+*/
+
+/*    
+     node->data = (struct MdbRec*) malloc(40);
+
+    // size_t fread(void *p, size_t size, size_t n, FILE *file);
+    while (fread(node->data, 40, 1, fp)) {
+
+        node = addAfter(&list, node, (struct MdbRec*)malloc(40));
+
+        printf("%s %s \n", ((struct MdbRec*)(node->data))->name, ((struct MdbRec*)(node->data))->msg);
+        //printf("%s %s \n", ((struct MdbRec*)(node->data))->name, ((struct MdbRec*)(node->data))->msg);
+
+    }
+*/
+    fclose(fp);
+
+
+
+
+    // 
+    char buf[500];
+    printf("look up: ");
+    while (fgets(buf, 500, stdin) != NULL) {
+
+
+        //printf("%s %ld ", buf, strlen(buf));
+        if (strlen(buf) > 1) { // '\n' count len = 1
+            char keyword[6];
+            strncpy(keyword, buf, strlen(buf) - 1); // buf has last char '\n' before '\0' ('\0' is added by fgets)
+
+            
+            if ((strlen(buf) - 1) > 4) {
+                keyword[5] = '\0';
+            }
+            else {
+                keyword[strlen(buf)-1] = '\0';
+            }
+
+                printf("You are looking for %s, %ld, %ld\n", keyword, strlen(buf), strlen(keyword));
+
+
+                traverseList_looking_up(&list, keyword);
+                memset(keyword, 0, sizeof(keyword));
+        }
+        else {
+            traverseList_looking_up(&list, "");
+        }
+
+        // char buf[500];
+        // char keyword[6];
+        memset(buf, 0, sizeof(buf));
+        // memset(keyword, 0, sizeof(keyword));
+        printf("\nlook up: ");
+    }
+/*
+    
+    int i = 1;
+    struct Node *node11 = list.head;
+    while (node11 != NULL)  {
+        //struct MdbRec* d1 = node1->data;
+        //printf("[%3d] %s %s \n",i++, (char*)d1->name, (char*)d1->msg);
+        printf("[%3d] %s %s \n",i++,  ((struct MdbRec*)(node11->data))->name, ((struct MdbRec*)(node11->data))->msg);
+        
+
+        node11 = node11->next;
+    }
+*/
+
+    free_list(list.head);
+
+    return 0;
+}
-- 
2.17.1


From 0c782dcaaccc38b71877ea1dbfe43f6d9cabf9ff Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 22 Mar 2022 22:02:27 -0400
Subject: [PATCH 2/5] modified README

---
 README.txt | 86 +++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 85 insertions(+), 1 deletion(-)

diff --git a/README.txt b/README.txt
index 66dfd3e..5ce557a 100644
--- a/README.txt
+++ b/README.txt
@@ -8,4 +8,88 @@ This file should contain:
 The description should indicate whether your solution for the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
-implemented or how you tried to fix your non-working code.
+implemented or how you tried to fix your non-working code. 
+
+Yixuan Zou
+yz4004  
+lab4
+
+
+######################################
+
+part1 a):
+Records nserted: 
+229: {yixuan} said {My     OC OC [2~ OD OD }
+230: {yixua  n } said {Hello AP}
+
+
+######################################
+
+
+part1 b):
+
+yz4004@clac ~/cs3157/lab4/part1 $ valgrind --leak-check=yes ./mdb-lookup test_db
+==14087== Memcheck, a memory error detector
+==14087== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==14087== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
+==14087== Command: ./mdb-lookup test_db
+==14087==
+look up:
+   1: {yixuan zou} said {hello}
+   2: {uuu} said {he   OB OB hhhh sfesfe}
+   3: {AP} said {im ap}
+   4: {dfhjfhjssfsefjs} said {bbbbbbbbbbbbbbbbbbbbbbb}
+
+look up: ==14087==
+==14087== HEAP SUMMARY:
+==14087==     in use at exit: 0 bytes in 0 blocks
+==14087==   total heap usage: 13 allocs, 13 frees, 3,376 bytes allocated
+==14087==
+==14087== All heap blocks were freed -- no leaks are possible
+==14087==
+==14087== For counts of detected and suppressed errors, rerun with: -v
+==14087== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+yz4004@clac ~/cs3157/lab4/part1 $ make
+gcc -c  mdb-lookup.c -o  mdb-lookup.o -I../../lab3/solutions/part1
+gcc  mdb-lookup.o -o mdb-lookup  -lmylist -L../../lab3/solutions/part1
+yz4004@clac ~/cs3157/lab4/part1 $ valgrind --leak-check=yes ./mdb-lookup test_db
+==15744== Memcheck, a memory error detector
+==15744== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
+==15744== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
+==15744== Command: ./mdb-lookup test_db
+==15744==
+lookup:
+   1: {yixuan zou} said {hello}
+   2: {uuu} said {he   OB OB hhhh sfesfe}
+   3: {AP} said {im ap}
+   4: {dfhjfhjssfsefjs} said {bbbbbbbbbbbbbbbbbbbbbbb}
+
+lookup: ee
+
+lookup: yixuan
+   1: {yixuan zou} said {hello}
+
+lookup: hell
+   1: {yixuan zou} said {hello}
+
+lookup: iii
+
+lookup: uu
+   2: {uuu} said {he   OB OB hhhh sfesfe}
+
+lookup: b
+   4: {dfhjfhjssfsefjs} said {bbbbbbbbbbbbbbbbbbbbbbb}
+
+lookup: ==15744==
+==15744== HEAP SUMMARY:
+==15744==     in use at exit: 0 bytes in 0 blocks
+==15744==   total heap usage: 13 allocs, 13 frees, 3,376 bytes allocated
+==15744==
+==15744== All heap blocks were freed -- no leaks are possible
+==15744==
+==15744== For counts of detected and suppressed errors, rerun with: -v
+==15744== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
+yz4004@clac ~/cs3157/lab4/part1 $
+
+
+
-- 
2.17.1


From 814f51fdc63362765fc8a57c5f5cf01c4a1c7dcd Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 22 Mar 2022 22:03:35 -0400
Subject: [PATCH 3/5] modify some comments

---
 part1/mdb-lookup.c | 81 ++++------------------------------------------
 1 file changed, 6 insertions(+), 75 deletions(-)

diff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c
index a3b7532..5df61e9 100644
--- a/part1/mdb-lookup.c
+++ b/part1/mdb-lookup.c
@@ -26,12 +26,8 @@ void traverseList_looking_up(struct List *list, char * string) {
         struct MdbRec* d = cur-> data;
 
         if (strstr(d->name, string) || strstr(d->msg, string)) {
-            printf("%3d {%s} said {%s}\n", i,d->name, d->msg);
+            printf("%4d: {%s} said {%s}\n", i,d->name, d->msg);
         }
-
-       // else{
-       //     printf("%s  \n", d->name);
-       // }
         i++;
         cur = cur->next;
     }
@@ -74,61 +70,16 @@ int main( int argc, char** argv)
 
 
     // size_t fread(void *p, size_t size, size_t n, FILE *file);
-    // char buffer[40];
     while (fread(record, 40, 1, fp)) {
-
-        
-
         node = addAfter(&list, node, record);
-
-        //printf("%s %s \n", record->name, record->msg);
-        //printf("%s %s \n", ((struct MdbRec*)(node->data))->name, ((struct MdbRec*)(node->data))->msg);
-    
-    
-        //struct MdbRec* record = malloc(40);
         record = (struct MdbRec*) malloc(40);
     }
     free(record);
-
-
-/*    
-    struct MdbRec* record1 = malloc(40);
-   
-    fread(record1, 40, 1, fp);
-
-    struct Node* node1 = addAfter(&list, NULL, record1);
-
-    struct MdbRec* record2 = malloc(40);
-
-    fread(record2, 40, 1, fp);
-
-    struct Node* node2 = addAfter(&list, node1, record2);
-
-    printf("%s\n", (*(struct MdbRec *)(list.head->data)).name);
-
-*/
-
-/*    
-     node->data = (struct MdbRec*) malloc(40);
-
-    // size_t fread(void *p, size_t size, size_t n, FILE *file);
-    while (fread(node->data, 40, 1, fp)) {
-
-        node = addAfter(&list, node, (struct MdbRec*)malloc(40));
-
-        printf("%s %s \n", ((struct MdbRec*)(node->data))->name, ((struct MdbRec*)(node->data))->msg);
-        //printf("%s %s \n", ((struct MdbRec*)(node->data))->name, ((struct MdbRec*)(node->data))->msg);
-
-    }
-*/
     fclose(fp);
 
 
-
-
-    // 
     char buf[500];
-    printf("look up: ");
+    printf("lookup: ");
     while (fgets(buf, 500, stdin) != NULL) {
 
 
@@ -144,36 +95,16 @@ int main( int argc, char** argv)
             else {
                 keyword[strlen(buf)-1] = '\0';
             }
-
-                printf("You are looking for %s, %ld, %ld\n", keyword, strlen(buf), strlen(keyword));
-
-
-                traverseList_looking_up(&list, keyword);
-                memset(keyword, 0, sizeof(keyword));
+            //printf("You are looking for %s, %ld, %ld\n", keyword, strlen(buf), strlen(keyword));
+            traverseList_looking_up(&list, keyword);
+            memset(keyword, 0, sizeof(keyword));
         }
         else {
             traverseList_looking_up(&list, "");
         }
-
-        // char buf[500];
-        // char keyword[6];
         memset(buf, 0, sizeof(buf));
-        // memset(keyword, 0, sizeof(keyword));
-        printf("\nlook up: ");
-    }
-/*
-    
-    int i = 1;
-    struct Node *node11 = list.head;
-    while (node11 != NULL)  {
-        //struct MdbRec* d1 = node1->data;
-        //printf("[%3d] %s %s \n",i++, (char*)d1->name, (char*)d1->msg);
-        printf("[%3d] %s %s \n",i++,  ((struct MdbRec*)(node11->data))->name, ((struct MdbRec*)(node11->data))->msg);
-        
-
-        node11 = node11->next;
+        printf("\nlookup: ");
     }
-*/
 
     free_list(list.head);
 
-- 
2.17.1


From 827d68ca657c6d27e8d1dff49507207b361f6596 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 22 Mar 2022 22:05:51 -0400
Subject: [PATCH 4/5] delete some comments

---
 part1/mdb-lookup.c | 9 ---------
 1 file changed, 9 deletions(-)

diff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c
index 5df61e9..dcdd916 100644
--- a/part1/mdb-lookup.c
+++ b/part1/mdb-lookup.c
@@ -39,12 +39,6 @@ int main( int argc, char** argv)
 {
         
 
-    // printf("%s\n%s\n",argv[0], argv[1]);
-
-
-    // argv++;
-
-
     if (argc != 2) {
         fprintf(stderr, "%s\n", "usage:  mdb-lookup <file_name>");
         exit(1);
@@ -65,7 +59,6 @@ int main( int argc, char** argv)
 
 
     struct Node* node = list.head;
-
     struct MdbRec* record = malloc(40);
 
 
@@ -82,8 +75,6 @@ int main( int argc, char** argv)
     printf("lookup: ");
     while (fgets(buf, 500, stdin) != NULL) {
 
-
-        //printf("%s %ld ", buf, strlen(buf));
         if (strlen(buf) > 1) { // '\n' count len = 1
             char keyword[6];
             strncpy(keyword, buf, strlen(buf) - 1); // buf has last char '\n' before '\0' ('\0' is added by fgets)
-- 
2.17.1


From 3e090dd1ce07e0a61bd0f10f85266b8fe41ac609 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Tue, 22 Mar 2022 22:07:02 -0400
Subject: [PATCH 5/5] modify Makefile

---
 part1/Makefile | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)
 create mode 100644 part1/Makefile

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..a1b8ce4
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,23 @@
+CC  = gcc
+CXX = g++
+
+INCLUDES =
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+LDFLAGS = -g
+
+mdb-lookup:  mdb-lookup.o
+	gcc  mdb-lookup.o -o mdb-lookup  -lmylist -L../../lab3/solutions/part1
+
+mdb-lookup.o:  mdb-lookup.c 
+	gcc -c  mdb-lookup.c -o  mdb-lookup.o -I../../lab3/solutions/part1
+
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+.PHONY: all
+all: clean main
-- 
2.17.1


--+QahgC5+KEYLbs62
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab4.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom ce3ef4533af53689a5693675867c22eb9504a4af Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Tue, 22 Mar 2022 05:51:42 =
-0400=0ASubject: [PATCH 1/5] finishing part1 b=0A=0A---=0A part1/mdb-lookup=
=2Ec | 181 +++++++++++++++++++++++++++++++++++++++++++++=0A 1 file changed,=
 181 insertions(+)=0A create mode 100644 part1/mdb-lookup.c=0A=0Adiff --git=
 a/part1/mdb-lookup.c b/part1/mdb-lookup.c=0Anew file mode 100644=0Aindex 0=
000000..a3b7532=0A--- /dev/null=0A+++ b/part1/mdb-lookup.c=0A@@ -0,0 +1,181=
 @@=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include "mylist.h"=0A+=
#include "mdb.h"=0A+#include <string.h>=0A+=0A+=0A+=0A+void free_list(struc=
t Node* head) {=0A+    if (!head) {=0A+        return;=0A+    }=0A+    else=
 {=0A+        free_list(head->next);=0A+        free(head->data);=0A+      =
  free(head);=0A+    }=0A+}=0A+=0A+=0A+void traverseList_looking_up(struct =
List *list, char * string) {=0A+=0A+    struct Node* cur =3D list->head;=0A=
+    int i =3D 1;=0A+    while (cur !=3D NULL) {=0A+        struct MdbRec* =
d =3D cur-> data;=0A+=0A+        if (strstr(d->name, string) || strstr(d->m=
sg, string)) {=0A+            printf("%3d {%s} said {%s}\n", i,d->name, d->=
msg);=0A+        }=0A+=0A+       // else{=0A+       //     printf("%s =E8=
=BF=99=E4=B8=AA=E6=B2=A1=E6=9C=89=E5=8C=B9=E9=85=8D \n", d->name);=0A+     =
  // }=0A+        i++;=0A+        cur =3D cur->next;=0A+    }=0A+=0A+}=0A+=
=0A+=0A+int main( int argc, char** argv)=0A+{=0A+        =0A+=0A+    // pri=
ntf("%s\n%s\n",argv[0], argv[1]);=0A+=0A+=0A+    // argv++;=0A+=0A+=0A+    =
if (argc !=3D 2) {=0A+        fprintf(stderr, "%s\n", "usage:  mdb-lookup <=
file_name>");=0A+        exit(1);=0A+    }=0A+=0A+    char* filename =3D ar=
gv[1];=0A+    FILE* fp =3D fopen(filename, "r");=0A+=0A+    if (fp =3D=3D N=
ULL) {=0A+        perror(filename);=0A+        exit(1);=0A+    }=0A+=0A+=0A=
+    // initialize list=0A+    struct List list;=0A+    initList(&list);=0A=
+=0A+=0A+    struct Node* node =3D list.head;=0A+=0A+    struct MdbRec* rec=
ord =3D malloc(40);=0A+=0A+=0A+    // size_t fread(void *p, size_t size, si=
ze_t n, FILE *file);=0A+    // char buffer[40];=0A+    while (fread(record,=
 40, 1, fp)) {=0A+=0A+        =0A+=0A+        node =3D addAfter(&list, node=
, record);=0A+=0A+        //printf("%s %s \n", record->name, record->msg);=
=0A+        //printf("%s %s \n", ((struct MdbRec*)(node->data))->name, ((st=
ruct MdbRec*)(node->data))->msg);=0A+    =0A+    =0A+        //struct MdbRe=
c* record =3D malloc(40);=0A+        record =3D (struct MdbRec*) malloc(40)=
;=0A+    }=0A+    free(record);=0A+=0A+=0A+/*    =0A+    struct MdbRec* rec=
ord1 =3D malloc(40);=0A+   =0A+    fread(record1, 40, 1, fp);=0A+=0A+    st=
ruct Node* node1 =3D addAfter(&list, NULL, record1);=0A+=0A+    struct MdbR=
ec* record2 =3D malloc(40);=0A+=0A+    fread(record2, 40, 1, fp);=0A+=0A+  =
  struct Node* node2 =3D addAfter(&list, node1, record2);=0A+=0A+    printf=
("%s\n", (*(struct MdbRec *)(list.head->data)).name);=0A+=0A+*/=0A+=0A+/*  =
  =0A+     node->data =3D (struct MdbRec*) malloc(40);=0A+=0A+    // size_t=
 fread(void *p, size_t size, size_t n, FILE *file);=0A+    while (fread(nod=
e->data, 40, 1, fp)) {=0A+=0A+        node =3D addAfter(&list, node, (struc=
t MdbRec*)malloc(40));=0A+=0A+        printf("%s %s \n", ((struct MdbRec*)(=
node->data))->name, ((struct MdbRec*)(node->data))->msg);=0A+        //prin=
tf("%s %s \n", ((struct MdbRec*)(node->data))->name, ((struct MdbRec*)(node=
->data))->msg);=0A+=0A+    }=0A+*/=0A+    fclose(fp);=0A+=0A+=0A+=0A+=0A+  =
  // =E7=94=A8=E6=88=B7=E8=BE=93=E5=85=A5=0A+    char buf[500];=0A+    prin=
tf("look up: ");=0A+    while (fgets(buf, 500, stdin) !=3D NULL) {=0A+=0A+=
=0A+        //printf("%s %ld ", buf, strlen(buf));=0A+        if (strlen(bu=
f) > 1) { // '\n' count len =3D 1=0A+            char keyword[6];=0A+      =
      strncpy(keyword, buf, strlen(buf) - 1); // buf has last char '\n' bef=
ore '\0' ('\0' is added by fgets)=0A+=0A+            =0A+            if ((s=
trlen(buf) - 1) > 4) {=0A+                keyword[5] =3D '\0';=0A+         =
   }=0A+            else {=0A+                keyword[strlen(buf)-1] =3D '\=
0';=0A+            }=0A+=0A+                printf("You are looking for %s,=
 %ld, %ld\n", keyword, strlen(buf), strlen(keyword));=0A+=0A+=0A+          =
      traverseList_looking_up(&list, keyword);=0A+                memset(ke=
yword, 0, sizeof(keyword));=0A+        }=0A+        else {=0A+            t=
raverseList_looking_up(&list, "");=0A+        }=0A+=0A+        // char buf[=
500];=0A+        // char keyword[6];=0A+        memset(buf, 0, sizeof(buf))=
;=0A+        // memset(keyword, 0, sizeof(keyword));=0A+        printf("\nl=
ook up: ");=0A+    }=0A+/*=0A+    =0A+    int i =3D 1;=0A+    struct Node *=
node11 =3D list.head;=0A+    while (node11 !=3D NULL)  {=0A+        //struc=
t MdbRec* d1 =3D node1->data;=0A+        //printf("[%3d] %s %s \n",i++, (ch=
ar*)d1->name, (char*)d1->msg);=0A+        printf("[%3d] %s %s \n",i++,  ((s=
truct MdbRec*)(node11->data))->name, ((struct MdbRec*)(node11->data))->msg)=
;=0A+        =0A+=0A+        node11 =3D node11->next;=0A+    }=0A+*/=0A+=0A=
+    free_list(list.head);=0A+=0A+    return 0;=0A+}=0A-- =0A2.17.1=0A=0A=
=0AFrom 0c782dcaaccc38b71877ea1dbfe43f6d9cabf9ff Mon Sep 17 00:00:00 2001=
=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Tue, 22 Mar 2022 22:02:27=
 -0400=0ASubject: [PATCH 2/5] modified README=0A=0A---=0A README.txt | 86 +=
++++++++++++++++++++++++++++++++++++++++++++++++++++-=0A 1 file changed, 85=
 insertions(+), 1 deletion(-)=0A=0Adiff --git a/README.txt b/README.txt=0Ai=
ndex 66dfd3e..5ce557a 100644=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -8,=
4 +8,88 @@ This file should contain:=0A The description should indicate whe=
ther your solution for the part is=0A working or not.  You may also want to=
 include anything else you would=0A like to communicate to the grader such =
as extra functionalities you=0A-implemented or how you tried to fix your no=
n-working code.=0A+implemented or how you tried to fix your non-working cod=
e. =0A+=0A+Yixuan Zou=0A+yz4004  =0A+lab4=0A+=0A+=0A+######################=
################=0A+=0A+part1 a):=0A+Records nserted: =0A+229: {yixuan} sai=
d {My     OC OC [2~ OD OD }=0A+230: {yixua  n } said {Hello AP}=0A+=0A+=0A+=
######################################=0A+=0A+=0A+part1 b):=0A+=0A+yz4004@c=
lac ~/cs3157/lab4/part1 $ valgrind --leak-check=3Dyes ./mdb-lookup test_db=
=0A+=3D=3D14087=3D=3D Memcheck, a memory error detector=0A+=3D=3D14087=3D=
=3D Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.=0A+=3D=
=3D14087=3D=3D Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyrigh=
t info=0A+=3D=3D14087=3D=3D Command: ./mdb-lookup test_db=0A+=3D=3D14087=3D=
=3D=0A+look up:=0A+   1: {yixuan zou} said {hello}=0A+   2: {uuu} said {he =
  OB OB hhhh sfesfe}=0A+   3: {AP} said {im ap}=0A+   4: {dfhjfhjssfsefjs} =
said {bbbbbbbbbbbbbbbbbbbbbbb}=0A+=0A+look up: =3D=3D14087=3D=3D=0A+=3D=3D1=
4087=3D=3D HEAP SUMMARY:=0A+=3D=3D14087=3D=3D     in use at exit: 0 bytes i=
n 0 blocks=0A+=3D=3D14087=3D=3D   total heap usage: 13 allocs, 13 frees, 3,=
376 bytes allocated=0A+=3D=3D14087=3D=3D=0A+=3D=3D14087=3D=3D All heap bloc=
ks were freed -- no leaks are possible=0A+=3D=3D14087=3D=3D=0A+=3D=3D14087=
=3D=3D For counts of detected and suppressed errors, rerun with: -v=0A+=3D=
=3D14087=3D=3D ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from =
0)=0A+yz4004@clac ~/cs3157/lab4/part1 $ make=0A+gcc -c  mdb-lookup.c -o  md=
b-lookup.o -I../../lab3/solutions/part1=0A+gcc  mdb-lookup.o -o mdb-lookup =
 -lmylist -L../../lab3/solutions/part1=0A+yz4004@clac ~/cs3157/lab4/part1 $=
 valgrind --leak-check=3Dyes ./mdb-lookup test_db=0A+=3D=3D15744=3D=3D Memc=
heck, a memory error detector=0A+=3D=3D15744=3D=3D Copyright (C) 2002-2017,=
 and GNU GPL'd, by Julian Seward et al.=0A+=3D=3D15744=3D=3D Using Valgrind=
-3.13.0 and LibVEX; rerun with -h for copyright info=0A+=3D=3D15744=3D=3D C=
ommand: ./mdb-lookup test_db=0A+=3D=3D15744=3D=3D=0A+lookup:=0A+   1: {yixu=
an zou} said {hello}=0A+   2: {uuu} said {he   OB OB hhhh sfesfe}=0A+   3: =
{AP} said {im ap}=0A+   4: {dfhjfhjssfsefjs} said {bbbbbbbbbbbbbbbbbbbbbbb}=
=0A+=0A+lookup: ee=0A+=0A+lookup: yixuan=0A+   1: {yixuan zou} said {hello}=
=0A+=0A+lookup: hell=0A+   1: {yixuan zou} said {hello}=0A+=0A+lookup: iii=
=0A+=0A+lookup: uu=0A+   2: {uuu} said {he   OB OB hhhh sfesfe}=0A+=0A+look=
up: b=0A+   4: {dfhjfhjssfsefjs} said {bbbbbbbbbbbbbbbbbbbbbbb}=0A+=0A+look=
up: =3D=3D15744=3D=3D=0A+=3D=3D15744=3D=3D HEAP SUMMARY:=0A+=3D=3D15744=3D=
=3D     in use at exit: 0 bytes in 0 blocks=0A+=3D=3D15744=3D=3D   total he=
ap usage: 13 allocs, 13 frees, 3,376 bytes allocated=0A+=3D=3D15744=3D=3D=
=0A+=3D=3D15744=3D=3D All heap blocks were freed -- no leaks are possible=
=0A+=3D=3D15744=3D=3D=0A+=3D=3D15744=3D=3D For counts of detected and suppr=
essed errors, rerun with: -v=0A+=3D=3D15744=3D=3D ERROR SUMMARY: 0 errors f=
rom 0 contexts (suppressed: 0 from 0)=0A+yz4004@clac ~/cs3157/lab4/part1 $=
=0A+=0A+=0A+=0A-- =0A2.17.1=0A=0A=0AFrom 814f51fdc63362765fc8a57c5f5cf01c4a=
1c7dcd Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0A=
Date: Tue, 22 Mar 2022 22:03:35 -0400=0ASubject: [PATCH 3/5] modify some co=
mments=0A=0A---=0A part1/mdb-lookup.c | 81 ++++----------------------------=
--------------=0A 1 file changed, 6 insertions(+), 75 deletions(-)=0A=0Adif=
f --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c=0Aindex a3b7532..5df61e9 =
100644=0A--- a/part1/mdb-lookup.c=0A+++ b/part1/mdb-lookup.c=0A@@ -26,12 +2=
6,8 @@ void traverseList_looking_up(struct List *list, char * string) {=0A =
        struct MdbRec* d =3D cur-> data;=0A =0A         if (strstr(d->name,=
 string) || strstr(d->msg, string)) {=0A-            printf("%3d {%s} said =
{%s}\n", i,d->name, d->msg);=0A+            printf("%4d: {%s} said {%s}\n",=
 i,d->name, d->msg);=0A         }=0A-=0A-       // else{=0A-       //     p=
rintf("%s =E8=BF=99=E4=B8=AA=E6=B2=A1=E6=9C=89=E5=8C=B9=E9=85=8D \n", d->na=
me);=0A-       // }=0A         i++;=0A         cur =3D cur->next;=0A     }=
=0A@@ -74,61 +70,16 @@ int main( int argc, char** argv)=0A =0A =0A     // s=
ize_t fread(void *p, size_t size, size_t n, FILE *file);=0A-    // char buf=
fer[40];=0A     while (fread(record, 40, 1, fp)) {=0A-=0A-        =0A-=0A  =
       node =3D addAfter(&list, node, record);=0A-=0A-        //printf("%s =
%s \n", record->name, record->msg);=0A-        //printf("%s %s \n", ((struc=
t MdbRec*)(node->data))->name, ((struct MdbRec*)(node->data))->msg);=0A-   =
 =0A-    =0A-        //struct MdbRec* record =3D malloc(40);=0A         rec=
ord =3D (struct MdbRec*) malloc(40);=0A     }=0A     free(record);=0A-=0A-=
=0A-/*    =0A-    struct MdbRec* record1 =3D malloc(40);=0A-   =0A-    frea=
d(record1, 40, 1, fp);=0A-=0A-    struct Node* node1 =3D addAfter(&list, NU=
LL, record1);=0A-=0A-    struct MdbRec* record2 =3D malloc(40);=0A-=0A-    =
fread(record2, 40, 1, fp);=0A-=0A-    struct Node* node2 =3D addAfter(&list=
, node1, record2);=0A-=0A-    printf("%s\n", (*(struct MdbRec *)(list.head-=
>data)).name);=0A-=0A-*/=0A-=0A-/*    =0A-     node->data =3D (struct MdbRe=
c*) malloc(40);=0A-=0A-    // size_t fread(void *p, size_t size, size_t n, =
FILE *file);=0A-    while (fread(node->data, 40, 1, fp)) {=0A-=0A-        n=
ode =3D addAfter(&list, node, (struct MdbRec*)malloc(40));=0A-=0A-        p=
rintf("%s %s \n", ((struct MdbRec*)(node->data))->name, ((struct MdbRec*)(n=
ode->data))->msg);=0A-        //printf("%s %s \n", ((struct MdbRec*)(node->=
data))->name, ((struct MdbRec*)(node->data))->msg);=0A-=0A-    }=0A-*/=0A  =
   fclose(fp);=0A =0A =0A-=0A-=0A-    // =E7=94=A8=E6=88=B7=E8=BE=93=E5=85=
=A5=0A     char buf[500];=0A-    printf("look up: ");=0A+    printf("lookup=
: ");=0A     while (fgets(buf, 500, stdin) !=3D NULL) {=0A =0A =0A@@ -144,3=
6 +95,16 @@ int main( int argc, char** argv)=0A             else {=0A      =
           keyword[strlen(buf)-1] =3D '\0';=0A             }=0A-=0A-       =
         printf("You are looking for %s, %ld, %ld\n", keyword, strlen(buf),=
 strlen(keyword));=0A-=0A-=0A-                traverseList_looking_up(&list=
, keyword);=0A-                memset(keyword, 0, sizeof(keyword));=0A+    =
        //printf("You are looking for %s, %ld, %ld\n", keyword, strlen(buf)=
, strlen(keyword));=0A+            traverseList_looking_up(&list, keyword);=
=0A+            memset(keyword, 0, sizeof(keyword));=0A         }=0A       =
  else {=0A             traverseList_looking_up(&list, "");=0A         }=0A=
-=0A-        // char buf[500];=0A-        // char keyword[6];=0A         me=
mset(buf, 0, sizeof(buf));=0A-        // memset(keyword, 0, sizeof(keyword)=
);=0A-        printf("\nlook up: ");=0A-    }=0A-/*=0A-    =0A-    int i =
=3D 1;=0A-    struct Node *node11 =3D list.head;=0A-    while (node11 !=3D =
NULL)  {=0A-        //struct MdbRec* d1 =3D node1->data;=0A-        //print=
f("[%3d] %s %s \n",i++, (char*)d1->name, (char*)d1->msg);=0A-        printf=
("[%3d] %s %s \n",i++,  ((struct MdbRec*)(node11->data))->name, ((struct Md=
bRec*)(node11->data))->msg);=0A-        =0A-=0A-        node11 =3D node11->=
next;=0A+        printf("\nlookup: ");=0A     }=0A-*/=0A =0A     free_list(=
list.head);=0A =0A-- =0A2.17.1=0A=0A=0AFrom 827d68ca657c6d27e8d1dff49507207=
b361f6596 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=
=0ADate: Tue, 22 Mar 2022 22:05:51 -0400=0ASubject: [PATCH 4/5] delete some=
 comments=0A=0A---=0A part1/mdb-lookup.c | 9 ---------=0A 1 file changed, 9=
 deletions(-)=0A=0Adiff --git a/part1/mdb-lookup.c b/part1/mdb-lookup.c=0Ai=
ndex 5df61e9..dcdd916 100644=0A--- a/part1/mdb-lookup.c=0A+++ b/part1/mdb-l=
ookup.c=0A@@ -39,12 +39,6 @@ int main( int argc, char** argv)=0A {=0A      =
   =0A =0A-    // printf("%s\n%s\n",argv[0], argv[1]);=0A-=0A-=0A-    // ar=
gv++;=0A-=0A-=0A     if (argc !=3D 2) {=0A         fprintf(stderr, "%s\n", =
"usage:  mdb-lookup <file_name>");=0A         exit(1);=0A@@ -65,7 +59,6 @@ =
int main( int argc, char** argv)=0A =0A =0A     struct Node* node =3D list.=
head;=0A-=0A     struct MdbRec* record =3D malloc(40);=0A =0A =0A@@ -82,8 +=
75,6 @@ int main( int argc, char** argv)=0A     printf("lookup: ");=0A     =
while (fgets(buf, 500, stdin) !=3D NULL) {=0A =0A-=0A-        //printf("%s =
%ld ", buf, strlen(buf));=0A         if (strlen(buf) > 1) { // '\n' count l=
en =3D 1=0A             char keyword[6];=0A             strncpy(keyword, bu=
f, strlen(buf) - 1); // buf has last char '\n' before '\0' ('\0' is added b=
y fgets)=0A-- =0A2.17.1=0A=0A=0AFrom 3e090dd1ce07e0a61bd0f10f85266b8fe41ac6=
09 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate=
: Tue, 22 Mar 2022 22:07:02 -0400=0ASubject: [PATCH 5/5] modify Makefile=0A=
=0A---=0A part1/Makefile | 23 +++++++++++++++++++++++=0A 1 file changed, 23=
 insertions(+)=0A create mode 100644 part1/Makefile=0A=0Adiff --git a/part1=
/Makefile b/part1/Makefile=0Anew file mode 100644=0Aindex 0000000..a1b8ce4=
=0A--- /dev/null=0A+++ b/part1/Makefile=0A@@ -0,0 +1,23 @@=0A+CC  =3D gcc=
=0A+CXX =3D g++=0A+=0A+INCLUDES =3D=0A+=0A+CFLAGS   =3D -g -Wall $(INCLUDES=
)=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+LDFLAGS =3D -g=0A+=0A+mdb-loo=
kup:  mdb-lookup.o=0A+	gcc  mdb-lookup.o -o mdb-lookup  -lmylist -L../../la=
b3/solutions/part1=0A+=0A+mdb-lookup.o:  mdb-lookup.c =0A+	gcc -c  mdb-look=
up.c -o  mdb-lookup.o -I../../lab3/solutions/part1=0A+=0A+=0A+.PHONY: clean=
=0A+clean:=0A+	rm -f *.o a.out core main=0A+=0A+.PHONY: all=0A+all: clean m=
ain=0A-- =0A2.17.1=0A=0A
--+QahgC5+KEYLbs62--

From do.not.reply@cloud.cs.columbia.edu Mon Apr  4 09:25:39 2022
Date: Mon, 4 Apr 2022 09:25:39 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab5.mbox
Message-ID: <20220404132539.GA4684@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="ZGiS0Q5IWpPtfppv"
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 13323
Lines: 375


--ZGiS0Q5IWpPtfppv
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline

From 9654ad008a6f32143b687243c065f1aef9e95d15 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 4 Apr 2022 09:03:20 -0400
Subject: [PATCH 1/5] part1 a)

---
 part1/mdb-lookup-server-nc.sh | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)
 create mode 100755 part1/mdb-lookup-server-nc.sh

diff --git a/part1/mdb-lookup-server-nc.sh b/part1/mdb-lookup-server-nc.sh
new file mode 100755
index 0000000..2734c1a
--- /dev/null
+++ b/part1/mdb-lookup-server-nc.sh
@@ -0,0 +1,22 @@
+#!/bin/sh
+
+on_ctrl_c() {
+ echo "Ignoring Ctrl-C"
+ }
+ # Call on_ctrl_c() when the interrupt signal is received.
+ # The interrupt signal is sent when you press Ctrl-C.
+ trap on_ctrl_c INT
+
+
+pid=$1
+
+mkfifo mypipe-${pid}
+
+cat  mypipe-${pid}| nc -l ${pid} | ./mdb-lookup-cs3157 > mypipe-${pid}
+
+rm ./mypipe-${pid}
+
+
+
+
+
-- 
2.17.1


From 53bea0ead71e84d63fb64cb3b036dcc0577141aa Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 4 Apr 2022 09:04:16 -0400
Subject: [PATCH 2/5] part1 b)

---
 README.txt | 46 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 46 insertions(+)
 create mode 100644 README.txt

diff --git a/README.txt b/README.txt
new file mode 100644
index 0000000..c54440c
--- /dev/null
+++ b/README.txt
@@ -0,0 +1,46 @@
+
+
+yz4004 
+
+Yixuan Zou
+
+lab5
+
+
+
+## part1 b)  #################################################################################################################################################
+
+ 3805 27728 27728 27728 ?           -1 Ss       0   0:00  \_ sshd: yz4004 [priv]
+27728 27967 27728 27728 ?           -1 S     5782   0:00  |   \_ sshd: yz4004@pts/159
+27967 28108 28108 28108 pts/159  18299 Ss    5782   0:00  |       \_ -bash
+28108 18299 18299 28108 pts/159  18299 S+    5782   0:00  |           \_ ./mdb-lookup-server-nc-1 10782
+18299 18300 18299 28108 pts/159  18299 S+    5782   0:00  |               \_ /bin/sh ./mdb-lookup-server-nc.sh 10782
+18300 18302 18299 28108 pts/159  18299 S+    5782   0:00  |                   \_ cat mypipe-10782
+18300 18303 18299 28108 pts/159  18299 S+    5782   0:00  |                   \_ nc -l 10782
+18300 18304 18299 28108 pts/159  18299 S+    5782   0:00  |                   \_ /bin/sh ./mdb-lookup-cs3157
+18304 18305 18299 28108 pts/159  18299 S+    5782   0:00  |                       \_ /home/jae/cs3157-pub/bin/mdb-lookup /home/jae/cs3157-pub/bin/mdb-cs3157
+
+my script: mdb-lookup-server-nc.sh
+
+
+
+
+## part1 c)  #################################################################################################################################################
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
-- 
2.17.1


From f9c6a774e8c98d70ab002969b7cac347a24070ec Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 4 Apr 2022 09:04:39 -0400
Subject: [PATCH 3/5] part1 c) Makefile

---
 part1/Makefile | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)
 create mode 100644 part1/Makefile

diff --git a/part1/Makefile b/part1/Makefile
new file mode 100644
index 0000000..62b2e5e
--- /dev/null
+++ b/part1/Makefile
@@ -0,0 +1,23 @@
+CC  = gcc
+CXX = g++
+
+INCLUDES =
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+LDFLAGS = -g
+
+mdb-lookup-server-nc-2:  mdb-lookup-server-nc-2.o
+	gcc  mdb-lookup-server-nc-2.o -o mdb-lookup-server-nc-2  
+
+mdb-lookup-server-nc-2.o:  mdb-lookup-server-nc-2.c 
+	gcc -c  mdb-lookup-server-nc-2.c -o  mdb-lookup-server-nc-2.o 
+
+
+.PHONY: clean
+clean:
+	rm -f *.o a.out core main
+
+.PHONY: all
+all: clean main
-- 
2.17.1


From 751f49b9895b0db960b528af271f2143e7c96c98 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 4 Apr 2022 09:05:22 -0400
Subject: [PATCH 4/5] part1 c)

---
 part1/mdb-lookup-server-nc-2.c | 72 ++++++++++++++++++++++++++++++++++
 1 file changed, 72 insertions(+)
 create mode 100644 part1/mdb-lookup-server-nc-2.c

diff --git a/part1/mdb-lookup-server-nc-2.c b/part1/mdb-lookup-server-nc-2.c
new file mode 100644
index 0000000..39d18de
--- /dev/null
+++ b/part1/mdb-lookup-server-nc-2.c
@@ -0,0 +1,72 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+static void die(const char* s) {
+	perror(s);
+	exit(1);
+}
+
+
+int main() {
+
+	char buf[100];
+	pid_t pid;
+	
+	pid_t parent_pid;
+
+	printf("port number: ");
+
+	while (fgets(buf, sizeof(buf), stdin) != NULL ) {
+
+
+		
+		if (buf[0] == '\n') {
+			// press enter, parent process goes into waitpid
+			
+			pid_t pid = waitpid((pid_t)-1, NULL, WNOHANG);
+			if (pid > 0) {
+				// -1 if no child has exited. on success, pid is finished child pid
+				printf("[pid=%d] mdb-lookup-server terminated\n", (int)pid); // return the finished child's pid
+			}
+
+		}
+		else {
+
+			if (buf[strlen(buf) - 1] == '\n') {
+				buf[strlen(buf) - 1] = 0;
+			}
+			int port_number = atoi(buf);
+
+			parent_pid = getpid();
+
+			pid = fork();
+
+			if (pid < 0) {
+				die("fork failed");
+			}
+			else if (pid == 0) {
+				// child process
+				execl("./mdb-lookup-server-nc.sh", "mdb-lookup-server-nc.sh", buf , (char*)0);
+				die("execl failed");
+
+			}
+			else {
+				// parent process
+				printf("port number: [pid=%d] mdb-lookup-server started on port %d\n\n",(int) pid, port_number  );
+                                memset(buf, 0, sizeof(buf));
+			}
+		}
+              
+                memset(buf, 0, sizeof(buf));
+		printf("port number: ");
+	}
+
+
+	return 0;
+}
+
+
-- 
2.17.1


From 55281e817f2ff09018104cacee86b92e34066806 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 4 Apr 2022 09:24:47 -0400
Subject: [PATCH 5/5] modify readme

---
 README.txt | 7 -------
 1 file changed, 7 deletions(-)

diff --git a/README.txt b/README.txt
index c54440c..6423996 100644
--- a/README.txt
+++ b/README.txt
@@ -25,13 +25,6 @@ my script: mdb-lookup-server-nc.sh
 
 
 
-## part1 c)  #################################################################################################################################################
-
-
-
-
-
-
 
 
 
-- 
2.17.1


--ZGiS0Q5IWpPtfppv
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab5.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 9654ad008a6f32143b687243c065f1aef9e95d15 Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Mon, 4 Apr 2022 09:03:20 -=
0400=0ASubject: [PATCH 1/5] part1 a)=0A=0A---=0A part1/mdb-lookup-server-nc=
=2Esh | 22 ++++++++++++++++++++++=0A 1 file changed, 22 insertions(+)=0A cr=
eate mode 100755 part1/mdb-lookup-server-nc.sh=0A=0Adiff --git a/part1/mdb-=
lookup-server-nc.sh b/part1/mdb-lookup-server-nc.sh=0Anew file mode 100755=
=0Aindex 0000000..2734c1a=0A--- /dev/null=0A+++ b/part1/mdb-lookup-server-n=
c.sh=0A@@ -0,0 +1,22 @@=0A+#!/bin/sh=0A+=0A+on_ctrl_c() {=0A+ echo "Ignorin=
g Ctrl-C"=0A+ }=0A+ # Call on_ctrl_c() when the interrupt signal is receive=
d.=0A+ # The interrupt signal is sent when you press Ctrl-C.=0A+ trap on_ct=
rl_c INT=0A+=0A+=0A+pid=3D$1=0A+=0A+mkfifo mypipe-${pid}=0A+=0A+cat  mypipe=
-${pid}| nc -l ${pid} | ./mdb-lookup-cs3157 > mypipe-${pid}=0A+=0A+rm ./myp=
ipe-${pid}=0A+=0A+=0A+=0A+=0A+=0A-- =0A2.17.1=0A=0A=0AFrom 53bea0ead71e84d6=
3fb64cb3b036dcc0577141aa Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz400=
4@columbia.edu>=0ADate: Mon, 4 Apr 2022 09:04:16 -0400=0ASubject: [PATCH 2/=
5] part1 b)=0A=0A---=0A README.txt | 46 +++++++++++++++++++++++++++++++++++=
+++++++++++=0A 1 file changed, 46 insertions(+)=0A create mode 100644 READM=
E.txt=0A=0Adiff --git a/README.txt b/README.txt=0Anew file mode 100644=0Ain=
dex 0000000..c54440c=0A--- /dev/null=0A+++ b/README.txt=0A@@ -0,0 +1,46 @@=
=0A+=0A+=0A+yz4004 =0A+=0A+Yixuan Zou=0A+=0A+lab5=0A+=0A+=0A+=0A+## part1 b=
)  ########################################################################=
#########################################################################=
=0A+=0A+ 3805 27728 27728 27728 ?           -1 Ss       0   0:00  \_ sshd: =
yz4004 [priv]=0A+27728 27967 27728 27728 ?           -1 S     5782   0:00  =
|   \_ sshd: yz4004@pts/159=0A+27967 28108 28108 28108 pts/159  18299 Ss   =
 5782   0:00  |       \_ -bash=0A+28108 18299 18299 28108 pts/159  18299 S+=
    5782   0:00  |           \_ ./mdb-lookup-server-nc-1 10782=0A+18299 183=
00 18299 28108 pts/159  18299 S+    5782   0:00  |               \_ /bin/sh=
 ./mdb-lookup-server-nc.sh 10782=0A+18300 18302 18299 28108 pts/159  18299 =
S+    5782   0:00  |                   \_ cat mypipe-10782=0A+18300 18303 1=
8299 28108 pts/159  18299 S+    5782   0:00  |                   \_ nc -l 1=
0782=0A+18300 18304 18299 28108 pts/159  18299 S+    5782   0:00  |        =
           \_ /bin/sh ./mdb-lookup-cs3157=0A+18304 18305 18299 28108 pts/15=
9  18299 S+    5782   0:00  |                       \_ /home/jae/cs3157-pub=
/bin/mdb-lookup /home/jae/cs3157-pub/bin/mdb-cs3157=0A+=0A+my script: mdb-l=
ookup-server-nc.sh=0A+=0A+=0A+=0A+=0A+## part1 c)  ########################=
###########################################################################=
##############################################=0A+=0A+=0A+=0A+=0A+=0A+=0A+=
=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A-- =0A2.17.1=0A=0A=0AFrom f9=
c6a774e8c98d70ab002969b7cac347a24070ec Mon Sep 17 00:00:00 2001=0AFrom: Yix=
uan_Zou <yz4004@columbia.edu>=0ADate: Mon, 4 Apr 2022 09:04:39 -0400=0ASubj=
ect: [PATCH 3/5] part1 c) Makefile=0A=0A---=0A part1/Makefile | 23 ++++++++=
+++++++++++++++=0A 1 file changed, 23 insertions(+)=0A create mode 100644 p=
art1/Makefile=0A=0Adiff --git a/part1/Makefile b/part1/Makefile=0Anew file =
mode 100644=0Aindex 0000000..62b2e5e=0A--- /dev/null=0A+++ b/part1/Makefile=
=0A@@ -0,0 +1,23 @@=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+INCLUDES =3D=0A+=
=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=
=0A+=0A+LDFLAGS =3D -g=0A+=0A+mdb-lookup-server-nc-2:  mdb-lookup-server-nc=
-2.o=0A+	gcc  mdb-lookup-server-nc-2.o -o mdb-lookup-server-nc-2  =0A+=0A+m=
db-lookup-server-nc-2.o:  mdb-lookup-server-nc-2.c =0A+	gcc -c  mdb-lookup-=
server-nc-2.c -o  mdb-lookup-server-nc-2.o =0A+=0A+=0A+.PHONY: clean=0A+cle=
an:=0A+	rm -f *.o a.out core main=0A+=0A+.PHONY: all=0A+all: clean main=0A-=
- =0A2.17.1=0A=0A=0AFrom 751f49b9895b0db960b528af271f2143e7c96c98 Mon Sep 1=
7 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Mon, 4 Apr=
 2022 09:05:22 -0400=0ASubject: [PATCH 4/5] part1 c)=0A=0A---=0A part1/mdb-=
lookup-server-nc-2.c | 72 ++++++++++++++++++++++++++++++++++=0A 1 file chan=
ged, 72 insertions(+)=0A create mode 100644 part1/mdb-lookup-server-nc-2.c=
=0A=0Adiff --git a/part1/mdb-lookup-server-nc-2.c b/part1/mdb-lookup-server=
-nc-2.c=0Anew file mode 100644=0Aindex 0000000..39d18de=0A--- /dev/null=0A+=
++ b/part1/mdb-lookup-server-nc-2.c=0A@@ -0,0 +1,72 @@=0A+#include <stdio.h=
>=0A+#include <stdlib.h>=0A+#include <string.h>=0A+#include <sys/wait.h>=0A=
+#include <sys/types.h>=0A+#include <unistd.h>=0A+=0A+static void die(const=
 char* s) {=0A+	perror(s);=0A+	exit(1);=0A+}=0A+=0A+=0A+int main() {=0A+=0A=
+	char buf[100];=0A+	pid_t pid;=0A+	=0A+	pid_t parent_pid;=0A+=0A+	printf("=
port number: ");=0A+=0A+	while (fgets(buf, sizeof(buf), stdin) !=3D NULL ) =
{=0A+=0A+=0A+		=0A+		if (buf[0] =3D=3D '\n') {=0A+			// press enter, parent=
 process goes into waitpid=0A+			=0A+			pid_t pid =3D waitpid((pid_t)-1, NU=
LL, WNOHANG);=0A+			if (pid > 0) {=0A+				// -1 if no child has exited. on =
success, pid is finished child pid=0A+				printf("[pid=3D%d] mdb-lookup-ser=
ver terminated\n", (int)pid); // return the finished child's pid=0A+			}=0A=
+=0A+		}=0A+		else {=0A+=0A+			if (buf[strlen(buf) - 1] =3D=3D '\n') {=0A+	=
			buf[strlen(buf) - 1] =3D 0;=0A+			}=0A+			int port_number =3D atoi(buf);=
=0A+=0A+			parent_pid =3D getpid();=0A+=0A+			pid =3D fork();=0A+=0A+			if =
(pid < 0) {=0A+				die("fork failed");=0A+			}=0A+			else if (pid =3D=3D 0)=
 {=0A+				// child process=0A+				execl("./mdb-lookup-server-nc.sh", "mdb-l=
ookup-server-nc.sh", buf , (char*)0);=0A+				die("execl failed");=0A+=0A+		=
	}=0A+			else {=0A+				// parent process=0A+				printf("port number: [pid=
=3D%d] mdb-lookup-server started on port %d\n\n",(int) pid, port_number  );=
=0A+                                memset(buf, 0, sizeof(buf));=0A+			}=0A=
+		}=0A+              =0A+                memset(buf, 0, sizeof(buf));=0A+	=
	printf("port number: ");=0A+	}=0A+=0A+=0A+	return 0;=0A+}=0A+=0A+=0A-- =0A=
2.17.1=0A=0A=0AFrom 55281e817f2ff09018104cacee86b92e34066806 Mon Sep 17 00:=
00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Mon, 4 Apr 2022=
 09:24:47 -0400=0ASubject: [PATCH 5/5] modify readme=0A=0A---=0A README.txt=
 | 7 -------=0A 1 file changed, 7 deletions(-)=0A=0Adiff --git a/README.txt=
 b/README.txt=0Aindex c54440c..6423996 100644=0A--- a/README.txt=0A+++ b/RE=
ADME.txt=0A@@ -25,13 +25,6 @@ my script: mdb-lookup-server-nc.sh=0A =0A =0A=
 =0A-## part1 c)  #########################################################=
###########################################################################=
#############=0A-=0A-=0A-=0A-=0A-=0A-=0A =0A =0A =0A-- =0A2.17.1=0A=0A
--ZGiS0Q5IWpPtfppv--

From do.not.reply@cloud.cs.columbia.edu Mon Apr 25 22:25:14 2022
Date: Mon, 25 Apr 2022 22:25:14 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab6.mbox
Message-ID: <20220426022514.GA27675@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="PNTmBPCT7hxwcZjr"
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 38948
Lines: 999


--PNTmBPCT7hxwcZjr
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: 8bit

From 64e44df168e101c502800e7d1b67fc2fffb5ecf5 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 25 Apr 2022 06:05:41 -0400
Subject: [PATCH 1/6] part1

---
 part1/mdb-lookup-server.c | 229 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 229 insertions(+)
 create mode 100644 part1/mdb-lookup-server.c

diff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-server.c
new file mode 100644
index 0000000..0df6051
--- /dev/null
+++ b/part1/mdb-lookup-server.c
@@ -0,0 +1,229 @@
+/*
+ * 
+ */
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <unistd.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+#include <arpa/inet.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "mylist.h"
+#include "mdb.h"
+
+#define KeyMax 5
+
+
+
+
+
+int loadmdb(FILE *fp, struct List *dest) 
+{
+    /*
+     * read all records into memory
+     */
+
+    struct MdbRec r;
+    struct Node *node = NULL;
+    int count = 0;
+
+    while (fread(&r, sizeof(r), 1, fp) == 1) {
+
+        // allocate memory for a new record and copy into it the one
+        // that was just read from the database.
+        struct MdbRec *rec = (struct MdbRec *)malloc(sizeof(r));
+        if (!rec)
+            return -1;
+        memcpy(rec, &r, sizeof(r));
+
+        // add the record to the linked list.
+        node = addAfter(dest, node, rec);
+        if (node == NULL) 
+            return -1;
+
+        count++;
+    }
+
+    // see if fread() produced error
+    if (ferror(fp)) 
+        return -1;
+
+    return count;
+}
+
+void freemdb(struct List *list) 
+{
+    // free all the records
+    traverseList(list, &free);
+    removeAllNodes(list);
+}
+
+
+
+static void die(const char *s) { perror(s); exit(1); }
+
+int main(int argc, char **argv)
+{
+    // ignore SIGPIPE so that we dont terminate when we call
+    // send() on a disconnected socket.
+    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) 
+    die("signal() failed");
+
+
+    if (argc != 3) {
+        fprintf(stderr, "usage: %s <server-port>\n", argv[0]);
+        exit(1);
+    }
+
+
+
+    // db part
+    // ---------------------------------------------------------------------------------
+
+    char *filename = argv[1];
+    FILE *fp = fopen(filename,"rb");
+    if (fp == NULL) 
+        die(filename);
+
+    struct List list;
+    initList(&list);
+
+    int loaded = loadmdb(fp, &list);
+    if (loaded < 0)
+        die("loadmdb");
+    
+    fclose(fp);
+    // ---------------------------------------------------------------------------------
+
+
+
+
+    // socket part
+    // ---------------------------------------------------------------------------------
+    unsigned short port = atoi(argv[2]);
+
+    int servsock;
+    if ((servsock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
+        die("socket failed");
+
+    struct sockaddr_in servaddr;
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family = AF_INET;
+    servaddr.sin_addr.s_addr = htonl(INADDR_ANY); // any network interface
+    servaddr.sin_port = htons(port);
+
+
+    if (bind(servsock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
+        die("bind failed");
+
+    if (listen(servsock, 5 /* queue size for connection requests */ ) < 0)
+        die("listen failed");
+
+    // int r;
+    // char buf[10];
+
+    int clntsock;
+    socklen_t clntlen;
+    struct sockaddr_in clntaddr;
+    // ---------------------------------------------------------------------------------
+
+    while (1) {
+
+        // Accept an incoming connection
+
+        fprintf(stderr, "waiting for client ... ");
+
+        clntlen = sizeof(clntaddr); // initialize the in-out parameter
+
+        if ((clntsock = accept(servsock,
+                        (struct sockaddr *) &clntaddr, &clntlen)) < 0)
+            die("accept failed");
+
+        // accept() returned a connected socket (also called client socket)
+        // and filled in the client's address into clntaddr
+
+        fprintf(stderr, "client ip: %s\n", inet_ntoa(clntaddr.sin_addr));
+
+
+
+        // ##############
+        FILE *input = fdopen(clntsock, "r" );
+        
+        char line[1000];
+        char key[KeyMax + 1];
+
+        int r;
+
+        // recv()
+        while ( fgets(line, sizeof(line), input) != NULL) {
+            
+
+            // must null-terminate the string manually after strncpy().
+            strncpy(key, line, sizeof(key) - 1);
+            key[sizeof(key) - 1] = '\0';
+
+            // if newline is there, remove it.
+            size_t last = strlen(key) - 1;
+            if (key[last] == '\n')
+                key[last] = '\0';
+
+            // traverse the list, printing out the matching records
+            struct Node* node = list.head;
+            int recNo = 1;
+            while (node) {
+                struct MdbRec* rec = (struct MdbRec*)node->data;
+                if (strstr(rec->name, key) || strstr(rec->msg, key)) {
+                    //printf("%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg);
+
+                    
+                    char output_record[50];
+                    if((r = snprintf(output_record, 50, "%4d: {%s} said {%s}\n", recNo, rec->name, rec->msg)) == 0){
+                        die("snprintf");
+                    }
+                    if(send(clntsock, output_record, r, 0) != r){     
+                       fprintf(stderr, "ERR: send failed\n");
+                       break;
+                    }
+                   
+
+                }
+                node = node->next;
+                recNo++;
+            }
+
+            // printf("\nlookup: ");
+            // fflush(stdout);
+            char blankline[1];
+            *blankline = '\n';
+            if (send(clntsock, blankline, 1, 0) != 1){
+                fprintf(stderr, "ERR: send blank line failed\n");
+                }
+
+        // see if fgets() produced error
+        if (ferror(input))
+            die("input");
+
+        }
+
+    
+        // #################################
+        freemdb(&list);
+    
+        fclose(input);
+
+        close(clntsock);
+     }    
+
+
+     return 0;
+}
-- 
2.17.1


From 0934e14eec93e58770a6b6a17c066829ad69b202 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 25 Apr 2022 06:21:24 -0400
Subject: [PATCH 2/6] modify part1

---
 part1/mdb-lookup-server.c | 14 ++++++--------
 1 file changed, 6 insertions(+), 8 deletions(-)

diff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-server.c
index 0df6051..25acf39 100644
--- a/part1/mdb-lookup-server.c
+++ b/part1/mdb-lookup-server.c
@@ -209,21 +209,19 @@ int main(int argc, char **argv)
                 fprintf(stderr, "ERR: send blank line failed\n");
                 }
 
-        // see if fgets() produced error
-        if (ferror(input))
-            die("input");
+            // see if fgets() produced error
+            if (ferror(input))
+                die("input");
 
         }
 
-    
-        // #################################
-        freemdb(&list);
-    
         fclose(input);
-
+    
         close(clntsock);
+        // #################################
      }    
 
 
+     freemdb(&list);
      return 0;
 }
-- 
2.17.1


From 3ca0284987ab9efb691f0fd92a379a28b7ccbe3c Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 25 Apr 2022 06:38:31 -0400
Subject: [PATCH 3/6] modify part1 again

---
 part1/mdb-lookup-server.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/part1/mdb-lookup-server.c b/part1/mdb-lookup-server.c
index 25acf39..6eacf73 100644
--- a/part1/mdb-lookup-server.c
+++ b/part1/mdb-lookup-server.c
@@ -1,5 +1,5 @@
 /*
- * 
+ *  mdb-lookup-server.c 
  */
 
 #include <ctype.h>
@@ -106,6 +106,7 @@ int main(int argc, char **argv)
     // ---------------------------------------------------------------------------------
 
 
+    fprintf(stderr, "\n");
 
 
     // socket part
@@ -141,7 +142,7 @@ int main(int argc, char **argv)
 
         // Accept an incoming connection
 
-        fprintf(stderr, "waiting for client ... ");
+        // fprintf(stderr, "waiting for client ... ");
 
         clntlen = sizeof(clntaddr); // initialize the in-out parameter
 
@@ -152,8 +153,9 @@ int main(int argc, char **argv)
         // accept() returned a connected socket (also called client socket)
         // and filled in the client's address into clntaddr
 
-        fprintf(stderr, "client ip: %s\n", inet_ntoa(clntaddr.sin_addr));
+        //fprintf(stderr, "client ip: %s\n", inet_ntoa(clntaddr.sin_addr));
 
+        fprintf(stderr, "connection started from: %s\n", inet_ntoa(clntaddr.sin_addr));
 
 
         // ##############
-- 
2.17.1


From ecc457685b0d77f41ecf1f1e7ee8225574124bed Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 25 Apr 2022 17:41:01 -0400
Subject: [PATCH 4/6] part2

---
 part2/Makefile      |  28 +++++++
 part2/http-client.c | 198 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 226 insertions(+)
 create mode 100644 part2/Makefile
 create mode 100644 part2/http-client.c

diff --git a/part2/Makefile b/part2/Makefile
new file mode 100644
index 0000000..b4cd0c0
--- /dev/null
+++ b/part2/Makefile
@@ -0,0 +1,28 @@
+
+#
+# Makefile for lab 6, part 1
+#
+
+CC  = gcc
+CXX = g++
+
+CFLAGS   = -g -Wall $(INCLUDES)
+CXXFLAGS = -g -Wall $(INCLUDES)
+
+
+.PHONY: default
+default: http-client 
+
+# header dependency
+## mdb-lookup-server.o: mdb.h
+
+
+
+.PHONY: clean
+clean:
+	rm -f *.o *~ a.out core http-client
+
+.PHONY: all
+all: clean default
+
+
diff --git a/part2/http-client.c b/part2/http-client.c
new file mode 100644
index 0000000..659b09a
--- /dev/null
+++ b/part2/http-client.c
@@ -0,0 +1,198 @@
+/*
+ *  mdb-lookup-server.c 
+ */
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <unistd.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+#include <arpa/inet.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <netdb.h>
+
+
+
+static void die(const char *s) { perror(s); exit(1); }
+
+int main(int argc, char **argv)
+{
+    // ignore SIGPIPE so that we dont terminate when we call
+    // send() on a disconnected socket.
+    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) 
+    die("signal() failed");
+
+
+    if (argc != 4) {
+        fprintf(stderr, "usage: %s <server-port>\n", argv[0]);
+        exit(1);
+    }
+
+        
+
+    // 
+    // ---------------------------------------------------------------------------------
+        
+    struct hostent *he;
+    char *serverName = argv[1];
+    // get server ip from server name
+    if ((he = gethostbyname(serverName)) == NULL) {
+        die("gethostbyname failed");
+    }
+    
+    char *serverIP = inet_ntoa(*(struct in_addr *)he->h_addr);
+        
+    unsigned short port = atoi(argv[2]);
+
+    char *path = argv[3];
+
+
+    // strchr
+    const char backslash = '/';
+    char *filename = argv[3] ;
+
+    while((path = strchr(filename, backslash)) != NULL ){
+        
+        //printf("path: %s\n", path);
+        path++;
+        filename = path;
+    }
+
+    path = argv[3]; // ?
+
+    printf("host ip: %s, host name: %s, port: %d, filename: %s \n",serverIP, serverName, port, filename);    
+
+
+
+    // ---------------------------------------------------------------------------------
+
+
+    // Create a socket for TCP connection
+
+    int sock; // socket descriptor
+    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
+        die("socket failed");
+
+    // Construct a server address structure
+
+    struct sockaddr_in servaddr;
+    memset(&servaddr, 0, sizeof(servaddr)); // must zero out the structure
+    servaddr.sin_family      = AF_INET;
+    servaddr.sin_addr.s_addr = inet_addr(serverIP);
+    servaddr.sin_port        = htons(port); // must be in network byte order
+
+    // Establish a TCP connection to the server
+
+    if (connect(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
+        die("connect failed");
+
+    /*
+    char buf[1000];
+    if(recv(sock, buf, sizeof(buf),0 ) > 0){
+        printf("RECEIVE:\n%s", buf);
+    }*/
+
+
+    // ---------------------------------------------------------------------------------
+
+    char request_line[1000]  = "GET ";
+    strcat(request_line, path);
+    strcat(request_line, " HTTP/1.0\r\n");
+
+
+    // Host: the.host.name.you.are.connecting.to:<port_number>
+
+    strcat(request_line, "Host: ");
+    strcat(request_line, serverName);
+    strcat(request_line, ":");
+
+    char num[100];
+    snprintf(num, 100,  "%d", port);
+
+    strcat(request_line, num);
+    strcat(request_line, "\r\n\r\n");
+
+    printf("request:\n%s\n", request_line);    
+    fflush(stdout);
+
+
+    //send()
+    // ---------------------------------------------------------------------------------
+    int len = strlen(request_line);
+    if (send(sock, request_line, len, 0) != len)
+        die("send failed");
+
+
+    // printf("#######");
+    // fflush(stdout);
+
+    /*
+    char buf1[1000];
+    if(recv(sock, buf1, sizeof(buf1),0 ) > 0){
+        printf("RECEIVE:\n%s", buf1);
+    }*/
+
+
+
+    // receive
+    // ---------------------------------------------------------------------------------
+    FILE *fp_sock = fdopen(sock, "r" );
+    char line[1000];
+    // fgets headers
+    if(fgets(line, sizeof(line), fp_sock) != NULL){
+       if ( strstr(line, "200")){
+           printf("successful:\n%s", line);
+       }else{
+           printf("%s", line);
+           close(sock);
+           exit(1);
+       } 
+    }
+    // if 200, then proceed
+    while (fgets(line, sizeof(line), fp_sock ) != NULL ){
+
+        printf("%s", line);
+
+        if(strncmp(line, "\r\n", 2) ){     //line == "\r\n"
+            break;
+        }
+    }
+
+
+    // fread content
+    FILE *fp = fopen(filename, "w+");
+    char buf[4096];
+    if(fp ==0){
+        die("cannot write into");
+    }
+
+    int n;
+    while( (n = fread(buf, 1, sizeof(buf), fp_sock)) > 0){
+
+          if(fwrite(buf, sizeof(buf), 1, fp) < 1){
+              die("fwrite fails");
+          }
+
+    }
+
+    fclose(fp);
+
+
+    // ---------------------------------------------------------------------------------
+
+    fclose(fp_sock);
+    
+    close(sock);
+
+
+    return 0;
+}
-- 
2.17.1


From 3ce92d37a1e802be29e2fe8f5783ffabd73b6148 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 25 Apr 2022 22:17:29 -0400
Subject: [PATCH 5/6] remove comment

---
 part2/http-client.c | 20 ++++++++++++++------
 1 file changed, 14 insertions(+), 6 deletions(-)

diff --git a/part2/http-client.c b/part2/http-client.c
index 659b09a..dd0d0a9 100644
--- a/part2/http-client.c
+++ b/part2/http-client.c
@@ -69,7 +69,7 @@ int main(int argc, char **argv)
 
     path = argv[3]; // ?
 
-    printf("host ip: %s, host name: %s, port: %d, filename: %s \n",serverIP, serverName, port, filename);    
+    //printf("host ip: %s, host name: %s, port: %d, filename: %s \n",serverIP, serverName, port, filename);    
 
 
 
@@ -121,8 +121,8 @@ int main(int argc, char **argv)
     strcat(request_line, num);
     strcat(request_line, "\r\n\r\n");
 
-    printf("request:\n%s\n", request_line);    
-    fflush(stdout);
+    //printf("request:\n%s\n", request_line);    
+    //fflush(stdout);
 
 
     //send()
@@ -150,7 +150,7 @@ int main(int argc, char **argv)
     // fgets headers
     if(fgets(line, sizeof(line), fp_sock) != NULL){
        if ( strstr(line, "200")){
-           printf("successful:\n%s", line);
+           // printf("successful:\n%s", line);
        }else{
            printf("%s", line);
            close(sock);
@@ -160,9 +160,9 @@ int main(int argc, char **argv)
     // if 200, then proceed
     while (fgets(line, sizeof(line), fp_sock ) != NULL ){
 
-        printf("%s", line);
+         //printf("%s", line);
 
-        if(strncmp(line, "\r\n", 2) ){     //line == "\r\n"
+        if((line[0] == '\r') &&( line[1] == '\n') ){     //line == "\r\n"
             break;
         }
     }
@@ -182,8 +182,16 @@ int main(int argc, char **argv)
               die("fwrite fails");
           }
 
+          /*
+          printf("%s", buf);
+          if (strcmp( buf, "</html>\n") ==0 ){
+              break;
+
+          }*/
     }
 
+
+
     fclose(fp);
 
 
-- 
2.17.1


From eb643018a7281b6667986eaf9d5bff2f77aed422 Mon Sep 17 00:00:00 2001
From: Yixuan_Zou <yz4004@columbia.edu>
Date: Mon, 25 Apr 2022 22:23:53 -0400
Subject: [PATCH 6/6] readme

---
 README.txt | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)
 create mode 100644 README.txt

diff --git a/README.txt b/README.txt
new file mode 100644
index 0000000..3739823
--- /dev/null
+++ b/README.txt
@@ -0,0 +1,26 @@
+Yixuan Zou
+
+yz4004
+
+
+For part2, I compare my make.html with jae's. At the bottom there are some
+extra lines:
+
+-----------------------------------------------------
+
+</body>
+</html>
+op"><a href="#Text-Functions">Text Functions</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-wordlist"><code>wordlist</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Text-Functions">Text Functions</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-words"><code>words</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Text-Functions">Text Functions</a></td></tr>
+<tr><td colspan="4"> <hr></td></tr>
+<tr><th id="Name-Index_fn_letter-Y">Y</th><td></td><td></td></tr>
+<tr><td></td><td valign="top"><a href="#index-YACC"><code>YACC</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Implicit-Variables">Implicit Variables</a></td></tr>
+<tr><td></td><td valign="top"><a href="#index-YFLAGS"><code>YFLAGS</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Implicit-V
+
+-----------------------------------------------------
+
+There are ways to get rid of them and just leave html body.
+But we also assume file may be other binary file.
+I don't know how to deal with this.
+
-- 
2.17.1


--PNTmBPCT7hxwcZjr
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab6.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 64e44df168e101c502800e7d1b67fc2fffb5ecf5 Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Mon, 25 Apr 2022 06:05:41 =
-0400=0ASubject: [PATCH 1/6] part1=0A=0A---=0A part1/mdb-lookup-server.c | =
229 ++++++++++++++++++++++++++++++++++++++=0A 1 file changed, 229 insertion=
s(+)=0A create mode 100644 part1/mdb-lookup-server.c=0A=0Adiff --git a/part=
1/mdb-lookup-server.c b/part1/mdb-lookup-server.c=0Anew file mode 100644=0A=
index 0000000..0df6051=0A--- /dev/null=0A+++ b/part1/mdb-lookup-server.c=0A=
@@ -0,0 +1,229 @@=0A+/*=0A+ * =0A+ */=0A+=0A+#include <ctype.h>=0A+#include=
 <stdio.h>=0A+#include <stdlib.h>=0A+#include <string.h>=0A+#include <asser=
t.h>=0A+#include <unistd.h>=0A+#include <sys/wait.h>=0A+#include <sys/stat.=
h>=0A+#include <arpa/inet.h>=0A+#include <sys/types.h>=0A+#include <sys/soc=
ket.h>=0A+=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <string=
=2Eh>=0A+=0A+#include "mylist.h"=0A+#include "mdb.h"=0A+=0A+#define KeyMax =
5=0A+=0A+=0A+=0A+=0A+=0A+int loadmdb(FILE *fp, struct List *dest) =0A+{=0A+=
    /*=0A+     * read all records into memory=0A+     */=0A+=0A+    struct =
MdbRec r;=0A+    struct Node *node =3D NULL;=0A+    int count =3D 0;=0A+=0A=
+    while (fread(&r, sizeof(r), 1, fp) =3D=3D 1) {=0A+=0A+        // alloc=
ate memory for a new record and copy into it the one=0A+        // that was=
 just read from the database.=0A+        struct MdbRec *rec =3D (struct Mdb=
Rec *)malloc(sizeof(r));=0A+        if (!rec)=0A+            return -1;=0A+=
        memcpy(rec, &r, sizeof(r));=0A+=0A+        // add the record to the=
 linked list.=0A+        node =3D addAfter(dest, node, rec);=0A+        if =
(node =3D=3D NULL) =0A+            return -1;=0A+=0A+        count++;=0A+  =
  }=0A+=0A+    // see if fread() produced error=0A+    if (ferror(fp)) =0A+=
        return -1;=0A+=0A+    return count;=0A+}=0A+=0A+void freemdb(struct=
 List *list) =0A+{=0A+    // free all the records=0A+    traverseList(list,=
 &free);=0A+    removeAllNodes(list);=0A+}=0A+=0A+=0A+=0A+static void die(c=
onst char *s) { perror(s); exit(1); }=0A+=0A+int main(int argc, char **argv=
)=0A+{=0A+    // ignore SIGPIPE so that we don=E2=80=99t terminate when we =
call=0A+    // send() on a disconnected socket.=0A+    if (signal(SIGPIPE, =
SIG_IGN) =3D=3D SIG_ERR) =0A+    die("signal() failed");=0A+=0A+=0A+    if =
(argc !=3D 3) {=0A+        fprintf(stderr, "usage: %s <server-port>\n", arg=
v[0]);=0A+        exit(1);=0A+    }=0A+=0A+=0A+=0A+    // db part=0A+    //=
 --------------------------------------------------------------------------=
-------=0A+=0A+    char *filename =3D argv[1];=0A+    FILE *fp =3D fopen(fi=
lename,"rb");=0A+    if (fp =3D=3D NULL) =0A+        die(filename);=0A+=0A+=
    struct List list;=0A+    initList(&list);=0A+=0A+    int loaded =3D loa=
dmdb(fp, &list);=0A+    if (loaded < 0)=0A+        die("loadmdb");=0A+    =
=0A+    fclose(fp);=0A+    // ---------------------------------------------=
------------------------------------=0A+=0A+=0A+=0A+=0A+    // socket part=
=0A+    // ----------------------------------------------------------------=
-----------------=0A+    unsigned short port =3D atoi(argv[2]);=0A+=0A+    =
int servsock;=0A+    if ((servsock =3D socket(AF_INET, SOCK_STREAM, 0)) < 0=
)=0A+        die("socket failed");=0A+=0A+    struct sockaddr_in servaddr;=
=0A+    memset(&servaddr, 0, sizeof(servaddr));=0A+    servaddr.sin_family =
=3D AF_INET;=0A+    servaddr.sin_addr.s_addr =3D htonl(INADDR_ANY); // any =
network interface=0A+    servaddr.sin_port =3D htons(port);=0A+=0A+=0A+    =
if (bind(servsock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)=0A=
+        die("bind failed");=0A+=0A+    if (listen(servsock, 5 /* queue siz=
e for connection requests */ ) < 0)=0A+        die("listen failed");=0A+=0A=
+    // int r;=0A+    // char buf[10];=0A+=0A+    int clntsock;=0A+    sock=
len_t clntlen;=0A+    struct sockaddr_in clntaddr;=0A+    // --------------=
-------------------------------------------------------------------=0A+=0A+=
    while (1) {=0A+=0A+        // Accept an incoming connection=0A+=0A+    =
    fprintf(stderr, "waiting for client ... ");=0A+=0A+        clntlen =3D =
sizeof(clntaddr); // initialize the in-out parameter=0A+=0A+        if ((cl=
ntsock =3D accept(servsock,=0A+                        (struct sockaddr *) =
&clntaddr, &clntlen)) < 0)=0A+            die("accept failed");=0A+=0A+    =
    // accept() returned a connected socket (also called client socket)=0A+=
        // and filled in the client's address into clntaddr=0A+=0A+        =
fprintf(stderr, "client ip: %s\n", inet_ntoa(clntaddr.sin_addr));=0A+=0A+=
=0A+=0A+        // ##############=0A+        FILE *input =3D fdopen(clntsoc=
k, "r" );=0A+        =0A+        char line[1000];=0A+        char key[KeyMa=
x + 1];=0A+=0A+        int r;=0A+=0A+        // recv()=0A+        while ( f=
gets(line, sizeof(line), input) !=3D NULL) {=0A+            =0A+=0A+       =
     // must null-terminate the string manually after strncpy().=0A+       =
     strncpy(key, line, sizeof(key) - 1);=0A+            key[sizeof(key) - =
1] =3D '\0';=0A+=0A+            // if newline is there, remove it.=0A+     =
       size_t last =3D strlen(key) - 1;=0A+            if (key[last] =3D=3D=
 '\n')=0A+                key[last] =3D '\0';=0A+=0A+            // travers=
e the list, printing out the matching records=0A+            struct Node* n=
ode =3D list.head;=0A+            int recNo =3D 1;=0A+            while (no=
de) {=0A+                struct MdbRec* rec =3D (struct MdbRec*)node->data;=
=0A+                if (strstr(rec->name, key) || strstr(rec->msg, key)) {=
=0A+                    //printf("%4d: {%s} said {%s}\n", recNo, rec->name,=
 rec->msg);=0A+=0A+                    =0A+                    char output_=
record[50];=0A+                    if((r =3D snprintf(output_record, 50, "%=
4d: {%s} said {%s}\n", recNo, rec->name, rec->msg)) =3D=3D 0){=0A+         =
               die("snprintf");=0A+                    }=0A+               =
     if(send(clntsock, output_record, r, 0) !=3D r){     =0A+              =
         fprintf(stderr, "ERR: send failed\n");=0A+                       b=
reak;=0A+                    }=0A+                   =0A+=0A+              =
  }=0A+                node =3D node->next;=0A+                recNo++;=0A+=
            }=0A+=0A+            // printf("\nlookup: ");=0A+            //=
 fflush(stdout);=0A+            char blankline[1];=0A+            *blanklin=
e =3D '\n';=0A+            if (send(clntsock, blankline, 1, 0) !=3D 1){=0A+=
                fprintf(stderr, "ERR: send blank line failed\n");=0A+      =
          }=0A+=0A+        // see if fgets() produced error=0A+        if (=
ferror(input))=0A+            die("input");=0A+=0A+        }=0A+=0A+    =0A=
+        // #################################=0A+        freemdb(&list);=0A=
+    =0A+        fclose(input);=0A+=0A+        close(clntsock);=0A+     }  =
  =0A+=0A+=0A+     return 0;=0A+}=0A-- =0A2.17.1=0A=0A=0AFrom 0934e14eec93e=
58770a6b6a17c066829ad69b202 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz=
4004@columbia.edu>=0ADate: Mon, 25 Apr 2022 06:21:24 -0400=0ASubject: [PATC=
H 2/6] modify part1=0A=0A---=0A part1/mdb-lookup-server.c | 14 ++++++------=
--=0A 1 file changed, 6 insertions(+), 8 deletions(-)=0A=0Adiff --git a/par=
t1/mdb-lookup-server.c b/part1/mdb-lookup-server.c=0Aindex 0df6051..25acf39=
 100644=0A--- a/part1/mdb-lookup-server.c=0A+++ b/part1/mdb-lookup-server.c=
=0A@@ -209,21 +209,19 @@ int main(int argc, char **argv)=0A                =
 fprintf(stderr, "ERR: send blank line failed\n");=0A                 }=0A =
=0A-        // see if fgets() produced error=0A-        if (ferror(input))=
=0A-            die("input");=0A+            // see if fgets() produced err=
or=0A+            if (ferror(input))=0A+                die("input");=0A =
=0A         }=0A =0A-    =0A-        // #################################=
=0A-        freemdb(&list);=0A-    =0A         fclose(input);=0A-=0A+    =
=0A         close(clntsock);=0A+        // ################################=
#=0A      }    =0A =0A =0A+     freemdb(&list);=0A      return 0;=0A }=0A--=
 =0A2.17.1=0A=0A=0AFrom 3ca0284987ab9efb691f0fd92a379a28b7ccbe3c Mon Sep 17=
 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Mon, 25 Apr=
 2022 06:38:31 -0400=0ASubject: [PATCH 3/6] modify part1 again=0A=0A---=0A =
part1/mdb-lookup-server.c | 8 +++++---=0A 1 file changed, 5 insertions(+), =
3 deletions(-)=0A=0Adiff --git a/part1/mdb-lookup-server.c b/part1/mdb-look=
up-server.c=0Aindex 25acf39..6eacf73 100644=0A--- a/part1/mdb-lookup-server=
=2Ec=0A+++ b/part1/mdb-lookup-server.c=0A@@ -1,5 +1,5 @@=0A /*=0A- * =0A+ *=
  mdb-lookup-server.c =0A  */=0A =0A #include <ctype.h>=0A@@ -106,6 +106,7 =
@@ int main(int argc, char **argv)=0A     // ------------------------------=
---------------------------------------------------=0A =0A =0A+    fprintf(=
stderr, "\n");=0A =0A =0A     // socket part=0A@@ -141,7 +142,7 @@ int main=
(int argc, char **argv)=0A =0A         // Accept an incoming connection=0A =
=0A-        fprintf(stderr, "waiting for client ... ");=0A+        // fprin=
tf(stderr, "waiting for client ... ");=0A =0A         clntlen =3D sizeof(cl=
ntaddr); // initialize the in-out parameter=0A =0A@@ -152,8 +153,9 @@ int m=
ain(int argc, char **argv)=0A         // accept() returned a connected sock=
et (also called client socket)=0A         // and filled in the client's add=
ress into clntaddr=0A =0A-        fprintf(stderr, "client ip: %s\n", inet_n=
toa(clntaddr.sin_addr));=0A+        //fprintf(stderr, "client ip: %s\n", in=
et_ntoa(clntaddr.sin_addr));=0A =0A+        fprintf(stderr, "connection sta=
rted from: %s\n", inet_ntoa(clntaddr.sin_addr));=0A =0A =0A         // ####=
##########=0A-- =0A2.17.1=0A=0A=0AFrom ecc457685b0d77f41ecf1f1e7ee822557412=
4bed Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADa=
te: Mon, 25 Apr 2022 17:41:01 -0400=0ASubject: [PATCH 4/6] part2=0A=0A---=
=0A part2/Makefile      |  28 +++++++=0A part2/http-client.c | 198 ++++++++=
++++++++++++++++++++++++++++++++++++=0A 2 files changed, 226 insertions(+)=
=0A create mode 100644 part2/Makefile=0A create mode 100644 part2/http-clie=
nt.c=0A=0Adiff --git a/part2/Makefile b/part2/Makefile=0Anew file mode 1006=
44=0Aindex 0000000..b4cd0c0=0A--- /dev/null=0A+++ b/part2/Makefile=0A@@ -0,=
0 +1,28 @@=0A+=0A+#=0A+# Makefile for lab 6, part 1=0A+#=0A+=0A+CC  =3D gcc=
=0A+CXX =3D g++=0A+=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=0A+CXXFLAGS =3D -g=
 -Wall $(INCLUDES)=0A+=0A+=0A+.PHONY: default=0A+default: http-client =0A+=
=0A+# header dependency=0A+## mdb-lookup-server.o: mdb.h=0A+=0A+=0A+=0A+.PH=
ONY: clean=0A+clean:=0A+	rm -f *.o *~ a.out core http-client=0A+=0A+.PHONY:=
 all=0A+all: clean default=0A+=0A+=0Adiff --git a/part2/http-client.c b/par=
t2/http-client.c=0Anew file mode 100644=0Aindex 0000000..659b09a=0A--- /dev=
/null=0A+++ b/part2/http-client.c=0A@@ -0,0 +1,198 @@=0A+/*=0A+ *  mdb-look=
up-server.c =0A+ */=0A+=0A+#include <ctype.h>=0A+#include <stdio.h>=0A+#inc=
lude <stdlib.h>=0A+#include <string.h>=0A+#include <assert.h>=0A+#include <=
unistd.h>=0A+#include <sys/wait.h>=0A+#include <sys/stat.h>=0A+#include <ar=
pa/inet.h>=0A+#include <sys/types.h>=0A+#include <sys/socket.h>=0A+=0A+#inc=
lude <stdio.h>=0A+#include <stdlib.h>=0A+#include <string.h>=0A+=0A+#includ=
e <netdb.h>=0A+=0A+=0A+=0A+static void die(const char *s) { perror(s); exit=
(1); }=0A+=0A+int main(int argc, char **argv)=0A+{=0A+    // ignore SIGPIPE=
 so that we don=E2=80=99t terminate when we call=0A+    // send() on a disc=
onnected socket.=0A+    if (signal(SIGPIPE, SIG_IGN) =3D=3D SIG_ERR) =0A+  =
  die("signal() failed");=0A+=0A+=0A+    if (argc !=3D 4) {=0A+        fpri=
ntf(stderr, "usage: %s <server-port>\n", argv[0]);=0A+        exit(1);=0A+ =
   }=0A+=0A+        =0A+=0A+    // =0A+    // -----------------------------=
----------------------------------------------------=0A+        =0A+    str=
uct hostent *he;=0A+    char *serverName =3D argv[1];=0A+    // get server =
ip from server name=0A+    if ((he =3D gethostbyname(serverName)) =3D=3D NU=
LL) {=0A+        die("gethostbyname failed");=0A+    }=0A+    =0A+    char =
*serverIP =3D inet_ntoa(*(struct in_addr *)he->h_addr);=0A+        =0A+    =
unsigned short port =3D atoi(argv[2]);=0A+=0A+    char *path =3D argv[3];=
=0A+=0A+=0A+    // strchr=0A+    const char backslash =3D '/';=0A+    char =
*filename =3D argv[3] ;=0A+=0A+    while((path =3D strchr(filename, backsla=
sh)) !=3D NULL ){=0A+        =0A+        //printf("path: %s\n", path);=0A+ =
       path++;=0A+        filename =3D path;=0A+    }=0A+=0A+    path =3D a=
rgv[3]; // ?=0A+=0A+    printf("host ip: %s, host name: %s, port: %d, filen=
ame: %s \n",serverIP, serverName, port, filename);    =0A+=0A+=0A+=0A+    /=
/ -------------------------------------------------------------------------=
--------=0A+=0A+=0A+    // Create a socket for TCP connection=0A+=0A+    in=
t sock; // socket descriptor=0A+    if ((sock =3D socket(AF_INET, SOCK_STRE=
AM, 0)) < 0)=0A+        die("socket failed");=0A+=0A+    // Construct a ser=
ver address structure=0A+=0A+    struct sockaddr_in servaddr;=0A+    memset=
(&servaddr, 0, sizeof(servaddr)); // must zero out the structure=0A+    ser=
vaddr.sin_family      =3D AF_INET;=0A+    servaddr.sin_addr.s_addr =3D inet=
_addr(serverIP);=0A+    servaddr.sin_port        =3D htons(port); // must b=
e in network byte order=0A+=0A+    // Establish a TCP connection to the ser=
ver=0A+=0A+    if (connect(sock, (struct sockaddr *) &servaddr, sizeof(serv=
addr)) < 0)=0A+        die("connect failed");=0A+=0A+    /*=0A+    char buf=
[1000];=0A+    if(recv(sock, buf, sizeof(buf),0 ) > 0){=0A+        printf("=
RECEIVE:\n%s", buf);=0A+    }*/=0A+=0A+=0A+    // -------------------------=
--------------------------------------------------------=0A+=0A+    char re=
quest_line[1000]  =3D "GET ";=0A+    strcat(request_line, path);=0A+    str=
cat(request_line, " HTTP/1.0\r\n");=0A+=0A+=0A+    // Host: the.host.name.y=
ou.are.connecting.to:<port_number>=0A+=0A+    strcat(request_line, "Host: "=
);=0A+    strcat(request_line, serverName);=0A+    strcat(request_line, ":"=
);=0A+=0A+    char num[100];=0A+    snprintf(num, 100,  "%d", port);=0A+=0A=
+    strcat(request_line, num);=0A+    strcat(request_line, "\r\n\r\n");=0A=
+=0A+    printf("request:\n%s\n", request_line);    =0A+    fflush(stdout);=
=0A+=0A+=0A+    //send()=0A+    // ----------------------------------------=
-----------------------------------------=0A+    int len =3D strlen(request=
_line);=0A+    if (send(sock, request_line, len, 0) !=3D len)=0A+        di=
e("send failed");=0A+=0A+=0A+    // printf("#######");=0A+    // fflush(std=
out);=0A+=0A+    /*=0A+    char buf1[1000];=0A+    if(recv(sock, buf1, size=
of(buf1),0 ) > 0){=0A+        printf("RECEIVE:\n%s", buf1);=0A+    }*/=0A+=
=0A+=0A+=0A+    // receive=0A+    // --------------------------------------=
-------------------------------------------=0A+    FILE *fp_sock =3D fdopen=
(sock, "r" );=0A+    char line[1000];=0A+    // fgets headers=0A+    if(fge=
ts(line, sizeof(line), fp_sock) !=3D NULL){=0A+       if ( strstr(line, "20=
0")){=0A+           printf("successful:\n%s", line);=0A+       }else{=0A+  =
         printf("%s", line);=0A+           close(sock);=0A+           exit(=
1);=0A+       } =0A+    }=0A+    // if 200, then proceed=0A+    while (fget=
s(line, sizeof(line), fp_sock ) !=3D NULL ){=0A+=0A+        printf("%s", li=
ne);=0A+=0A+        if(strncmp(line, "\r\n", 2) ){     //line =3D=3D "\r\n"=
=0A+            break;=0A+        }=0A+    }=0A+=0A+=0A+    // fread conten=
t=0A+    FILE *fp =3D fopen(filename, "w+");=0A+    char buf[4096];=0A+    =
if(fp =3D=3D0){=0A+        die("cannot write into");=0A+    }=0A+=0A+    in=
t n;=0A+    while( (n =3D fread(buf, 1, sizeof(buf), fp_sock)) > 0){=0A+=0A=
+          if(fwrite(buf, sizeof(buf), 1, fp) < 1){=0A+              die("f=
write fails");=0A+          }=0A+=0A+    }=0A+=0A+    fclose(fp);=0A+=0A+=
=0A+    // ----------------------------------------------------------------=
-----------------=0A+=0A+    fclose(fp_sock);=0A+    =0A+    close(sock);=
=0A+=0A+=0A+    return 0;=0A+}=0A-- =0A2.17.1=0A=0A=0AFrom 3ce92d37a1e802be=
29e2fe8f5783ffabd73b6148 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz400=
4@columbia.edu>=0ADate: Mon, 25 Apr 2022 22:17:29 -0400=0ASubject: [PATCH 5=
/6] remove comment=0A=0A---=0A part2/http-client.c | 20 ++++++++++++++-----=
-=0A 1 file changed, 14 insertions(+), 6 deletions(-)=0A=0Adiff --git a/par=
t2/http-client.c b/part2/http-client.c=0Aindex 659b09a..dd0d0a9 100644=0A--=
- a/part2/http-client.c=0A+++ b/part2/http-client.c=0A@@ -69,7 +69,7 @@ int=
 main(int argc, char **argv)=0A =0A     path =3D argv[3]; // ?=0A =0A-    p=
rintf("host ip: %s, host name: %s, port: %d, filename: %s \n",serverIP, ser=
verName, port, filename);    =0A+    //printf("host ip: %s, host name: %s, =
port: %d, filename: %s \n",serverIP, serverName, port, filename);    =0A =
=0A =0A =0A@@ -121,8 +121,8 @@ int main(int argc, char **argv)=0A     strca=
t(request_line, num);=0A     strcat(request_line, "\r\n\r\n");=0A =0A-    p=
rintf("request:\n%s\n", request_line);    =0A-    fflush(stdout);=0A+    //=
printf("request:\n%s\n", request_line);    =0A+    //fflush(stdout);=0A =0A=
 =0A     //send()=0A@@ -150,7 +150,7 @@ int main(int argc, char **argv)=0A =
    // fgets headers=0A     if(fgets(line, sizeof(line), fp_sock) !=3D NULL=
){=0A        if ( strstr(line, "200")){=0A-           printf("successful:\n=
%s", line);=0A+           // printf("successful:\n%s", line);=0A        }el=
se{=0A            printf("%s", line);=0A            close(sock);=0A@@ -160,=
9 +160,9 @@ int main(int argc, char **argv)=0A     // if 200, then proceed=
=0A     while (fgets(line, sizeof(line), fp_sock ) !=3D NULL ){=0A =0A-    =
    printf("%s", line);=0A+         //printf("%s", line);=0A =0A-        if=
(strncmp(line, "\r\n", 2) ){     //line =3D=3D "\r\n"=0A+        if((line[0=
] =3D=3D '\r') &&( line[1] =3D=3D '\n') ){     //line =3D=3D "\r\n"=0A     =
        break;=0A         }=0A     }=0A@@ -182,8 +182,16 @@ int main(int ar=
gc, char **argv)=0A               die("fwrite fails");=0A           }=0A =
=0A+          /*=0A+          printf("%s", buf);=0A+          if (strcmp( b=
uf, "</html>\n") =3D=3D0 ){=0A+              break;=0A+=0A+          }*/=0A=
     }=0A =0A+=0A+=0A     fclose(fp);=0A =0A =0A-- =0A2.17.1=0A=0A=0AFrom e=
b643018a7281b6667986eaf9d5bff2f77aed422 Mon Sep 17 00:00:00 2001=0AFrom: Yi=
xuan_Zou <yz4004@columbia.edu>=0ADate: Mon, 25 Apr 2022 22:23:53 -0400=0ASu=
bject: [PATCH 6/6] readme=0A=0A---=0A README.txt | 26 +++++++++++++++++++++=
+++++=0A 1 file changed, 26 insertions(+)=0A create mode 100644 README.txt=
=0A=0Adiff --git a/README.txt b/README.txt=0Anew file mode 100644=0Aindex 0=
000000..3739823=0A--- /dev/null=0A+++ b/README.txt=0A@@ -0,0 +1,26 @@=0A+Yi=
xuan Zou=0A+=0A+yz4004=0A+=0A+=0A+For part2, I compare my make.html with ja=
e's. At the bottom there are some=0A+extra lines:=0A+=0A+------------------=
-----------------------------------=0A+=0A+</body>=0A+</html>=0A+op"><a hre=
f=3D"#Text-Functions">Text Functions</a></td></tr>=0A+<tr><td></td><td vali=
gn=3D"top"><a href=3D"#index-wordlist"><code>wordlist</code></a>:</td><td>&=
nbsp;</td><td valign=3D"top"><a href=3D"#Text-Functions">Text Functions</a>=
</td></tr>=0A+<tr><td></td><td valign=3D"top"><a href=3D"#index-words"><cod=
e>words</code></a>:</td><td>&nbsp;</td><td valign=3D"top"><a href=3D"#Text-=
Functions">Text Functions</a></td></tr>=0A+<tr><td colspan=3D"4"> <hr></td>=
</tr>=0A+<tr><th id=3D"Name-Index_fn_letter-Y">Y</th><td></td><td></td></tr=
>=0A+<tr><td></td><td valign=3D"top"><a href=3D"#index-YACC"><code>YACC</co=
de></a>:</td><td>&nbsp;</td><td valign=3D"top"><a href=3D"#Implicit-Variabl=
es">Implicit Variables</a></td></tr>=0A+<tr><td></td><td valign=3D"top"><a =
href=3D"#index-YFLAGS"><code>YFLAGS</code></a>:</td><td>&nbsp;</td><td vali=
gn=3D"top"><a href=3D"#Implicit-V=0A+=0A+----------------------------------=
-------------------=0A+=0A+There are ways to get rid of them and just leave=
 html body.=0A+But we also assume file may be other binary file.=0A+I don't=
 know how to deal with this.=0A+=0A-- =0A2.17.1=0A=0A
--PNTmBPCT7hxwcZjr--

From do.not.reply@cloud.cs.columbia.edu Thu May  5 22:25:29 2022
Date: Thu, 5 May 2022 22:25:29 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab7.mbox
Message-ID: <20220506022529.GA6486@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="AhhlLboLdkugWU4S"
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 95790
Lines: 2429


--AhhlLboLdkugWU4S
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

=46rom 9c1b686e24e076e8292f46bee5102b36e24c340f Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 19:33:12 -0400
Subject: [PATCH 1/5] draft 1

---
 http-server.c | 731 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 731 insertions(+)
 create mode 100644 http-server.c

diff --git a/http-server.c b/http-server.c
new file mode 100644
index 0000000..3e57ef6
--- /dev/null
+++ b/http-server.c
@@ -0,0 +1,731 @@
+/*
+ * http-server.c
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <netdb.h>
+
+#include <assert.h> =20
+#include <sys/wait.h> =20
+#include <sys/stat.h>
+
+
+#define BUF_SIZE 4096
+
+static void die(const char *msg) {
+    perror(msg);
+    exit(1);
+}
+
+static void printUsage() {
+    fprintf(stderr, "usage: http-server <server_port> <web_root> <mdb-look=
up-host> <mdb-lookup-port>\n");
+    fprintf(stderr, "   ex) http-server www.example.com 80 /index.html\n");
+    exit(1);
+}
+
+char* cook_html(int code){ // char* content
+
+    char *html =3D (char *) malloc(1000 * sizeof(char));
+
+    char *error_code_prompt;
+    if(code =3D=3D 501)
+        error_code_prompt =3D  "Not Implemented";
+    if(code =3D=3D 400)
+        error_code_prompt =3D  "Bad Request";
+    if(code =3D=3D 404)
+        error_code_prompt =3D "Not Found";
+
+
+    snprintf(html, 1000,  //sizeof(html),=20
+            "HTTP/1.0 %d %s\r\n"
+            "\r\n"
+            //"<html>\r\n<body>\r\n<h1>%d %s</h1>\r\n</body>\r\n</html>\r\=
n",
+            "<html><body><h1>%d %s</h1></body></html>",
+            code, error_code_prompt, code, error_code_prompt);
+    printf("\n\n%s\\n\n", html);
+    return html;
+}
+
+
+
+
+
+int main(int argc, char **argv) {
+
+    // Ignore SIGPIPE so that we don=E2=80=99t terminate when we call
+    // send() on a disconnected socket
+    if (signal(SIGPIPE, SIG_IGN) =3D=3D SIG_ERR)
+        die("signal() failed");=20
+   =20
+    if (argc !=3D 5) {
+	printUsage();
+    }
+
+    // Assign server_port and web_root to correct command line arguments
+
+    unsigned short serv_port =3D atoi(argv[1]);
+    const char *web_root =3D argv[2];
+   =20
+
+    // Create a listening socket (also called server socket)=20
+
+    int servsock;
+    if ((servsock =3D socket(AF_INET, SOCK_STREAM, 0)) < 0)
+        die("socket failed");
+
+    // Construct local address structure
+
+    struct sockaddr_in servaddr;
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family =3D AF_INET;
+    servaddr.sin_addr.s_addr =3D htonl(INADDR_ANY); // any network interfa=
ce
+    servaddr.sin_port =3D htons(serv_port);
+
+    // Bind to the local address
+
+    if (bind(servsock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < =
0)
+        die("bind failed");
+
+    // Start listening for incoming connections
+
+    if (listen(servsock, 5 /* queue size for connection requests */ ) < 0)
+        die("listen failed");
+
+    int clntsock;
+    socklen_t clntlen;
+    struct sockaddr_in clntaddr;
+
+
+    // +-------------------------------------------
+    // part2 b
+
+    // create a mdb-lookup-server sock, now I'm a client to mdb-lookup-ser=
ver, and as a client, I only need server sock.
+
+    char *mdb_serverName =3D argv[3];
+    char *mdb_serverIP;
+    unsigned short mdb_serverPort =3D atoi(argv[4]);
+
+
+    int mdb_sock;
+    struct sockaddr_in mdb_serverAddr;
+    struct hostent *mdb_he;
+    // char buf_2[BUF_SIZE];                    // necessary?
+
+    =20
+    // get mdb-lookup server ip from mdb-server name
+    if ((mdb_he =3D gethostbyname(mdb_serverName)) =3D=3D NULL) {
+	die("gethostbyname failed");
+    }
+    mdb_serverIP =3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);
+
+    /* for debugging
+       printf("1: %s\n", mdb_serverName);
+       printf("2: %s\n", mdb_serverIP);
+       printf("3: %s\n", mdb_serverPort);
+       printf("4: %s\n", filePath);
+       printf("5: %s\n", fname);
+       */
+
+
+    // create socket
+    if ((mdb_sock =3D socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
+	die("socket failed");
+    }
+
+
+    // construct mdb-lookup server address
+    memset(&mdb_serverAddr, 0, sizeof(mdb_serverAddr));
+    mdb_serverAddr.sin_family =3D AF_INET;
+    mdb_serverAddr.sin_addr.s_addr =3D inet_addr(mdb_serverIP);
+    mdb_serverAddr.sin_port =3D htons(mdb_serverPort);
+
+    // connect
+    if (connect(mdb_sock, (struct sockaddr *)&mdb_serverAddr, sizeof(mdb_s=
erverAddr)) < 0) {
+	die("connect failed");
+    }
+
+   =20
+   =20
+    // wrap the socket with a file* so that we can read the socket using f=
gets()
+    FILE *fd_mdb;
+    if ((fd_mdb =3D fdopen(mdb_sock, "r")) =3D=3D NULL) {
+	die("fdopen failed mdb_sock");
+    }
+
+
+
+    // +-------------------------------------------
+
+    int count =3D 0;
+    while (1) {
+
+        printf("\n$ %d \n", count++);
+
+        char buf[4096];
+
+
+        // Accept an incoming connection
+
+        clntlen =3D sizeof(clntaddr); // initialize the in-out parameter
+
+        if ((clntsock =3D accept(servsock,
+                        (struct sockaddr * ) &clntaddr, &clntlen)) < 0){
+            //perror("next clinet");
+            //die("accept fail");
+            continue;=20
+        }
+
+        // accept() returned a connected socket (also called client socket)
+        // and filled in the client's address into clntaddr
+
+
+        // fd_clntsock, for clnt/browser
+        FILE *fd_clntsock; =20
+        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL) {  =20
+           // if i cannot open clntsock, is it a clnt crash issue? No, my =
problem. die=20
+            die("fdopen failed");
+        }
+
+
+
+        // read GET request from FILE *fd_clntsock, clnt request from brow=
ser
+        char requestLine[1000];=20
+        if(fgets(requestLine, sizeof(requestLine), fd_clntsock) =3D=3D NUL=
L ){
+            // fail to read request line, (maybe clnt crash/close connecti=
on -- fail to send request), skip current clnt to next one.
+            fprintf(stderr, "clnt crashes");
+            //fclose(fd_clntsock); no need
+            continue;
+        }
+
+        // parse browser http request line
+        char *token_separators =3D "\t \r\n"; // tab, space, new line
+        char *method =3D strtok(requestLine, token_separators);
+        //  printf("1 method:(%s)", method);
+        // printf("1 requestLine:(%s)", requestLine);
+      =20
+        char *requestURI =3D strtok(NULL, token_separators);
+        // printf("2 requestURI:(%s)", requestURI);
+        // printf("2 requestLine:(%s)", requestLine);
+      =20
+        char *httpVersion =3D strtok(NULL, token_separators);
+        // printf("3 httpVersion:(%s)", httpVersion);
+        // printf("3 requestLine:(%s)", requestLine);
+
+        /*
+           1 method:(GET)
+           1 requestLine:(GET)
+           2 requestURI:(/~yz4004/cs3157/tng/index.html)
+           2 requestLine:(GET)
+           3 httpVersion:(HTTP/1.1)
+           3 requestLine:(GET)$ 1*/
+
+        // print log through stderr, whether it's legal or not. if wrong p=
ut error code later.
+        fprintf(stderr, "%s \"%s %s\" ",
+                inet_ntoa(clntaddr.sin_addr),
+                method,
+                requestURI);
+
+
+
+
+/*
+           int html_size ;=20
+           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) !=
=3D 0 ){
+             printf("html: \n%s", buf);
+           }=20
+           fflush(stdout);
+ =20
+*/
+          =20
+
+
+        // Now parse method and httpVersion first, and then requestURI.=20
+        // 1. check GET keyword
+        if (strncmp(method, "GET", 3) !=3D 0 ){ //=20
+
+            // fclose(fd_clntsock); no need to turn this off, since this c=
lnt fails, we continue to next clnt (while 1)
+            // fd_clntsock created again & cover old one. Not simple die p=
rogram
+            // as long as program keep running, no need to close/free sinc=
e we do that at the end, unless die program.
+
+            // send error 501 http to clnt & output log
+            fprintf(stderr, "%d\n", 501);=20
+
+            char *html_501 =3D=20
+                "HTTP/1.0 501 Not Implemented"
+                "<html><body><h1>501 Not Implemented</h1></body></html>";
+
+            //printf("html : \n%s",html);
+            if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
+                die("send content failed");
+            }
+
+            continue;
+        }
+     =20
+        // 2. check whether http 1.0 or 1.1 protocol
+        if (strncmp("HTTP/1.0", httpVersion, 8) !=3D 0 && strncmp("HTTP/1.=
1", httpVersion, 8) !=3D 0) {
+       =20
+            fprintf(stderr, "\"%s %s %s\" %d\n",method, requestURI, httpVe=
rsion, 501);=20
+         =20
+            fclose(fd_clntsock);
+          =20
+
+          =20
+            char *html =3D cook_html(501);
+          =20
+            //size =3D snprintf(buf, sizeof(buf),"%s" , html);
+          =20
+            printf("html : \n%s",html);
+          =20
+            if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
+         =20
+                //free(html);
+         =20
+                die("send content failed");
+         =20
+            }
+         =20
+            free(html);=20
+         =20
+            continue;
+      =20
+        }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+       ///////////////   part 2 b
+
+
+           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
+
+       // http://clac.cs.columbia.edu:41782/mdb-lookup=20
+       if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){
+
+           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
+
+           const char *form =3D
+               "HTTP 200 OK\r\n"
+               "\r\n"
+               "<h1>mdb-lookup</h1>\n"
+               "<p>\n"
+               "<form method=3DGET action=3D/mdb-lookup>\n"
+               "lookup: <input type=3Dtext name=3Dkey>\n"
+               "<input type=3Dsubmit>\n"
+               "</form>\n"
+               "<p>\n";
+
+           if (send(clntsock, form, strlen(form), 0) !=3D strlen(form) ){
+               die("send content failed");
+           }
+
+
+           printf("\n\n send, you should see search page  \n\n");
+
+
+          continue;=20
+       }
+
+
+
+       // http://clac.cs.columbia.edu:41782/mdb-lookup?key=3Dhello=20
+       if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){
+
+           printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncmp(=
requestURI, "/mdb-lookup?key=3D",16 ));
+
+
+        /*
+        FILE *fd_clntsock;  // fp_servsock
+        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // fp=
_servsock =3D fdopen(servsock, "r")=20
+            die("fdopen failed");
+        }*/
+
+
+        // printf("why2");
+        // fflush(stdout);
+
+
+        /*
+           int html_size;=20
+           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) > 0=
 ){
+             printf("html: \n%s", buf);
+           }  =20
+
+
+        printf("||||||||||||||||||||||||||");
+        fflush(stdout);
+       =20
+        FILE *fd_clntsock_1;  // fp_servsock
+        if ((fd_clntsock_1 =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // =
fp_servsock =3D fdopen(servsock, "r")=20
+            die("fdopen failed");
+        }
+
+
+           //=20
+           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=
=3D 0 ){
+
+               printf("html: \n%s", buf);
+
+           }*/  =20
+       =20
+
+=20
+     =20
+           /*
+           // int html_size ;=20
+           // int i =3D 0;
+
+
+           // printf("\n%ld, %s \n", fread(buf,1,30,fd_clntsock), buf );=
=20
+           // printf("\n%ld\n", fread(buf,1,sizeof(buf),fd_clntsock));=20
+
+           // while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) =
>  0 ){
+
+           printf("_____ %d\n", i++);
+           fflush(stdout);
+             printf("html: \n%s", buf);
+             printf("88888 %d\n", i );
+             fflush(stdout);
+             break;
+            =20
+           } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =
=E4=BD=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=
=85=A5size? =20
+
+           /* // =E6=A3=80=E6=9F=A5 header
+           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
+               printf("\nHeaders: %s\n", buf);
+           }
+           fgets(buf,sizeof(buf), fd_clntsock);
+           printf("$$$$$$$$ %s", buf);
+
+           fgets(buf,sizeof(buf), fd_clntsock);
+           printf("*** $$$$$$$$ %s", buf);
+           */
+
+
+       =20
+        // printf("\n(%s)\n",requestURI);
+
+        for(int i=3D0; i<16; i++){
+            requestURI++;
+        }
+        strcat(requestURI, "\n");
+        // printf("\n(%s)\n",requestURI);
+
+
+
+        // =E6=88=91=E8=A6=81=E6=8A=8A=E4=B8=9C=E8=A5=BF search key send =
=E7=BB=99 mdb-lookup-server
+        //
+
+
+        printf("\n(%s)\n",requestURI);
+
+       // =E6=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=
=E4=BA=86=EF=BC=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2
+   =20
+    //printf("=1A=1A")   =20
+    if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strlen(requ=
estURI)) {
+	die("send failed");
+    }
+
+
+
+    /*
+           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
+               printf("\nHeaders: %s\n", buf);
+           }
+           */
+           // fgets(buf,sizeof(buf), fd_mdb);
+           // printf("$$$$$$$$ %s", buf);
+
+
+    /*
+           printf("\n\n 11111111111111111111111111111111------------------=
--------\n\n");
+
+           fgets(buf,sizeof(buf), fd_mdb);
+           printf("*** $$$$$$$$ %s", buf);
+
+           printf("\n\n 22222222222222222222222222222222------------------=
--------\n\n");
+
+           fgets(buf,sizeof(buf), fd_mdb);
+           printf("*** $$$$$$$$ %s", buf);
+      */
+
+
+
+
+  /*     =20
+    char html[10000];
+    strcpy(html,
+        "HTTP 200 OK\r\n"      =20
+        "\r\n"
+              =20
+        "<h1>mdb-lookup</h1>\n"
+              =20
+        "<p>\n"
+              =20
+        "<form method=3DGET action=3D/mdb-lookup>\n"
+              =20
+        "lookup: <input type=3Dtext name=3Dkey>\n"
+              =20
+        "<input type=3Dsubmit>\n"
+              =20
+        "</form>\n"
+              =20
+        "<p>\n"
+
+        "<p><table border>\n");
+
+
+        printf("0000000000000000000000000000000000000000000000000000000000=
000000\n");
+    char row[100];
+    while(fgets(buf, sizeof(buf), fd_mdb)!=3D NULL ){
+
+        if( strcmp(buf, "\n") =3D=3D 0){
+            printf("\n\n end \n\n");
+            break;
+        }
+
+        snprintf(row, sizeof(row), "<tr><td> %s\n", buf);
+        printf("%s\n", row );
+        strcat(html, row);
+
+     =20
+       =20
+    }
+
+    strcat(html, "</table>\n</body>\n</html>");
+
+
+    printf("\n\n%s\n\n", html);
+*/
+
+
+
+   =20
+    strcpy(buf,
+        "HTTP 200 OK\r\n"      =20
+        "\r\n"
+              =20
+        "<h1>mdb-lookup</h1>\n"
+              =20
+        "<p>\n"
+              =20
+        "<form method=3DGET action=3D/mdb-lookup>\n"
+              =20
+        "lookup: <input type=3Dtext name=3Dkey>\n"
+              =20
+        "<input type=3Dsubmit>\n"
+              =20
+        "</form>\n"
+              =20
+        "<p>\n"
+
+        "<p><table border>\n");
+
+   =20
+
+          =20
+    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+   =20
+        perror("send content failed");
+
+        break;
+
+    }
+
+    char row[100];
+    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
+
+        if( strcmp(row, "\n") =3D=3D 0){
+            printf("\n\n end \n\n");
+            break;
+        }
+
+
+        snprintf(buf, sizeof(buf), "<tr><td> %s\n", row);
+        //printf("%s\n", row) ;
+        //strcat(html, row);
+
+
+    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+   =20
+        perror("send content failed");
+
+        break;
+
+    }
+    }
+
+
+
+
+
+
+
+
+
+
+        continue;=20
+       }
+
+
+
+      =20
+       ////////////////////////////////////////////
+
+
+
+
+
+
+
+
+
+
+
+       // check requestURI !!!!!!!!!!!!!!!!
+       //
+      =20
+       // check web_root
+
+
+
+
+
+
+
+
+
+     =20
+
+
+
+
+
+       // printf("\nweb_root %s\n", web_root);
+
+
+       // log print out
+       fprintf(stderr, "\"%s %s %s\" %d OK\n",method, requestURI, httpVers=
ion, 200);
+
+       // retrive the file -- requestURI
+       // 1. make path
+       char full_path[100];  // should not be " char *full_path;" has to h=
ave len
+       strcpy(full_path, web_root);
+       strcat(full_path, requestURI);  // char *file_path =3D strcat(web_r=
oot, requestURI);
+
+
+
+       // int stat(const char *path, struct stat *buf);
+       // success returns 0 & fill buf, error return -1
+       // reference: https://www.ibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_7=
3/apis/stat.htm=20
+       struct stat status;
+       char full_path_1[strlen(full_path)];
+       strcpy(full_path_1, full_path);
+
+
+
+       // check ending char of path is '/' or not, return 400 error code  =
 =20
+       if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
+           // if ending with '/', attach index.html
+           strcat(full_path_1, "index.html");
+           // printf("***********%s\n", full_path_1);
+
+       }
+       /*
+       else{
+           // else send 400 error code
+           char *html =3D cook_html(400);
+           printf("html : \n%s",html);
+           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
+               free(html);
+               die("send content failed");
+           }
+           free(html);=20
+           fclose(fd_clntsock);
+           continue;
+       }*/
+
+
+
+       // if path/file exists, proceeds, else =20
+       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds -- file exists=
, then check directory/file
+
+           printf("**********  %s", full_path_1 );
+
+           // full_path ends with / or not
+           // printf("***********%s\n",full_path_1);
+           // printf("%c, %c\n", '/',full_path_1[strlen(full_path_1)-1] );
+           // if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
+           //        strcat(full_path_1, "index.html");
+           //        // printf("***********%s\n", full_path_1);
+           // }
+       }else{
+
+           //printf("\nfail does not exists:  %s\n", full_path_1 );
+
+           char *html =3D cook_html(404);
+           printf("html : \n%s",html);
+           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
+               //free(html);
+               die("send content failed");
+           }
+           free(html);=20
+           fclose(fd_clntsock);
+           continue;
+       }=20
+
+       // 2. send response headers
+       snprintf(buf, sizeof(buf),=20
+               "HTTP/1.0 200 OK\r\n"
+               "\r\n");
+
+       // 3. open file, read & send
+       // printf("\nfull_path_1: %s\n", full_path_1);
+       // printf("\nstat code: %d\n", stat(full_path_1, &status));
+       FILE *file_requested =3D fopen(full_path_1, "rb");
+       if( file_requested =3D=3D NULL)=20
+               die("fail open file");
+       int size_read;
+
+       size_read =3D strlen(buf); // should be 19, header=20
+       do{
+           printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
+           if( send(clntsock, buf, size_read, 0) !=3D size_read ){
+               perror("send content failed");
+               break;
+           }
+       }while(( size_read =3D fread(buf,1, sizeof(buf), file_requested)) >=
 0);
+
+
+       //if(feof(file_requested) )
+       //    printf("file has not been fully read");
+
+       fclose(file_requested);
+       fclose(fd_clntsock);
+
+       fclose(fd_mdb);
+
+
+    }// while (1)
+
+    return 0;
+}
--=20
2.17.1


=46rom dbe85f545b93c3d04f51b3eae63e7c4adce22c71 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 19:33:36 -0400
Subject: [PATCH 2/5] add makefile

---
 Makefile | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)
 create mode 100644 Makefile

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..a95373e
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,29 @@
+
+#
+# Makefile for lab 7, part 2
+#
+
+CC  =3D gcc
+CXX =3D g++
+
+CFLAGS   =3D -g -Wall $(INCLUDES)
+CXXFLAGS =3D -g -Wall $(INCLUDES)
+
+
+.PHONY: default
+default: http-server=20
+
+# header dependency
+## mdb-lookup-server.o: mdb.h
+
+
+
+.PHONY: clean
+clean:
+	rm -f *.o *~ a.out core http-server
+
+.PHONY: all
+all: clean default
+
+
+
--=20
2.17.1


=46rom 997c897e237b0e985f14ca4ea8e49e938dadd939 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 21:33:39 -0400
Subject: [PATCH 3/5] finish part2

---
 http-server.c | 500 ++++++++++++++------------------------------------
 1 file changed, 141 insertions(+), 359 deletions(-)

diff --git a/http-server.c b/http-server.c
index 3e57ef6..befd329 100644
--- a/http-server.c
+++ b/http-server.c
@@ -162,10 +162,10 @@ int main(int argc, char **argv) {
=20
     // +-------------------------------------------
=20
-    int count =3D 0;
+    //int count =3D 0;
     while (1) {
=20
-        printf("\n$ %d \n", count++);
+        //printf("\n$ %d \n", count++);
=20
         char buf[4096];
=20
@@ -234,17 +234,6 @@ int main(int argc, char **argv) {
=20
=20
=20
-/*
-           int html_size ;=20
-           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) !=
=3D 0 ){
-             printf("html: \n%s", buf);
-           }=20
-           fflush(stdout);
- =20
-*/
-          =20
-
-
         // Now parse method and httpVersion first, and then requestURI.=20
         // 1. check GET keyword
         if (strncmp(method, "GET", 3) !=3D 0 ){ //=20
@@ -254,15 +243,17 @@ int main(int argc, char **argv) {
             // as long as program keep running, no need to close/free sinc=
e we do that at the end, unless die program.
=20
             // send error 501 http to clnt & output log
-            fprintf(stderr, "%d\n", 501);=20
+            fprintf(stderr, "%d Not Implemented\n", 501);=20
=20
             char *html_501 =3D=20
-                "HTTP/1.0 501 Not Implemented"
+                "HTTP/1.0 501 Not Implemented\r\n\r\n"
                 "<html><body><h1>501 Not Implemented</h1></body></html>";
=20
             //printf("html : \n%s",html);
             if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
-                die("send content failed");
+               fclose(fd_mdb);
+               fclose(fd_clntsock);=20
+               die("send content failed");
             }
=20
             continue;
@@ -271,58 +262,59 @@ int main(int argc, char **argv) {
         // 2. check whether http 1.0 or 1.1 protocol
         if (strncmp("HTTP/1.0", httpVersion, 8) !=3D 0 && strncmp("HTTP/1.=
1", httpVersion, 8) !=3D 0) {
        =20
-            fprintf(stderr, "\"%s %s %s\" %d\n",method, requestURI, httpVe=
rsion, 501);=20
-         =20
-            fclose(fd_clntsock);
-          =20
+            fprintf(stderr, "%d Not Implemented\n", 501);=20
+            char *html_501 =3D=20
+                "HTTP/1.0 501 Not Implemented\r\n\r\n"
+                "<html><body><h1>501 Not Implemented</h1></body></html>";
=20
-          =20
-            char *html =3D cook_html(501);
-          =20
-            //size =3D snprintf(buf, sizeof(buf),"%s" , html);
-          =20
-            printf("html : \n%s",html);
-          =20
-            if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
-         =20
-                //free(html);
-         =20
-                die("send content failed");
-         =20
+            if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send content failed");
             }
-         =20
-            free(html);=20
-         =20
+
             continue;
-      =20
         }
=20
=20
=20
+        // 3. check URI starts with /, not ended with /..  not contains /.=
=2E/
=20
+        //printf("\n||||||| %s\n",requestURI);
+        if (strncmp("/", requestURI, 1) !=3D 0 || strstr(requestURI, "/../=
") || strstr(requestURI, "/..") )  {
+       =20
+            fprintf(stderr, "%d Bad Request\n", 400);=20
+            char *html_400 =3D=20
+                "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>";
+
+            if (send(clntsock, html_400, strlen(html_400), 0) !=3D strlen(=
html_400)){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send content failed");
+            }
=20
+            continue;
+        }
=20
=20
+        // printf("2333333333333333333333333333"); fflush(stdout);
=20
=20
=20
-
-
-
-
-
-
+        =20
=20
        ///////////////   part 2 b
=20
=20
-           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
+           //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
=20
        // http://clac.cs.columbia.edu:41782/mdb-lookup=20
        if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){
=20
-           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
-
+           //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
+      =20
+           fprintf(stderr, "200 OK\n");
            const char *form =3D
                "HTTP 200 OK\r\n"
                "\r\n"
@@ -335,296 +327,103 @@ int main(int argc, char **argv) {
                "<p>\n";
=20
            if (send(clntsock, form, strlen(form), 0) !=3D strlen(form) ){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
                die("send content failed");
            }
=20
-
-           printf("\n\n send, you should see search page  \n\n");
-
-
-          continue;=20
+           //printf("\n\n send, you should see search page  \n\n");
+           continue;=20
+     =20
        }
=20
=20
=20
+     =20
        // http://clac.cs.columbia.edu:41782/mdb-lookup?key=3Dhello=20
        if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){
=20
-           printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncmp(=
requestURI, "/mdb-lookup?key=3D",16 ));
-
-
-        /*
-        FILE *fd_clntsock;  // fp_servsock
-        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // fp=
_servsock =3D fdopen(servsock, "r")=20
-            die("fdopen failed");
-        }*/
-
-
-        // printf("why2");
-        // fflush(stdout);
-
-
-        /*
-           int html_size;=20
-           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) > 0=
 ){
-             printf("html: \n%s", buf);
-           }  =20
-
+           //printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncm=
p(requestURI, "/mdb-lookup?key=3D",16 ));
+     =20
+           // printf("\n(%s)\n",requestURI);
=20
-        printf("||||||||||||||||||||||||||");
-        fflush(stdout);
        =20
-        FILE *fd_clntsock_1;  // fp_servsock
-        if ((fd_clntsock_1 =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // =
fp_servsock =3D fdopen(servsock, "r")=20
-            die("fdopen failed");
-        }
-
-
-           //=20
-           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=
=3D 0 ){
-
-               printf("html: \n%s", buf);
-
-           }*/  =20
+           for(int i=3D0; i<16; i++){
+          =20
+               requestURI++;
        =20
-
-=20
-     =20
-           /*
-           // int html_size ;=20
-           // int i =3D 0;
-
-
-           // printf("\n%ld, %s \n", fread(buf,1,30,fd_clntsock), buf );=
=20
-           // printf("\n%ld\n", fread(buf,1,sizeof(buf),fd_clntsock));=20
-
-           // while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) =
>  0 ){
-
-           printf("_____ %d\n", i++);
-           fflush(stdout);
-             printf("html: \n%s", buf);
-             printf("88888 %d\n", i );
-             fflush(stdout);
-             break;
-            =20
-           } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =
=E4=BD=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=
=85=A5size? =20
-
-           /* // =E6=A3=80=E6=9F=A5 header
-           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
-               printf("\nHeaders: %s\n", buf);
            }
-           fgets(buf,sizeof(buf), fd_clntsock);
-           printf("$$$$$$$$ %s", buf);
-
-           fgets(buf,sizeof(buf), fd_clntsock);
-           printf("*** $$$$$$$$ %s", buf);
-           */
-
-
+          =20
+      =20
+           strcat(requestURI, "\n");
        =20
-        // printf("\n(%s)\n",requestURI);
-
-        for(int i=3D0; i<16; i++){
-            requestURI++;
-        }
-        strcat(requestURI, "\n");
-        // printf("\n(%s)\n",requestURI);
-
+           // printf("\n(%s)\n",requestURI);
=20
+           // send   =20
=20
-        // =E6=88=91=E8=A6=81=E6=8A=8A=E4=B8=9C=E8=A5=BF search key send =
=E7=BB=99 mdb-lookup-server
-        //
-
-
-        printf("\n(%s)\n",requestURI);
-
-       // =E6=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=
=E4=BA=86=EF=BC=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2
    =20
-    //printf("=1A=1A")   =20
-    if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strlen(requ=
estURI)) {
-	die("send failed");
-    }
-
-
-
-    /*
-           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
-               printf("\nHeaders: %s\n", buf);
+           if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strl=
en(requestURI)) {
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send failed");
            }
-           */
-           // fgets(buf,sizeof(buf), fd_mdb);
-           // printf("$$$$$$$$ %s", buf);
-
-
-    /*
-           printf("\n\n 11111111111111111111111111111111------------------=
--------\n\n");
-
-           fgets(buf,sizeof(buf), fd_mdb);
-           printf("*** $$$$$$$$ %s", buf);
-
-           printf("\n\n 22222222222222222222222222222222------------------=
--------\n\n");
-
-           fgets(buf,sizeof(buf), fd_mdb);
-           printf("*** $$$$$$$$ %s", buf);
-      */
-
-
-
-
-  /*     =20
-    char html[10000];
-    strcpy(html,
-        "HTTP 200 OK\r\n"      =20
-        "\r\n"
-              =20
-        "<h1>mdb-lookup</h1>\n"
-              =20
-        "<p>\n"
-              =20
-        "<form method=3DGET action=3D/mdb-lookup>\n"
-              =20
-        "lookup: <input type=3Dtext name=3Dkey>\n"
-              =20
-        "<input type=3Dsubmit>\n"
-              =20
-        "</form>\n"
-              =20
-        "<p>\n"
-
-        "<p><table border>\n");
-
-
-        printf("0000000000000000000000000000000000000000000000000000000000=
000000\n");
-    char row[100];
-    while(fgets(buf, sizeof(buf), fd_mdb)!=3D NULL ){
-
-        if( strcmp(buf, "\n") =3D=3D 0){
-            printf("\n\n end \n\n");
-            break;
-        }
-
-        snprintf(row, sizeof(row), "<tr><td> %s\n", buf);
-        printf("%s\n", row );
-        strcat(html, row);
-
-     =20
-       =20
-    }
-
-    strcat(html, "</table>\n</body>\n</html>");
-
-
-    printf("\n\n%s\n\n", html);
-*/
-
-
-
-   =20
-    strcpy(buf,
-        "HTTP 200 OK\r\n"      =20
-        "\r\n"
-              =20
-        "<h1>mdb-lookup</h1>\n"
-              =20
-        "<p>\n"
-              =20
-        "<form method=3DGET action=3D/mdb-lookup>\n"
-              =20
-        "lookup: <input type=3Dtext name=3Dkey>\n"
-              =20
-        "<input type=3Dsubmit>\n"
-              =20
-        "</form>\n"
-              =20
-        "<p>\n"
-
-        "<p><table border>\n");
-
+         =20
+      =20
+           fprintf(stderr, "200 OK\n");
+           strcpy(buf,
+                   "HTTP/1.0 200 OK\r\n"    =20
+                   "\r\n"
+                   "<h1>mdb-lookup</h1>\n"
+                   "<p>\n"
+                   "<form method=3DGET action=3D/mdb-lookup>\n"
+                   "lookup: <input type=3Dtext name=3Dkey>\n"
+                   "<input type=3Dsubmit>\n"
+                   "</form>\n"
+                   "<p>\n"
+                   "<p><table border>\n");
    =20
+           if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send contenct failed 2b)");
+           }
=20
+  =20
           =20
-    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
-   =20
-        perror("send content failed");
-
-        break;
-
-    }
-
-    char row[100];
-    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
-
-        if( strcmp(row, "\n") =3D=3D 0){
-            printf("\n\n end \n\n");
-            break;
-        }
-
-
-        snprintf(buf, sizeof(buf), "<tr><td> %s\n", row);
-        //printf("%s\n", row) ;
-        //strcat(html, row);
-
+         =20
+          =20
+           char row[100];
+         =20
+           int even =3D 0;
+          =20
+           while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
+               if( strcmp(row, "\n") =3D=3D 0){
+                   //printf("\n\n end \n\n");
+                   break;
+               }
=20
-    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+               if(even++%2 =3D=3D 0){
+              =20
+                   snprintf(buf, sizeof(buf), "<tr><td> %s\n", row);
+               }else{
+                   snprintf(buf, sizeof(buf), "<tr><td  bgcolor=3Dyellow> =
%s\n", row);
+
+               }
+               if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+                   fclose(fd_mdb);
+                   fclose(fd_clntsock);
+                   die("send contenct failed 2b)");
+               }
    =20
-        perror("send content failed");
-
-        break;
-
-    }
-    }
-
-
-
-
-
-
-
-
+           }
=20
=20
         continue;=20
-       }
-
-
-
-      =20
-       ////////////////////////////////////////////
+       }// end if ./mdb-lookup?key=3D
=20
=20
=20
-
-
-
-
-
-
-
-
-       // check requestURI !!!!!!!!!!!!!!!!
-       //
-      =20
-       // check web_root
-
-
-
-
-
-
-
-
-
-     =20
-
-
-
-
-
-       // printf("\nweb_root %s\n", web_root);
-
-
-       // log print out
-       fprintf(stderr, "\"%s %s %s\" %d OK\n",method, requestURI, httpVers=
ion, 200);
+       // part2 a) continue  //////////
=20
        // retrive the file -- requestURI
        // 1. make path
@@ -633,7 +432,6 @@ int main(int argc, char **argv) {
        strcat(full_path, requestURI);  // char *file_path =3D strcat(web_r=
oot, requestURI);
=20
=20
-
        // int stat(const char *path, struct stat *buf);
        // success returns 0 & fill buf, error return -1
        // reference: https://www.ibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_7=
3/apis/stat.htm=20
@@ -643,89 +441,73 @@ int main(int argc, char **argv) {
=20
=20
=20
-       // check ending char of path is '/' or not, return 400 error code  =
 =20
+       // check ending char of path is '/', if true, concat  index.html=20
        if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
-           // if ending with '/', attach index.html
            strcat(full_path_1, "index.html");
-           // printf("***********%s\n", full_path_1);
-
        }
-       /*
-       else{
-           // else send 400 error code
-           char *html =3D cook_html(400);
-           printf("html : \n%s",html);
-           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
-               free(html);
-               die("send content failed");
-           }
-           free(html);=20
-           fclose(fd_clntsock);
-           continue;
-       }*/
-
-
-
+      =20
+      =20
        // if path/file exists, proceeds, else =20
-       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds -- file exists=
, then check directory/file
-
-           printf("**********  %s", full_path_1 );
+       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds -- stat return=
 none 0,  file not exists, then check directory/file
=20
-           // full_path ends with / or not
-           // printf("***********%s\n",full_path_1);
-           // printf("%c, %c\n", '/',full_path_1[strlen(full_path_1)-1] );
-           // if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
-           //        strcat(full_path_1, "index.html");
-           //        // printf("***********%s\n", full_path_1);
-           // }
+           //printf("**********  %s", full_path_1 );
+      =20
        }else{
=20
            //printf("\nfail does not exists:  %s\n", full_path_1 );
+            fprintf(stderr, "%d Not Found\n", 404);=20
+            char *html_404 =3D=20
+                "HTTP/1.0 404 Not Found\r\n\r\n"
+                "<html><body><h1>404 Not Found</h1></body></html>";
+
+            if (send(clntsock, html_404, strlen(html_404), 0) !=3D strlen(=
html_404)){
+                   fclose(fd_mdb);
+                   fclose(fd_clntsock);
+                   die("send content failed");
+            }
=20
-           char *html =3D cook_html(404);
-           printf("html : \n%s",html);
-           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
-               //free(html);
-               die("send content failed");
-           }
-           free(html);=20
-           fclose(fd_clntsock);
-           continue;
+            continue;
        }=20
=20
-       // 2. send response headers
+
+       fprintf(stderr, "200 OK\n");
+
+
+       // 2. prepare response headers
        snprintf(buf, sizeof(buf),=20
                "HTTP/1.0 200 OK\r\n"
                "\r\n");
=20
        // 3. open file, read & send
-       // printf("\nfull_path_1: %s\n", full_path_1);
-       // printf("\nstat code: %d\n", stat(full_path_1, &status));
        FILE *file_requested =3D fopen(full_path_1, "rb");
-       if( file_requested =3D=3D NULL)=20
+       if( file_requested =3D=3D NULL){=20
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
                die("fail open file");
+       }
        int size_read;
=20
        size_read =3D strlen(buf); // should be 19, header=20
        do{
-           printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
+           //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
            if( send(clntsock, buf, size_read, 0) !=3D size_read ){
-               perror("send content failed");
-               break;
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send content failed");
            }
        }while(( size_read =3D fread(buf,1, sizeof(buf), file_requested)) >=
 0);
=20
=20
-       //if(feof(file_requested) )
-       //    printf("file has not been fully read");
-
        fclose(file_requested);
        fclose(fd_clntsock);
=20
-       fclose(fd_mdb);
-
-
+       fprintf(stdout, "\n");
     }// while (1)
=20
+      =20
+   =20
+
+=20
+    fclose(fd_mdb);
     return 0;
 }
--=20
2.17.1


=46rom 58ac4b4732ec355c52b3dab752eb8e3684cea079 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 22:22:07 -0400
Subject: [PATCH 4/5] finish test, part2 ab both work on firefox

---
 http-server.c | 78 +++++++++------------------------------------------
 1 file changed, 14 insertions(+), 64 deletions(-)

diff --git a/http-server.c b/http-server.c
index befd329..7387137 100644
--- a/http-server.c
+++ b/http-server.c
@@ -29,30 +29,6 @@ static void printUsage() {
     exit(1);
 }
=20
-char* cook_html(int code){ // char* content
-
-    char *html =3D (char *) malloc(1000 * sizeof(char));
-
-    char *error_code_prompt;
-    if(code =3D=3D 501)
-        error_code_prompt =3D  "Not Implemented";
-    if(code =3D=3D 400)
-        error_code_prompt =3D  "Bad Request";
-    if(code =3D=3D 404)
-        error_code_prompt =3D "Not Found";
-
-
-    snprintf(html, 1000,  //sizeof(html),=20
-            "HTTP/1.0 %d %s\r\n"
-            "\r\n"
-            //"<html>\r\n<body>\r\n<h1>%d %s</h1>\r\n</body>\r\n</html>\r\=
n",
-            "<html><body><h1>%d %s</h1></body></html>",
-            code, error_code_prompt, code, error_code_prompt);
-    printf("\n\n%s\\n\n", html);
-    return html;
-}
-
-
=20
=20
=20
@@ -115,7 +91,6 @@ int main(int argc, char **argv) {
     int mdb_sock;
     struct sockaddr_in mdb_serverAddr;
     struct hostent *mdb_he;
-    // char buf_2[BUF_SIZE];                    // necessary?
=20
     =20
     // get mdb-lookup server ip from mdb-server name
@@ -124,15 +99,6 @@ int main(int argc, char **argv) {
     }
     mdb_serverIP =3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);
=20
-    /* for debugging
-       printf("1: %s\n", mdb_serverName);
-       printf("2: %s\n", mdb_serverIP);
-       printf("3: %s\n", mdb_serverPort);
-       printf("4: %s\n", filePath);
-       printf("5: %s\n", fname);
-       */
-
-
     // create socket
     if ((mdb_sock =3D socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
 	die("socket failed");
@@ -300,23 +266,17 @@ int main(int argc, char **argv) {
=20
         // printf("2333333333333333333333333333"); fflush(stdout);
=20
-
-
         =20
=20
        ///////////////   part 2 b
=20
-
-           //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
-
        // http://clac.cs.columbia.edu:41782/mdb-lookup=20
        if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){
=20
            //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
-      =20
            fprintf(stderr, "200 OK\n");
            const char *form =3D
-               "HTTP 200 OK\r\n"
+               "HTTP/1.0 200 OK\r\n"
                "\r\n"
                "<h1>mdb-lookup</h1>\n"
                "<p>\n"
@@ -333,35 +293,24 @@ int main(int argc, char **argv) {
            }
=20
            //printf("\n\n send, you should see search page  \n\n");
+           fclose(fd_clntsock);
            continue;=20
      =20
        }
=20
-
-
      =20
        // http://clac.cs.columbia.edu:41782/mdb-lookup?key=3Dhello=20
        if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){
=20
            //printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncm=
p(requestURI, "/mdb-lookup?key=3D",16 ));
-     =20
            // printf("\n(%s)\n",requestURI);
-
-       =20
            for(int i=3D0; i<16; i++){
-          =20
                requestURI++;
-       =20
            }
-          =20
-      =20
            strcat(requestURI, "\n");
        =20
            // printf("\n(%s)\n",requestURI);
-
            // send   =20
-
-   =20
            if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strl=
en(requestURI)) {
                fclose(fd_mdb);
                fclose(fd_clntsock);
@@ -388,14 +337,8 @@ int main(int argc, char **argv) {
                die("send contenct failed 2b)");
            }
=20
-  =20
-          =20
-         =20
-          =20
            char row[100];
-         =20
            int even =3D 0;
-          =20
            while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
                if( strcmp(row, "\n") =3D=3D 0){
                    //printf("\n\n end \n\n");
@@ -417,8 +360,8 @@ int main(int argc, char **argv) {
    =20
            }
=20
-
-        continue;=20
+           fclose(fd_clntsock);
+           continue;=20
        }// end if ./mdb-lookup?key=3D
=20
=20
@@ -454,8 +397,15 @@ int main(int argc, char **argv) {
       =20
        }else{
=20
+           printf("**********  %s", full_path_1 );
+           fprintf(stderr, "%d Not Found\n", 404);=20
+           if( strcmp(full_path,"/mnt/disks/students221/yz4004/html/cs3157=
/tng/favicon.ico" ) =3D=3D 0 ){
+
+               break;
+           }
+
+
            //printf("\nfail does not exists:  %s\n", full_path_1 );
-            fprintf(stderr, "%d Not Found\n", 404);=20
             char *html_404 =3D=20
                 "HTTP/1.0 404 Not Found\r\n\r\n"
                 "<html><body><h1>404 Not Found</h1></body></html>";
@@ -492,6 +442,7 @@ int main(int argc, char **argv) {
            //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
            if( send(clntsock, buf, size_read, 0) !=3D size_read ){
                fclose(fd_mdb);
+               fclose(file_requested);
                fclose(fd_clntsock);
                die("send content failed");
            }
@@ -501,10 +452,9 @@ int main(int argc, char **argv) {
        fclose(file_requested);
        fclose(fd_clntsock);
=20
-       fprintf(stdout, "\n");
+       //fprintf(stdout, "\n");
     }// while (1)
=20
-      =20
    =20
=20
 =20
--=20
2.17.1


=46rom edbc31cfe47c1bfb59c17b691baed94f59b45d78 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 22:24:34 -0400
Subject: [PATCH 5/5] modify README

---
 README.txt | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/README.txt b/README.txt
index 66dfd3e..e571053 100644
--- a/README.txt
+++ b/README.txt
@@ -9,3 +9,10 @@ The description should indicate whether your solution for =
the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+
+
+Yixuan Zou
+yz4004
+lab7
+
+part2 a) b) both work on firefox.
--=20
2.17.1


--AhhlLboLdkugWU4S
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab7.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 9c1b686e24e076e8292f46bee5102b36e24c340f Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Thu, 5 May 2022 19:33:12 -=
0400=0ASubject: [PATCH 1/5] draft 1=0A=0A---=0A http-server.c | 731 +++++++=
+++++++++++++++++++++++++++++++++++++++++++=0A 1 file changed, 731 insertio=
ns(+)=0A create mode 100644 http-server.c=0A=0Adiff --git a/http-server.c b=
/http-server.c=0Anew file mode 100644=0Aindex 0000000..3e57ef6=0A--- /dev/n=
ull=0A+++ b/http-server.c=0A@@ -0,0 +1,731 @@=0A+/*=0A+ * http-server.c=0A+=
 */=0A+=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <string.h>=
=0A+#include <sys/types.h>=0A+#include <sys/socket.h>=0A+#include <arpa/ine=
t.h>=0A+#include <unistd.h>=0A+#include <netdb.h>=0A+=0A+#include <assert.h=
>  =0A+#include <sys/wait.h>  =0A+#include <sys/stat.h>=0A+=0A+=0A+#define =
BUF_SIZE 4096=0A+=0A+static void die(const char *msg) {=0A+    perror(msg);=
=0A+    exit(1);=0A+}=0A+=0A+static void printUsage() {=0A+    fprintf(stde=
rr, "usage: http-server <server_port> <web_root> <mdb-lookup-host> <mdb-loo=
kup-port>\n");=0A+    fprintf(stderr, "   ex) http-server www.example.com 8=
0 /index.html\n");=0A+    exit(1);=0A+}=0A+=0A+char* cook_html(int code){ /=
/ char* content=0A+=0A+    char *html =3D (char *) malloc(1000 * sizeof(cha=
r));=0A+=0A+    char *error_code_prompt;=0A+    if(code =3D=3D 501)=0A+    =
    error_code_prompt =3D  "Not Implemented";=0A+    if(code =3D=3D 400)=0A=
+        error_code_prompt =3D  "Bad Request";=0A+    if(code =3D=3D 404)=
=0A+        error_code_prompt =3D "Not Found";=0A+=0A+=0A+    snprintf(html=
, 1000,  //sizeof(html), =0A+            "HTTP/1.0 %d %s\r\n"=0A+          =
  "\r\n"=0A+            //"<html>\r\n<body>\r\n<h1>%d %s</h1>\r\n</body>\r\=
n</html>\r\n",=0A+            "<html><body><h1>%d %s</h1></body></html>",=
=0A+            code, error_code_prompt, code, error_code_prompt);=0A+    p=
rintf("\n\n%s\\n\n", html);=0A+    return html;=0A+}=0A+=0A+=0A+=0A+=0A+=0A=
+int main(int argc, char **argv) {=0A+=0A+    // Ignore SIGPIPE so that we =
don=E2=80=99t terminate when we call=0A+    // send() on a disconnected soc=
ket=0A+    if (signal(SIGPIPE, SIG_IGN) =3D=3D SIG_ERR)=0A+        die("sig=
nal() failed"); =0A+    =0A+    if (argc !=3D 5) {=0A+	printUsage();=0A+   =
 }=0A+=0A+    // Assign server_port and web_root to correct command line ar=
guments=0A+=0A+    unsigned short serv_port =3D atoi(argv[1]);=0A+    const=
 char *web_root =3D argv[2];=0A+    =0A+=0A+    // Create a listening socke=
t (also called server socket) =0A+=0A+    int servsock;=0A+    if ((servsoc=
k =3D socket(AF_INET, SOCK_STREAM, 0)) < 0)=0A+        die("socket failed")=
;=0A+=0A+    // Construct local address structure=0A+=0A+    struct sockadd=
r_in servaddr;=0A+    memset(&servaddr, 0, sizeof(servaddr));=0A+    servad=
dr.sin_family =3D AF_INET;=0A+    servaddr.sin_addr.s_addr =3D htonl(INADDR=
_ANY); // any network interface=0A+    servaddr.sin_port =3D htons(serv_por=
t);=0A+=0A+    // Bind to the local address=0A+=0A+    if (bind(servsock, (=
struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)=0A+        die("bind f=
ailed");=0A+=0A+    // Start listening for incoming connections=0A+=0A+    =
if (listen(servsock, 5 /* queue size for connection requests */ ) < 0)=0A+ =
       die("listen failed");=0A+=0A+    int clntsock;=0A+    socklen_t clnt=
len;=0A+    struct sockaddr_in clntaddr;=0A+=0A+=0A+    // +---------------=
----------------------------=0A+    // part2 b=0A+=0A+    // create a mdb-l=
ookup-server sock, now I'm a client to mdb-lookup-server, and as a client, =
I only need server sock.=0A+=0A+    char *mdb_serverName =3D argv[3];=0A+  =
  char *mdb_serverIP;=0A+    unsigned short mdb_serverPort =3D atoi(argv[4]=
);=0A+=0A+=0A+    int mdb_sock;=0A+    struct sockaddr_in mdb_serverAddr;=
=0A+    struct hostent *mdb_he;=0A+    // char buf_2[BUF_SIZE];            =
        // necessary?=0A+=0A+     =0A+    // get mdb-lookup server ip from =
mdb-server name=0A+    if ((mdb_he =3D gethostbyname(mdb_serverName)) =3D=
=3D NULL) {=0A+	die("gethostbyname failed");=0A+    }=0A+    mdb_serverIP =
=3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);=0A+=0A+    /* for debuggi=
ng=0A+       printf("1: %s\n", mdb_serverName);=0A+       printf("2: %s\n",=
 mdb_serverIP);=0A+       printf("3: %s\n", mdb_serverPort);=0A+       prin=
tf("4: %s\n", filePath);=0A+       printf("5: %s\n", fname);=0A+       */=
=0A+=0A+=0A+    // create socket=0A+    if ((mdb_sock =3D socket(PF_INET, S=
OCK_STREAM, IPPROTO_TCP)) < 0) {=0A+	die("socket failed");=0A+    }=0A+=0A+=
=0A+    // construct mdb-lookup server address=0A+    memset(&mdb_serverAdd=
r, 0, sizeof(mdb_serverAddr));=0A+    mdb_serverAddr.sin_family =3D AF_INET=
;=0A+    mdb_serverAddr.sin_addr.s_addr =3D inet_addr(mdb_serverIP);=0A+   =
 mdb_serverAddr.sin_port =3D htons(mdb_serverPort);=0A+=0A+    // connect=
=0A+    if (connect(mdb_sock, (struct sockaddr *)&mdb_serverAddr, sizeof(md=
b_serverAddr)) < 0) {=0A+	die("connect failed");=0A+    }=0A+=0A+    =0A+  =
  =0A+    // wrap the socket with a file* so that we can read the socket us=
ing fgets()=0A+    FILE *fd_mdb;=0A+    if ((fd_mdb =3D fdopen(mdb_sock, "r=
")) =3D=3D NULL) {=0A+	die("fdopen failed mdb_sock");=0A+    }=0A+=0A+=0A+=
=0A+    // +-------------------------------------------=0A+=0A+    int coun=
t =3D 0;=0A+    while (1) {=0A+=0A+        printf("\n$ %d \n", count++);=0A=
+=0A+        char buf[4096];=0A+=0A+=0A+        // Accept an incoming conne=
ction=0A+=0A+        clntlen =3D sizeof(clntaddr); // initialize the in-out=
 parameter=0A+=0A+        if ((clntsock =3D accept(servsock,=0A+           =
             (struct sockaddr * ) &clntaddr, &clntlen)) < 0){=0A+          =
  //perror("next clinet");=0A+            //die("accept fail");=0A+        =
    continue; =0A+        }=0A+=0A+        // accept() returned a connected=
 socket (also called client socket)=0A+        // and filled in the client'=
s address into clntaddr=0A+=0A+=0A+        // fd_clntsock, for clnt/browser=
=0A+        FILE *fd_clntsock;  =0A+        if ((fd_clntsock =3D fdopen(cln=
tsock, "r")) =3D=3D NULL) {   =0A+           // if i cannot open clntsock, =
is it a clnt crash issue? No, my problem. die =0A+            die("fdopen f=
ailed");=0A+        }=0A+=0A+=0A+=0A+        // read GET request from FILE =
*fd_clntsock, clnt request from browser=0A+        char requestLine[1000]; =
=0A+        if(fgets(requestLine, sizeof(requestLine), fd_clntsock) =3D=3D =
NULL ){=0A+            // fail to read request line, (maybe clnt crash/clos=
e connection -- fail to send request), skip current clnt to next one.=0A+  =
          fprintf(stderr, "clnt crashes");=0A+            //fclose(fd_clnts=
ock); no need=0A+            continue;=0A+        }=0A+=0A+        // parse=
 browser http request line=0A+        char *token_separators =3D "\t \r\n";=
 // tab, space, new line=0A+        char *method =3D strtok(requestLine, to=
ken_separators);=0A+        //  printf("1 method:(%s)", method);=0A+       =
 // printf("1 requestLine:(%s)", requestLine);=0A+       =0A+        char *=
requestURI =3D strtok(NULL, token_separators);=0A+        // printf("2 requ=
estURI:(%s)", requestURI);=0A+        // printf("2 requestLine:(%s)", reque=
stLine);=0A+       =0A+        char *httpVersion =3D strtok(NULL, token_sep=
arators);=0A+        // printf("3 httpVersion:(%s)", httpVersion);=0A+     =
   // printf("3 requestLine:(%s)", requestLine);=0A+=0A+        /*=0A+     =
      1 method:(GET)=0A+           1 requestLine:(GET)=0A+           2 requ=
estURI:(/~yz4004/cs3157/tng/index.html)=0A+           2 requestLine:(GET)=
=0A+           3 httpVersion:(HTTP/1.1)=0A+           3 requestLine:(GET)$ =
1*/=0A+=0A+        // print log through stderr, whether it's legal or not. =
if wrong put error code later.=0A+        fprintf(stderr, "%s \"%s %s\" ",=
=0A+                inet_ntoa(clntaddr.sin_addr),=0A+                method=
,=0A+                requestURI);=0A+=0A+=0A+=0A+=0A+/*=0A+           int h=
tml_size ; =0A+           while((html_size =3D fread(buf,1,sizeof(buf),fd_c=
lntsock) ) !=3D 0 ){=0A+             printf("html: \n%s", buf);=0A+        =
   } =0A+           fflush(stdout);=0A+  =0A+*/=0A+           =0A+=0A+=0A+ =
       // Now parse method and httpVersion first, and then requestURI. =0A+=
        // 1. check GET keyword=0A+        if (strncmp(method, "GET", 3) !=
=3D 0 ){ // =0A+=0A+            // fclose(fd_clntsock); no need to turn thi=
s off, since this clnt fails, we continue to next clnt (while 1)=0A+       =
     // fd_clntsock created again & cover old one. Not simple die program=
=0A+            // as long as program keep running, no need to close/free s=
ince we do that at the end, unless die program.=0A+=0A+            // send =
error 501 http to clnt & output log=0A+            fprintf(stderr, "%d\n", =
501); =0A+=0A+            char *html_501 =3D =0A+                "HTTP/1.0 =
501 Not Implemented"=0A+                "<html><body><h1>501 Not Implemente=
d</h1></body></html>";=0A+=0A+            //printf("html : \n%s",html);=0A+=
            if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(h=
tml_501)){=0A+                die("send content failed");=0A+            }=
=0A+=0A+            continue;=0A+        }=0A+      =0A+        // 2. check=
 whether http 1.0 or 1.1 protocol=0A+        if (strncmp("HTTP/1.0", httpVe=
rsion, 8) !=3D 0 && strncmp("HTTP/1.1", httpVersion, 8) !=3D 0) {=0A+      =
  =0A+            fprintf(stderr, "\"%s %s %s\" %d\n",method, requestURI, h=
ttpVersion, 501); =0A+          =0A+            fclose(fd_clntsock);=0A+   =
        =0A+=0A+           =0A+            char *html =3D cook_html(501);=
=0A+           =0A+            //size =3D snprintf(buf, sizeof(buf),"%s" , =
html);=0A+           =0A+            printf("html : \n%s",html);=0A+       =
    =0A+            if (send(clntsock, html, strlen(html), 0) !=3D strlen(h=
tml) ){=0A+          =0A+                //free(html);=0A+          =0A+   =
             die("send content failed");=0A+          =0A+            }=0A+=
          =0A+            free(html); =0A+          =0A+            continu=
e;=0A+       =0A+        }=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=
=0A+=0A+=0A+=0A+=0A+=0A+       ///////////////   part 2 b=0A+=0A+=0A+      =
     printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requestUR=
I, "/mdb-lookup"));=0A+=0A+       // http://clac.cs.columbia.edu:41782/mdb-=
lookup =0A+       if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){=0A+=0A+ =
          printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requ=
estURI, "/mdb-lookup"));=0A+=0A+           const char *form =3D=0A+        =
       "HTTP 200 OK\r\n"=0A+               "\r\n"=0A+               "<h1>md=
b-lookup</h1>\n"=0A+               "<p>\n"=0A+               "<form method=
=3DGET action=3D/mdb-lookup>\n"=0A+               "lookup: <input type=3Dte=
xt name=3Dkey>\n"=0A+               "<input type=3Dsubmit>\n"=0A+          =
     "</form>\n"=0A+               "<p>\n";=0A+=0A+           if (send(clnt=
sock, form, strlen(form), 0) !=3D strlen(form) ){=0A+               die("se=
nd content failed");=0A+           }=0A+=0A+=0A+           printf("\n\n sen=
d, you should see search page  \n\n");=0A+=0A+=0A+          continue; =0A+ =
      }=0A+=0A+=0A+=0A+       // http://clac.cs.columbia.edu:41782/mdb-look=
up?key=3Dhello =0A+       if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =
=3D=3D0 ){=0A+=0A+           printf("2222222222222222  (%s), %d\n\n\n", req=
uestURI, strncmp(requestURI, "/mdb-lookup?key=3D",16 ));=0A+=0A+=0A+       =
 /*=0A+        FILE *fd_clntsock;  // fp_servsock=0A+        if ((fd_clntso=
ck =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // fp_servsock =3D fdopen(se=
rvsock, "r") =0A+            die("fdopen failed");=0A+        }*/=0A+=0A+=
=0A+        // printf("why2");=0A+        // fflush(stdout);=0A+=0A+=0A+   =
     /*=0A+           int html_size; =0A+           while((html_size =3D fr=
ead(buf,1,sizeof(buf),fd_clntsock) ) > 0 ){=0A+             printf("html: \=
n%s", buf);=0A+           }   =0A+=0A+=0A+        printf("|||||||||||||||||=
|||||||||");=0A+        fflush(stdout);=0A+        =0A+        FILE *fd_cln=
tsock_1;  // fp_servsock=0A+        if ((fd_clntsock_1 =3D fdopen(clntsock,=
 "r")) =3D=3D NULL) {   // fp_servsock =3D fdopen(servsock, "r") =0A+      =
      die("fdopen failed");=0A+        }=0A+=0A+=0A+           // =0A+     =
      while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=3D 0 =
){=0A+=0A+               printf("html: \n%s", buf);=0A+=0A+           }*/  =
 =0A+        =0A+=0A+ =0A+      =0A+           /*=0A+           // int html=
_size ; =0A+           // int i =3D 0;=0A+=0A+=0A+           // printf("\n%=
ld, %s \n", fread(buf,1,30,fd_clntsock), buf ); =0A+           // printf("\=
n%ld\n", fread(buf,1,sizeof(buf),fd_clntsock)); =0A+=0A+           // while=
((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) >  0 ){=0A+=0A+     =
      printf("_____ %d\n", i++);=0A+           fflush(stdout);=0A+         =
    printf("html: \n%s", buf);=0A+             printf("88888 %d\n", i );=0A=
+             fflush(stdout);=0A+             break;=0A+             =0A+  =
         } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =E4=
=BD=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=85=
=A5size?  =0A+=0A+           /* // =E6=A3=80=E6=9F=A5 header=0A+           =
while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){=0A+               pri=
ntf("\nHeaders: %s\n", buf);=0A+           }=0A+           fgets(buf,sizeof=
(buf), fd_clntsock);=0A+           printf("$$$$$$$$ %s", buf);=0A+=0A+     =
      fgets(buf,sizeof(buf), fd_clntsock);=0A+           printf("*** $$$$$$=
$$ %s", buf);=0A+           */=0A+=0A+=0A+        =0A+        // printf("\n=
(%s)\n",requestURI);=0A+=0A+        for(int i=3D0; i<16; i++){=0A+         =
   requestURI++;=0A+        }=0A+        strcat(requestURI, "\n");=0A+     =
   // printf("\n(%s)\n",requestURI);=0A+=0A+=0A+=0A+        // =E6=88=91=E8=
=A6=81=E6=8A=8A=E4=B8=9C=E8=A5=BF search key send =E7=BB=99 mdb-lookup-serv=
er=0A+        //=0A+=0A+=0A+        printf("\n(%s)\n",requestURI);=0A+=0A+ =
      // =E6=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=E4=
=BA=86=EF=BC=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2=0A+    =0A+    //pri=
ntf("=1A=1A")    =0A+    if (send(mdb_sock, requestURI, strlen(requestURI),=
 0) !=3D strlen(requestURI)) {=0A+	die("send failed");=0A+    }=0A+=0A+=0A+=
=0A+    /*=0A+           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NUL=
L){=0A+               printf("\nHeaders: %s\n", buf);=0A+           }=0A+  =
         */=0A+           // fgets(buf,sizeof(buf), fd_mdb);=0A+           =
// printf("$$$$$$$$ %s", buf);=0A+=0A+=0A+    /*=0A+           printf("\n\n=
 11111111111111111111111111111111--------------------------\n\n");=0A+=0A+ =
          fgets(buf,sizeof(buf), fd_mdb);=0A+           printf("*** $$$$$$$=
$ %s", buf);=0A+=0A+           printf("\n\n 2222222222222222222222222222222=
2--------------------------\n\n");=0A+=0A+           fgets(buf,sizeof(buf),=
 fd_mdb);=0A+           printf("*** $$$$$$$$ %s", buf);=0A+      */=0A+=0A+=
=0A+=0A+=0A+  /*      =0A+    char html[10000];=0A+    strcpy(html,=0A+    =
    "HTTP 200 OK\r\n"       =0A+        "\r\n"=0A+               =0A+      =
  "<h1>mdb-lookup</h1>\n"=0A+               =0A+        "<p>\n"=0A+        =
       =0A+        "<form method=3DGET action=3D/mdb-lookup>\n"=0A+        =
       =0A+        "lookup: <input type=3Dtext name=3Dkey>\n"=0A+          =
     =0A+        "<input type=3Dsubmit>\n"=0A+               =0A+        "<=
/form>\n"=0A+               =0A+        "<p>\n"=0A+=0A+        "<p><table b=
order>\n");=0A+=0A+=0A+        printf("000000000000000000000000000000000000=
0000000000000000000000000000\n");=0A+    char row[100];=0A+    while(fgets(=
buf, sizeof(buf), fd_mdb)!=3D NULL ){=0A+=0A+        if( strcmp(buf, "\n") =
=3D=3D 0){=0A+            printf("\n\n end \n\n");=0A+            break;=0A=
+        }=0A+=0A+        snprintf(row, sizeof(row), "<tr><td> %s\n", buf);=
=0A+        printf("%s\n", row );=0A+        strcat(html, row);=0A+=0A+    =
  =0A+        =0A+    }=0A+=0A+    strcat(html, "</table>\n</body>\n</html>=
");=0A+=0A+=0A+    printf("\n\n%s\n\n", html);=0A+*/=0A+=0A+=0A+=0A+    =0A=
+    strcpy(buf,=0A+        "HTTP 200 OK\r\n"       =0A+        "\r\n"=0A+ =
              =0A+        "<h1>mdb-lookup</h1>\n"=0A+               =0A+   =
     "<p>\n"=0A+               =0A+        "<form method=3DGET action=3D/md=
b-lookup>\n"=0A+               =0A+        "lookup: <input type=3Dtext name=
=3Dkey>\n"=0A+               =0A+        "<input type=3Dsubmit>\n"=0A+     =
          =0A+        "</form>\n"=0A+               =0A+        "<p>\n"=0A+=
=0A+        "<p><table border>\n");=0A+=0A+    =0A+=0A+           =0A+    i=
f( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){=0A+    =0A+     =
   perror("send content failed");=0A+=0A+        break;=0A+=0A+    }=0A+=0A=
+    char row[100];=0A+    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){=
=0A+=0A+        if( strcmp(row, "\n") =3D=3D 0){=0A+            printf("\n\=
n end \n\n");=0A+            break;=0A+        }=0A+=0A+=0A+        snprint=
f(buf, sizeof(buf), "<tr><td> %s\n", row);=0A+        //printf("%s\n", row)=
 ;=0A+        //strcat(html, row);=0A+=0A+=0A+    if( send(clntsock, buf, s=
trlen(buf), 0) !=3D strlen(buf) ){=0A+    =0A+        perror("send content =
failed");=0A+=0A+        break;=0A+=0A+    }=0A+    }=0A+=0A+=0A+=0A+=0A+=
=0A+=0A+=0A+=0A+=0A+=0A+        continue; =0A+       }=0A+=0A+=0A+=0A+     =
  =0A+       ////////////////////////////////////////////=0A+=0A+=0A+=0A+=
=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+       // check requestURI !!!!!!!!!!!!!!!!=
=0A+       //=0A+       =0A+       // check web_root=0A+=0A+=0A+=0A+=0A+=0A=
+=0A+=0A+=0A+=0A+      =0A+=0A+=0A+=0A+=0A+=0A+       // printf("\nweb_root=
 %s\n", web_root);=0A+=0A+=0A+       // log print out=0A+       fprintf(std=
err, "\"%s %s %s\" %d OK\n",method, requestURI, httpVersion, 200);=0A+=0A+ =
      // retrive the file -- requestURI=0A+       // 1. make path=0A+      =
 char full_path[100];  // should not be " char *full_path;" has to have len=
=0A+       strcpy(full_path, web_root);=0A+       strcat(full_path, request=
URI);  // char *file_path =3D strcat(web_root, requestURI);=0A+=0A+=0A+=0A+=
       // int stat(const char *path, struct stat *buf);=0A+       // succes=
s returns 0 & fill buf, error return -1=0A+       // reference: https://www=
=2Eibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_73/apis/stat.htm =0A+       stru=
ct stat status;=0A+       char full_path_1[strlen(full_path)];=0A+       st=
rcpy(full_path_1, full_path);=0A+=0A+=0A+=0A+       // check ending char of=
 path is '/' or not, return 400 error code    =0A+       if(full_path_1[str=
len(full_path_1)-1] =3D=3D '/' ){=0A+           // if ending with '/', atta=
ch index.html=0A+           strcat(full_path_1, "index.html");=0A+         =
  // printf("***********%s\n", full_path_1);=0A+=0A+       }=0A+       /*=
=0A+       else{=0A+           // else send 400 error code=0A+           ch=
ar *html =3D cook_html(400);=0A+           printf("html : \n%s",html);=0A+ =
          if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){=0A=
+               free(html);=0A+               die("send content failed");=
=0A+           }=0A+           free(html); =0A+           fclose(fd_clntsoc=
k);=0A+           continue;=0A+       }*/=0A+=0A+=0A+=0A+       // if path/=
file exists, proceeds, else  =0A+       if(stat(full_path_1, &status) =3D=
=3D 0){ // succeeds -- file exists, then check directory/file=0A+=0A+      =
     printf("**********  %s", full_path_1 );=0A+=0A+           // full_path=
 ends with / or not=0A+           // printf("***********%s\n",full_path_1);=
=0A+           // printf("%c, %c\n", '/',full_path_1[strlen(full_path_1)-1]=
 );=0A+           // if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){=0A=
+           //        strcat(full_path_1, "index.html");=0A+           //  =
      // printf("***********%s\n", full_path_1);=0A+           // }=0A+    =
   }else{=0A+=0A+           //printf("\nfail does not exists:  %s\n", full_=
path_1 );=0A+=0A+           char *html =3D cook_html(404);=0A+           pr=
intf("html : \n%s",html);=0A+           if (send(clntsock, html, strlen(htm=
l), 0) !=3D strlen(html) ){=0A+               //free(html);=0A+            =
   die("send content failed");=0A+           }=0A+           free(html); =
=0A+           fclose(fd_clntsock);=0A+           continue;=0A+       } =0A=
+=0A+       // 2. send response headers=0A+       snprintf(buf, sizeof(buf)=
, =0A+               "HTTP/1.0 200 OK\r\n"=0A+               "\r\n");=0A+=
=0A+       // 3. open file, read & send=0A+       // printf("\nfull_path_1:=
 %s\n", full_path_1);=0A+       // printf("\nstat code: %d\n", stat(full_pa=
th_1, &status));=0A+       FILE *file_requested =3D fopen(full_path_1, "rb"=
);=0A+       if( file_requested =3D=3D NULL) =0A+               die("fail o=
pen file");=0A+       int size_read;=0A+=0A+       size_read =3D strlen(buf=
); // should be 19, header =0A+       do{=0A+           printf("\n @@@@@@@@=
@@@@@@@@@@ %d \n",size_read); =0A+           if( send(clntsock, buf, size_r=
ead, 0) !=3D size_read ){=0A+               perror("send content failed");=
=0A+               break;=0A+           }=0A+       }while(( size_read =3D =
fread(buf,1, sizeof(buf), file_requested)) > 0);=0A+=0A+=0A+       //if(feo=
f(file_requested) )=0A+       //    printf("file has not been fully read");=
=0A+=0A+       fclose(file_requested);=0A+       fclose(fd_clntsock);=0A+=
=0A+       fclose(fd_mdb);=0A+=0A+=0A+    }// while (1)=0A+=0A+    return 0=
;=0A+}=0A-- =0A2.17.1=0A=0A=0AFrom dbe85f545b93c3d04f51b3eae63e7c4adce22c71=
 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: =
Thu, 5 May 2022 19:33:36 -0400=0ASubject: [PATCH 2/5] add makefile=0A=0A---=
=0A Makefile | 29 +++++++++++++++++++++++++++++=0A 1 file changed, 29 inser=
tions(+)=0A create mode 100644 Makefile=0A=0Adiff --git a/Makefile b/Makefi=
le=0Anew file mode 100644=0Aindex 0000000..a95373e=0A--- /dev/null=0A+++ b/=
Makefile=0A@@ -0,0 +1,29 @@=0A+=0A+#=0A+# Makefile for lab 7, part 2=0A+#=
=0A+=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=
=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+=0A+.PHONY: default=0A+default=
: http-server =0A+=0A+# header dependency=0A+## mdb-lookup-server.o: mdb.h=
=0A+=0A+=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.o *~ a.out core http-se=
rver=0A+=0A+.PHONY: all=0A+all: clean default=0A+=0A+=0A+=0A-- =0A2.17.1=0A=
=0A=0AFrom 997c897e237b0e985f14ca4ea8e49e938dadd939 Mon Sep 17 00:00:00 200=
1=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Thu, 5 May 2022 21:33:39=
 -0400=0ASubject: [PATCH 3/5] finish part2=0A=0A---=0A http-server.c | 500 =
++++++++++++++------------------------------------=0A 1 file changed, 141 i=
nsertions(+), 359 deletions(-)=0A=0Adiff --git a/http-server.c b/http-serve=
r.c=0Aindex 3e57ef6..befd329 100644=0A--- a/http-server.c=0A+++ b/http-serv=
er.c=0A@@ -162,10 +162,10 @@ int main(int argc, char **argv) {=0A =0A     /=
/ +-------------------------------------------=0A =0A-    int count =3D 0;=
=0A+    //int count =3D 0;=0A     while (1) {=0A =0A-        printf("\n$ %d=
 \n", count++);=0A+        //printf("\n$ %d \n", count++);=0A =0A         c=
har buf[4096];=0A =0A@@ -234,17 +234,6 @@ int main(int argc, char **argv) {=
=0A =0A =0A =0A-/*=0A-           int html_size ; =0A-           while((html=
_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) !=3D 0 ){=0A-             =
printf("html: \n%s", buf);=0A-           } =0A-           fflush(stdout);=
=0A-  =0A-*/=0A-           =0A-=0A-=0A         // Now parse method and http=
Version first, and then requestURI. =0A         // 1. check GET keyword=0A =
        if (strncmp(method, "GET", 3) !=3D 0 ){ // =0A@@ -254,15 +243,17 @@=
 int main(int argc, char **argv) {=0A             // as long as program kee=
p running, no need to close/free since we do that at the end, unless die pr=
ogram.=0A =0A             // send error 501 http to clnt & output log=0A-  =
          fprintf(stderr, "%d\n", 501); =0A+            fprintf(stderr, "%d=
 Not Implemented\n", 501); =0A =0A             char *html_501 =3D =0A-     =
           "HTTP/1.0 501 Not Implemented"=0A+                "HTTP/1.0 501 =
Not Implemented\r\n\r\n"=0A                 "<html><body><h1>501 Not Implem=
ented</h1></body></html>";=0A =0A             //printf("html : \n%s",html);=
=0A             if (send(clntsock, html_501, strlen(html_501), 0) !=3D strl=
en(html_501)){=0A-                die("send content failed");=0A+          =
     fclose(fd_mdb);=0A+               fclose(fd_clntsock); =0A+           =
    die("send content failed");=0A             }=0A =0A             continu=
e;=0A@@ -271,58 +262,59 @@ int main(int argc, char **argv) {=0A         // =
2. check whether http 1.0 or 1.1 protocol=0A         if (strncmp("HTTP/1.0"=
, httpVersion, 8) !=3D 0 && strncmp("HTTP/1.1", httpVersion, 8) !=3D 0) {=
=0A         =0A-            fprintf(stderr, "\"%s %s %s\" %d\n",method, req=
uestURI, httpVersion, 501); =0A-          =0A-            fclose(fd_clntsoc=
k);=0A-           =0A+            fprintf(stderr, "%d Not Implemented\n", 5=
01); =0A+            char *html_501 =3D =0A+                "HTTP/1.0 501 N=
ot Implemented\r\n\r\n"=0A+                "<html><body><h1>501 Not Impleme=
nted</h1></body></html>";=0A =0A-           =0A-            char *html =3D =
cook_html(501);=0A-           =0A-            //size =3D snprintf(buf, size=
of(buf),"%s" , html);=0A-           =0A-            printf("html : \n%s",ht=
ml);=0A-           =0A-            if (send(clntsock, html, strlen(html), 0=
) !=3D strlen(html) ){=0A-          =0A-                //free(html);=0A-  =
        =0A-                die("send content failed");=0A-          =0A+  =
          if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(htm=
l_501)){=0A+               fclose(fd_mdb);=0A+               fclose(fd_clnt=
sock);=0A+               die("send content failed");=0A             }=0A-  =
        =0A-            free(html); =0A-          =0A+=0A             conti=
nue;=0A-       =0A         }=0A =0A =0A =0A+        // 3. check URI starts =
with /, not ended with /..  not contains /../=0A =0A+        //printf("\n||=
||||| %s\n",requestURI);=0A+        if (strncmp("/", requestURI, 1) !=3D 0 =
|| strstr(requestURI, "/../") || strstr(requestURI, "/..") )  {=0A+        =
=0A+            fprintf(stderr, "%d Bad Request\n", 400); =0A+            c=
har *html_400 =3D =0A+                "HTTP/1.0 400 Bad Request\r\n\r\n"=0A=
+                "<html><body><h1>400 Bad Request</h1></body></html>";=0A+=
=0A+            if (send(clntsock, html_400, strlen(html_400), 0) !=3D strl=
en(html_400)){=0A+               fclose(fd_mdb);=0A+               fclose(f=
d_clntsock);=0A+               die("send content failed");=0A+            }=
=0A =0A+            continue;=0A+        }=0A =0A =0A+        // printf("23=
33333333333333333333333333"); fflush(stdout);=0A =0A =0A =0A-=0A-=0A-=0A-=
=0A-=0A-=0A+         =0A =0A        ///////////////   part 2 b=0A =0A =0A- =
          printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requ=
estURI, "/mdb-lookup"));=0A+           //printf("111111111111111  (%s), %d\=
n\n\n", requestURI, strcmp(requestURI, "/mdb-lookup"));=0A =0A        // ht=
tp://clac.cs.columbia.edu:41782/mdb-lookup =0A        if (strcmp(requestURI=
, "/mdb-lookup") =3D=3D0 ){=0A =0A-           printf("111111111111111  (%s)=
, %d\n\n\n", requestURI, strcmp(requestURI, "/mdb-lookup"));=0A-=0A+       =
    //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requestU=
RI, "/mdb-lookup"));=0A+       =0A+           fprintf(stderr, "200 OK\n");=
=0A            const char *form =3D=0A                "HTTP 200 OK\r\n"=0A =
               "\r\n"=0A@@ -335,296 +327,103 @@ int main(int argc, char **a=
rgv) {=0A                "<p>\n";=0A =0A            if (send(clntsock, form=
, strlen(form), 0) !=3D strlen(form) ){=0A+               fclose(fd_mdb);=
=0A+               fclose(fd_clntsock);=0A                die("send content=
 failed");=0A            }=0A =0A-=0A-           printf("\n\n send, you sho=
uld see search page  \n\n");=0A-=0A-=0A-          continue; =0A+           =
//printf("\n\n send, you should see search page  \n\n");=0A+           cont=
inue; =0A+      =0A        }=0A =0A =0A =0A+      =0A        // http://clac=
=2Ecs.columbia.edu:41782/mdb-lookup?key=3Dhello =0A        if (strncmp(requ=
estURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){=0A =0A-           printf("22222=
22222222222  (%s), %d\n\n\n", requestURI, strncmp(requestURI, "/mdb-lookup?=
key=3D",16 ));=0A-=0A-=0A-        /*=0A-        FILE *fd_clntsock;  // fp_s=
ervsock=0A-        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL)=
 {   // fp_servsock =3D fdopen(servsock, "r") =0A-            die("fdopen f=
ailed");=0A-        }*/=0A-=0A-=0A-        // printf("why2");=0A-        //=
 fflush(stdout);=0A-=0A-=0A-        /*=0A-           int html_size; =0A-   =
        while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) > 0 ){=
=0A-             printf("html: \n%s", buf);=0A-           }   =0A-=0A+     =
      //printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncmp(requ=
estURI, "/mdb-lookup?key=3D",16 ));=0A+      =0A+           // printf("\n(%=
s)\n",requestURI);=0A =0A-        printf("||||||||||||||||||||||||||");=0A-=
        fflush(stdout);=0A         =0A-        FILE *fd_clntsock_1;  // fp_=
servsock=0A-        if ((fd_clntsock_1 =3D fdopen(clntsock, "r")) =3D=3D NU=
LL) {   // fp_servsock =3D fdopen(servsock, "r") =0A-            die("fdope=
n failed");=0A-        }=0A-=0A-=0A-           // =0A-           while((htm=
l_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=3D 0 ){=0A-=0A-      =
         printf("html: \n%s", buf);=0A-=0A-           }*/   =0A+           =
for(int i=3D0; i<16; i++){=0A+           =0A+               requestURI++;=
=0A         =0A-=0A- =0A-      =0A-           /*=0A-           // int html_=
size ; =0A-           // int i =3D 0;=0A-=0A-=0A-           // printf("\n%l=
d, %s \n", fread(buf,1,30,fd_clntsock), buf ); =0A-           // printf("\n=
%ld\n", fread(buf,1,sizeof(buf),fd_clntsock)); =0A-=0A-           // while(=
(html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) >  0 ){=0A-=0A-      =
     printf("_____ %d\n", i++);=0A-           fflush(stdout);=0A-          =
   printf("html: \n%s", buf);=0A-             printf("88888 %d\n", i );=0A-=
             fflush(stdout);=0A-             break;=0A-             =0A-   =
        } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =E4=BD=
=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=85=A5s=
ize?  =0A-=0A-           /* // =E6=A3=80=E6=9F=A5 header=0A-           whil=
e(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){=0A-               printf(=
"\nHeaders: %s\n", buf);=0A            }=0A-           fgets(buf,sizeof(buf=
), fd_clntsock);=0A-           printf("$$$$$$$$ %s", buf);=0A-=0A-         =
  fgets(buf,sizeof(buf), fd_clntsock);=0A-           printf("*** $$$$$$$$ %=
s", buf);=0A-           */=0A-=0A-=0A+           =0A+       =0A+           =
strcat(requestURI, "\n");=0A         =0A-        // printf("\n(%s)\n",reque=
stURI);=0A-=0A-        for(int i=3D0; i<16; i++){=0A-            requestURI=
++;=0A-        }=0A-        strcat(requestURI, "\n");=0A-        // printf(=
"\n(%s)\n",requestURI);=0A-=0A+           // printf("\n(%s)\n",requestURI);=
=0A =0A+           // send    =0A =0A-        // =E6=88=91=E8=A6=81=E6=8A=
=8A=E4=B8=9C=E8=A5=BF search key send =E7=BB=99 mdb-lookup-server=0A-      =
  //=0A-=0A-=0A-        printf("\n(%s)\n",requestURI);=0A-=0A-       // =E6=
=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=E4=BA=86=EF=BC=
=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2=0A     =0A-    //printf("=1A=1A"=
)    =0A-    if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D str=
len(requestURI)) {=0A-	die("send failed");=0A-    }=0A-=0A-=0A-=0A-    /*=
=0A-           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){=0A-   =
            printf("\nHeaders: %s\n", buf);=0A+           if (send(mdb_sock=
, requestURI, strlen(requestURI), 0) !=3D strlen(requestURI)) {=0A+        =
       fclose(fd_mdb);=0A+               fclose(fd_clntsock);=0A+          =
     die("send failed");=0A            }=0A-           */=0A-           // =
fgets(buf,sizeof(buf), fd_mdb);=0A-           // printf("$$$$$$$$ %s", buf)=
;=0A-=0A-=0A-    /*=0A-           printf("\n\n 1111111111111111111111111111=
1111--------------------------\n\n");=0A-=0A-           fgets(buf,sizeof(bu=
f), fd_mdb);=0A-           printf("*** $$$$$$$$ %s", buf);=0A-=0A-         =
  printf("\n\n 22222222222222222222222222222222--------------------------\n=
\n");=0A-=0A-           fgets(buf,sizeof(buf), fd_mdb);=0A-           print=
f("*** $$$$$$$$ %s", buf);=0A-      */=0A-=0A-=0A-=0A-=0A-  /*      =0A-   =
 char html[10000];=0A-    strcpy(html,=0A-        "HTTP 200 OK\r\n"       =
=0A-        "\r\n"=0A-               =0A-        "<h1>mdb-lookup</h1>\n"=0A=
-               =0A-        "<p>\n"=0A-               =0A-        "<form me=
thod=3DGET action=3D/mdb-lookup>\n"=0A-               =0A-        "lookup: =
<input type=3Dtext name=3Dkey>\n"=0A-               =0A-        "<input typ=
e=3Dsubmit>\n"=0A-               =0A-        "</form>\n"=0A-               =
=0A-        "<p>\n"=0A-=0A-        "<p><table border>\n");=0A-=0A-=0A-     =
   printf("0000000000000000000000000000000000000000000000000000000000000000=
\n");=0A-    char row[100];=0A-    while(fgets(buf, sizeof(buf), fd_mdb)!=
=3D NULL ){=0A-=0A-        if( strcmp(buf, "\n") =3D=3D 0){=0A-            =
printf("\n\n end \n\n");=0A-            break;=0A-        }=0A-=0A-        =
snprintf(row, sizeof(row), "<tr><td> %s\n", buf);=0A-        printf("%s\n",=
 row );=0A-        strcat(html, row);=0A-=0A-      =0A-        =0A-    }=0A=
-=0A-    strcat(html, "</table>\n</body>\n</html>");=0A-=0A-=0A-    printf(=
"\n\n%s\n\n", html);=0A-*/=0A-=0A-=0A-=0A-    =0A-    strcpy(buf,=0A-      =
  "HTTP 200 OK\r\n"       =0A-        "\r\n"=0A-               =0A-        =
"<h1>mdb-lookup</h1>\n"=0A-               =0A-        "<p>\n"=0A-          =
     =0A-        "<form method=3DGET action=3D/mdb-lookup>\n"=0A-          =
     =0A-        "lookup: <input type=3Dtext name=3Dkey>\n"=0A-            =
   =0A-        "<input type=3Dsubmit>\n"=0A-               =0A-        "</f=
orm>\n"=0A-               =0A-        "<p>\n"=0A-=0A-        "<p><table bor=
der>\n");=0A-=0A+          =0A+       =0A+           fprintf(stderr, "200 O=
K\n");=0A+           strcpy(buf,=0A+                   "HTTP/1.0 200 OK\r\n=
"     =0A+                   "\r\n"=0A+                   "<h1>mdb-lookup</=
h1>\n"=0A+                   "<p>\n"=0A+                   "<form method=3D=
GET action=3D/mdb-lookup>\n"=0A+                   "lookup: <input type=3Dt=
ext name=3Dkey>\n"=0A+                   "<input type=3Dsubmit>\n"=0A+     =
              "</form>\n"=0A+                   "<p>\n"=0A+                =
   "<p><table border>\n");=0A     =0A+           if( send(clntsock, buf, st=
rlen(buf), 0) !=3D strlen(buf) ){=0A+               fclose(fd_mdb);=0A+    =
           fclose(fd_clntsock);=0A+               die("send contenct failed=
 2b)");=0A+           }=0A =0A+   =0A            =0A-    if( send(clntsock,=
 buf, strlen(buf), 0) !=3D strlen(buf) ){=0A-    =0A-        perror("send c=
ontent failed");=0A-=0A-        break;=0A-=0A-    }=0A-=0A-    char row[100=
];=0A-    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){=0A-=0A-        i=
f( strcmp(row, "\n") =3D=3D 0){=0A-            printf("\n\n end \n\n");=0A-=
            break;=0A-        }=0A-=0A-=0A-        snprintf(buf, sizeof(buf=
), "<tr><td> %s\n", row);=0A-        //printf("%s\n", row) ;=0A-        //s=
trcat(html, row);=0A-=0A+          =0A+           =0A+           char row[1=
00];=0A+          =0A+           int even =3D 0;=0A+           =0A+        =
   while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){=0A+               if( s=
trcmp(row, "\n") =3D=3D 0){=0A+                   //printf("\n\n end \n\n")=
;=0A+                   break;=0A+               }=0A =0A-    if( send(clnt=
sock, buf, strlen(buf), 0) !=3D strlen(buf) ){=0A+               if(even++%=
2 =3D=3D 0){=0A+               =0A+                   snprintf(buf, sizeof(=
buf), "<tr><td> %s\n", row);=0A+               }else{=0A+                  =
 snprintf(buf, sizeof(buf), "<tr><td  bgcolor=3Dyellow> %s\n", row);=0A+=0A=
+               }=0A+               if( send(clntsock, buf, strlen(buf), 0)=
 !=3D strlen(buf) ){=0A+                   fclose(fd_mdb);=0A+             =
      fclose(fd_clntsock);=0A+                   die("send contenct failed =
2b)");=0A+               }=0A     =0A-        perror("send content failed")=
;=0A-=0A-        break;=0A-=0A-    }=0A-    }=0A-=0A-=0A-=0A-=0A-=0A-=0A-=
=0A-=0A+           }=0A =0A =0A         continue; =0A-       }=0A-=0A-=0A-=
=0A-       =0A-       ////////////////////////////////////////////=0A+     =
  }// end if ./mdb-lookup?key=3D=0A =0A =0A =0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A=
-=0A-       // check requestURI !!!!!!!!!!!!!!!!=0A-       //=0A-       =0A=
-       // check web_root=0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A-      =0A-=
=0A-=0A-=0A-=0A-=0A-       // printf("\nweb_root %s\n", web_root);=0A-=0A-=
=0A-       // log print out=0A-       fprintf(stderr, "\"%s %s %s\" %d OK\n=
",method, requestURI, httpVersion, 200);=0A+       // part2 a) continue  //=
////////=0A =0A        // retrive the file -- requestURI=0A        // 1. ma=
ke path=0A@@ -633,7 +432,6 @@ int main(int argc, char **argv) {=0A        s=
trcat(full_path, requestURI);  // char *file_path =3D strcat(web_root, requ=
estURI);=0A =0A =0A-=0A        // int stat(const char *path, struct stat *b=
uf);=0A        // success returns 0 & fill buf, error return -1=0A        /=
/ reference: https://www.ibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_73/apis/st=
at.htm =0A@@ -643,89 +441,73 @@ int main(int argc, char **argv) {=0A =0A =
=0A =0A-       // check ending char of path is '/' or not, return 400 error=
 code    =0A+       // check ending char of path is '/', if true, concat  i=
ndex.html =0A        if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){=0A=
-           // if ending with '/', attach index.html=0A            strcat(f=
ull_path_1, "index.html");=0A-           // printf("***********%s\n", full_=
path_1);=0A-=0A        }=0A-       /*=0A-       else{=0A-           // else=
 send 400 error code=0A-           char *html =3D cook_html(400);=0A-      =
     printf("html : \n%s",html);=0A-           if (send(clntsock, html, str=
len(html), 0) !=3D strlen(html) ){=0A-               free(html);=0A-       =
        die("send content failed");=0A-           }=0A-           free(html=
); =0A-           fclose(fd_clntsock);=0A-           continue;=0A-       }*=
/=0A-=0A-=0A-=0A+       =0A+       =0A        // if path/file exists, proce=
eds, else  =0A-       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds =
-- file exists, then check directory/file=0A-=0A-           printf("*******=
***  %s", full_path_1 );=0A+       if(stat(full_path_1, &status) =3D=3D 0){=
 // succeeds -- stat return none 0,  file not exists, then check directory/=
file=0A =0A-           // full_path ends with / or not=0A-           // pri=
ntf("***********%s\n",full_path_1);=0A-           // printf("%c, %c\n", '/'=
,full_path_1[strlen(full_path_1)-1] );=0A-           // if(full_path_1[strl=
en(full_path_1)-1] =3D=3D '/' ){=0A-           //        strcat(full_path_1=
, "index.html");=0A-           //        // printf("***********%s\n", full_=
path_1);=0A-           // }=0A+           //printf("**********  %s", full_p=
ath_1 );=0A+       =0A        }else{=0A =0A            //printf("\nfail doe=
s not exists:  %s\n", full_path_1 );=0A+            fprintf(stderr, "%d Not=
 Found\n", 404); =0A+            char *html_404 =3D =0A+                "HT=
TP/1.0 404 Not Found\r\n\r\n"=0A+                "<html><body><h1>404 Not F=
ound</h1></body></html>";=0A+=0A+            if (send(clntsock, html_404, s=
trlen(html_404), 0) !=3D strlen(html_404)){=0A+                   fclose(fd=
_mdb);=0A+                   fclose(fd_clntsock);=0A+                   die=
("send content failed");=0A+            }=0A =0A-           char *html =3D =
cook_html(404);=0A-           printf("html : \n%s",html);=0A-           if =
(send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){=0A-            =
   //free(html);=0A-               die("send content failed");=0A-         =
  }=0A-           free(html); =0A-           fclose(fd_clntsock);=0A-      =
     continue;=0A+            continue;=0A        } =0A =0A-       // 2. se=
nd response headers=0A+=0A+       fprintf(stderr, "200 OK\n");=0A+=0A+=0A+ =
      // 2. prepare response headers=0A        snprintf(buf, sizeof(buf), =
=0A                "HTTP/1.0 200 OK\r\n"=0A                "\r\n");=0A =0A =
       // 3. open file, read & send=0A-       // printf("\nfull_path_1: %s\=
n", full_path_1);=0A-       // printf("\nstat code: %d\n", stat(full_path_1=
, &status));=0A        FILE *file_requested =3D fopen(full_path_1, "rb");=
=0A-       if( file_requested =3D=3D NULL) =0A+       if( file_requested =
=3D=3D NULL){ =0A+               fclose(fd_mdb);=0A+               fclose(f=
d_clntsock);=0A                die("fail open file");=0A+       }=0A       =
 int size_read;=0A =0A        size_read =3D strlen(buf); // should be 19, h=
eader =0A        do{=0A-           printf("\n @@@@@@@@@@@@@@@@@@ %d \n",siz=
e_read); =0A+           //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read); =
=0A            if( send(clntsock, buf, size_read, 0) !=3D size_read ){=0A- =
              perror("send content failed");=0A-               break;=0A+  =
             fclose(fd_mdb);=0A+               fclose(fd_clntsock);=0A+    =
           die("send content failed");=0A            }=0A        }while(( s=
ize_read =3D fread(buf,1, sizeof(buf), file_requested)) > 0);=0A =0A =0A-  =
     //if(feof(file_requested) )=0A-       //    printf("file has not been =
fully read");=0A-=0A        fclose(file_requested);=0A        fclose(fd_cln=
tsock);=0A =0A-       fclose(fd_mdb);=0A-=0A-=0A+       fprintf(stdout, "\n=
");=0A     }// while (1)=0A =0A+       =0A+    =0A+=0A+ =0A+    fclose(fd_m=
db);=0A     return 0;=0A }=0A-- =0A2.17.1=0A=0A=0AFrom 58ac4b4732ec355c52b3=
dab752eb8e3684cea079 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@co=
lumbia.edu>=0ADate: Thu, 5 May 2022 22:22:07 -0400=0ASubject: [PATCH 4/5] f=
inish test, part2 ab both work on firefox=0A=0A---=0A http-server.c | 78 ++=
+++++++------------------------------------------=0A 1 file changed, 14 ins=
ertions(+), 64 deletions(-)=0A=0Adiff --git a/http-server.c b/http-server.c=
=0Aindex befd329..7387137 100644=0A--- a/http-server.c=0A+++ b/http-server.=
c=0A@@ -29,30 +29,6 @@ static void printUsage() {=0A     exit(1);=0A }=0A =
=0A-char* cook_html(int code){ // char* content=0A-=0A-    char *html =3D (=
char *) malloc(1000 * sizeof(char));=0A-=0A-    char *error_code_prompt;=0A=
-    if(code =3D=3D 501)=0A-        error_code_prompt =3D  "Not Implemented=
";=0A-    if(code =3D=3D 400)=0A-        error_code_prompt =3D  "Bad Reques=
t";=0A-    if(code =3D=3D 404)=0A-        error_code_prompt =3D "Not Found"=
;=0A-=0A-=0A-    snprintf(html, 1000,  //sizeof(html), =0A-            "HTT=
P/1.0 %d %s\r\n"=0A-            "\r\n"=0A-            //"<html>\r\n<body>\r=
\n<h1>%d %s</h1>\r\n</body>\r\n</html>\r\n",=0A-            "<html><body><h=
1>%d %s</h1></body></html>",=0A-            code, error_code_prompt, code, =
error_code_prompt);=0A-    printf("\n\n%s\\n\n", html);=0A-    return html;=
=0A-}=0A-=0A-=0A =0A =0A =0A@@ -115,7 +91,6 @@ int main(int argc, char **ar=
gv) {=0A     int mdb_sock;=0A     struct sockaddr_in mdb_serverAddr;=0A    =
 struct hostent *mdb_he;=0A-    // char buf_2[BUF_SIZE];                   =
 // necessary?=0A =0A      =0A     // get mdb-lookup server ip from mdb-ser=
ver name=0A@@ -124,15 +99,6 @@ int main(int argc, char **argv) {=0A     }=
=0A     mdb_serverIP =3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);=0A =
=0A-    /* for debugging=0A-       printf("1: %s\n", mdb_serverName);=0A-  =
     printf("2: %s\n", mdb_serverIP);=0A-       printf("3: %s\n", mdb_serve=
rPort);=0A-       printf("4: %s\n", filePath);=0A-       printf("5: %s\n", =
fname);=0A-       */=0A-=0A-=0A     // create socket=0A     if ((mdb_sock =
=3D socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {=0A 	die("socket faile=
d");=0A@@ -300,23 +266,17 @@ int main(int argc, char **argv) {=0A =0A      =
   // printf("2333333333333333333333333333"); fflush(stdout);=0A =0A-=0A-=
=0A          =0A =0A        ///////////////   part 2 b=0A =0A-=0A-         =
  //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requestURI=
, "/mdb-lookup"));=0A-=0A        // http://clac.cs.columbia.edu:41782/mdb-l=
ookup =0A        if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){=0A =0A   =
         //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(req=
uestURI, "/mdb-lookup"));=0A-       =0A            fprintf(stderr, "200 OK\=
n");=0A            const char *form =3D=0A-               "HTTP 200 OK\r\n"=
=0A+               "HTTP/1.0 200 OK\r\n"=0A                "\r\n"=0A       =
         "<h1>mdb-lookup</h1>\n"=0A                "<p>\n"=0A@@ -333,35 +29=
3,24 @@ int main(int argc, char **argv) {=0A            }=0A =0A           =
 //printf("\n\n send, you should see search page  \n\n");=0A+           fcl=
ose(fd_clntsock);=0A            continue; =0A       =0A        }=0A =0A-=0A=
-=0A       =0A        // http://clac.cs.columbia.edu:41782/mdb-lookup?key=
=3Dhello =0A        if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D=
0 ){=0A =0A            //printf("2222222222222222  (%s), %d\n\n\n", request=
URI, strncmp(requestURI, "/mdb-lookup?key=3D",16 ));=0A-      =0A          =
  // printf("\n(%s)\n",requestURI);=0A-=0A-        =0A            for(int i=
=3D0; i<16; i++){=0A-           =0A                requestURI++;=0A-       =
 =0A            }=0A-           =0A-       =0A            strcat(requestURI=
, "\n");=0A         =0A            // printf("\n(%s)\n",requestURI);=0A-=0A=
            // send    =0A-=0A-    =0A            if (send(mdb_sock, reques=
tURI, strlen(requestURI), 0) !=3D strlen(requestURI)) {=0A                f=
close(fd_mdb);=0A                fclose(fd_clntsock);=0A@@ -388,14 +337,8 @=
@ int main(int argc, char **argv) {=0A                die("send contenct fa=
iled 2b)");=0A            }=0A =0A-   =0A-           =0A-          =0A-    =
       =0A            char row[100];=0A-          =0A            int even =
=3D 0;=0A-           =0A            while(fgets(row, sizeof(row), fd_mdb)!=
=3D NULL){=0A                if( strcmp(row, "\n") =3D=3D 0){=0A           =
         //printf("\n\n end \n\n");=0A@@ -417,8 +360,8 @@ int main(int argc=
, char **argv) {=0A     =0A            }=0A =0A-=0A-        continue; =0A+ =
          fclose(fd_clntsock);=0A+           continue; =0A        }// end i=
f ./mdb-lookup?key=3D=0A =0A =0A@@ -454,8 +397,15 @@ int main(int argc, cha=
r **argv) {=0A        =0A        }else{=0A =0A+           printf("*********=
*  %s", full_path_1 );=0A+           fprintf(stderr, "%d Not Found\n", 404)=
; =0A+           if( strcmp(full_path,"/mnt/disks/students221/yz4004/html/c=
s3157/tng/favicon.ico" ) =3D=3D 0 ){=0A+=0A+               break;=0A+      =
     }=0A+=0A+=0A            //printf("\nfail does not exists:  %s\n", full=
_path_1 );=0A-            fprintf(stderr, "%d Not Found\n", 404); =0A      =
       char *html_404 =3D =0A                 "HTTP/1.0 404 Not Found\r\n\r=
\n"=0A                 "<html><body><h1>404 Not Found</h1></body></html>";=
=0A@@ -492,6 +442,7 @@ int main(int argc, char **argv) {=0A            //pr=
intf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read); =0A            if( send(clnt=
sock, buf, size_read, 0) !=3D size_read ){=0A                fclose(fd_mdb)=
;=0A+               fclose(file_requested);=0A                fclose(fd_cln=
tsock);=0A                die("send content failed");=0A            }=0A@@ =
-501,10 +452,9 @@ int main(int argc, char **argv) {=0A        fclose(file_r=
equested);=0A        fclose(fd_clntsock);=0A =0A-       fprintf(stdout, "\n=
");=0A+       //fprintf(stdout, "\n");=0A     }// while (1)=0A =0A-       =
=0A     =0A =0A  =0A-- =0A2.17.1=0A=0A=0AFrom edbc31cfe47c1bfb59c17b691baed=
94f59b45d78 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.ed=
u>=0ADate: Thu, 5 May 2022 22:24:34 -0400=0ASubject: [PATCH 5/5] modify REA=
DME=0A=0A---=0A README.txt | 7 +++++++=0A 1 file changed, 7 insertions(+)=
=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 66dfd3e..e571053 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -9,3 +9,10 @@ The description s=
hould indicate whether your solution for the part is=0A working or not.  Yo=
u may also want to include anything else you would=0A like to communicate t=
o the grader such as extra functionalities you=0A implemented or how you tr=
ied to fix your non-working code.=0A+=0A+=0A+Yixuan Zou=0A+yz4004=0A+lab7=
=0A+=0A+part2 a) b) both work on firefox.=0A-- =0A2.17.1=0A=0A
--AhhlLboLdkugWU4S--

From do.not.reply@cloud.cs.columbia.edu Thu May  5 23:45:19 2022
Date: Thu, 5 May 2022 23:45:19 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab7.mbox
Message-ID: <20220506034519.GA28397@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="/04w6evG8XlLl3ft"
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 110878
Lines: 2746


--/04w6evG8XlLl3ft
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

=46rom 9c1b686e24e076e8292f46bee5102b36e24c340f Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 19:33:12 -0400
Subject: [PATCH 1/6] draft 1

---
 http-server.c | 731 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 731 insertions(+)
 create mode 100644 http-server.c

diff --git a/http-server.c b/http-server.c
new file mode 100644
index 0000000..3e57ef6
--- /dev/null
+++ b/http-server.c
@@ -0,0 +1,731 @@
+/*
+ * http-server.c
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <netdb.h>
+
+#include <assert.h> =20
+#include <sys/wait.h> =20
+#include <sys/stat.h>
+
+
+#define BUF_SIZE 4096
+
+static void die(const char *msg) {
+    perror(msg);
+    exit(1);
+}
+
+static void printUsage() {
+    fprintf(stderr, "usage: http-server <server_port> <web_root> <mdb-look=
up-host> <mdb-lookup-port>\n");
+    fprintf(stderr, "   ex) http-server www.example.com 80 /index.html\n");
+    exit(1);
+}
+
+char* cook_html(int code){ // char* content
+
+    char *html =3D (char *) malloc(1000 * sizeof(char));
+
+    char *error_code_prompt;
+    if(code =3D=3D 501)
+        error_code_prompt =3D  "Not Implemented";
+    if(code =3D=3D 400)
+        error_code_prompt =3D  "Bad Request";
+    if(code =3D=3D 404)
+        error_code_prompt =3D "Not Found";
+
+
+    snprintf(html, 1000,  //sizeof(html),=20
+            "HTTP/1.0 %d %s\r\n"
+            "\r\n"
+            //"<html>\r\n<body>\r\n<h1>%d %s</h1>\r\n</body>\r\n</html>\r\=
n",
+            "<html><body><h1>%d %s</h1></body></html>",
+            code, error_code_prompt, code, error_code_prompt);
+    printf("\n\n%s\\n\n", html);
+    return html;
+}
+
+
+
+
+
+int main(int argc, char **argv) {
+
+    // Ignore SIGPIPE so that we don=E2=80=99t terminate when we call
+    // send() on a disconnected socket
+    if (signal(SIGPIPE, SIG_IGN) =3D=3D SIG_ERR)
+        die("signal() failed");=20
+   =20
+    if (argc !=3D 5) {
+	printUsage();
+    }
+
+    // Assign server_port and web_root to correct command line arguments
+
+    unsigned short serv_port =3D atoi(argv[1]);
+    const char *web_root =3D argv[2];
+   =20
+
+    // Create a listening socket (also called server socket)=20
+
+    int servsock;
+    if ((servsock =3D socket(AF_INET, SOCK_STREAM, 0)) < 0)
+        die("socket failed");
+
+    // Construct local address structure
+
+    struct sockaddr_in servaddr;
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family =3D AF_INET;
+    servaddr.sin_addr.s_addr =3D htonl(INADDR_ANY); // any network interfa=
ce
+    servaddr.sin_port =3D htons(serv_port);
+
+    // Bind to the local address
+
+    if (bind(servsock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < =
0)
+        die("bind failed");
+
+    // Start listening for incoming connections
+
+    if (listen(servsock, 5 /* queue size for connection requests */ ) < 0)
+        die("listen failed");
+
+    int clntsock;
+    socklen_t clntlen;
+    struct sockaddr_in clntaddr;
+
+
+    // +-------------------------------------------
+    // part2 b
+
+    // create a mdb-lookup-server sock, now I'm a client to mdb-lookup-ser=
ver, and as a client, I only need server sock.
+
+    char *mdb_serverName =3D argv[3];
+    char *mdb_serverIP;
+    unsigned short mdb_serverPort =3D atoi(argv[4]);
+
+
+    int mdb_sock;
+    struct sockaddr_in mdb_serverAddr;
+    struct hostent *mdb_he;
+    // char buf_2[BUF_SIZE];                    // necessary?
+
+    =20
+    // get mdb-lookup server ip from mdb-server name
+    if ((mdb_he =3D gethostbyname(mdb_serverName)) =3D=3D NULL) {
+	die("gethostbyname failed");
+    }
+    mdb_serverIP =3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);
+
+    /* for debugging
+       printf("1: %s\n", mdb_serverName);
+       printf("2: %s\n", mdb_serverIP);
+       printf("3: %s\n", mdb_serverPort);
+       printf("4: %s\n", filePath);
+       printf("5: %s\n", fname);
+       */
+
+
+    // create socket
+    if ((mdb_sock =3D socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
+	die("socket failed");
+    }
+
+
+    // construct mdb-lookup server address
+    memset(&mdb_serverAddr, 0, sizeof(mdb_serverAddr));
+    mdb_serverAddr.sin_family =3D AF_INET;
+    mdb_serverAddr.sin_addr.s_addr =3D inet_addr(mdb_serverIP);
+    mdb_serverAddr.sin_port =3D htons(mdb_serverPort);
+
+    // connect
+    if (connect(mdb_sock, (struct sockaddr *)&mdb_serverAddr, sizeof(mdb_s=
erverAddr)) < 0) {
+	die("connect failed");
+    }
+
+   =20
+   =20
+    // wrap the socket with a file* so that we can read the socket using f=
gets()
+    FILE *fd_mdb;
+    if ((fd_mdb =3D fdopen(mdb_sock, "r")) =3D=3D NULL) {
+	die("fdopen failed mdb_sock");
+    }
+
+
+
+    // +-------------------------------------------
+
+    int count =3D 0;
+    while (1) {
+
+        printf("\n$ %d \n", count++);
+
+        char buf[4096];
+
+
+        // Accept an incoming connection
+
+        clntlen =3D sizeof(clntaddr); // initialize the in-out parameter
+
+        if ((clntsock =3D accept(servsock,
+                        (struct sockaddr * ) &clntaddr, &clntlen)) < 0){
+            //perror("next clinet");
+            //die("accept fail");
+            continue;=20
+        }
+
+        // accept() returned a connected socket (also called client socket)
+        // and filled in the client's address into clntaddr
+
+
+        // fd_clntsock, for clnt/browser
+        FILE *fd_clntsock; =20
+        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL) {  =20
+           // if i cannot open clntsock, is it a clnt crash issue? No, my =
problem. die=20
+            die("fdopen failed");
+        }
+
+
+
+        // read GET request from FILE *fd_clntsock, clnt request from brow=
ser
+        char requestLine[1000];=20
+        if(fgets(requestLine, sizeof(requestLine), fd_clntsock) =3D=3D NUL=
L ){
+            // fail to read request line, (maybe clnt crash/close connecti=
on -- fail to send request), skip current clnt to next one.
+            fprintf(stderr, "clnt crashes");
+            //fclose(fd_clntsock); no need
+            continue;
+        }
+
+        // parse browser http request line
+        char *token_separators =3D "\t \r\n"; // tab, space, new line
+        char *method =3D strtok(requestLine, token_separators);
+        //  printf("1 method:(%s)", method);
+        // printf("1 requestLine:(%s)", requestLine);
+      =20
+        char *requestURI =3D strtok(NULL, token_separators);
+        // printf("2 requestURI:(%s)", requestURI);
+        // printf("2 requestLine:(%s)", requestLine);
+      =20
+        char *httpVersion =3D strtok(NULL, token_separators);
+        // printf("3 httpVersion:(%s)", httpVersion);
+        // printf("3 requestLine:(%s)", requestLine);
+
+        /*
+           1 method:(GET)
+           1 requestLine:(GET)
+           2 requestURI:(/~yz4004/cs3157/tng/index.html)
+           2 requestLine:(GET)
+           3 httpVersion:(HTTP/1.1)
+           3 requestLine:(GET)$ 1*/
+
+        // print log through stderr, whether it's legal or not. if wrong p=
ut error code later.
+        fprintf(stderr, "%s \"%s %s\" ",
+                inet_ntoa(clntaddr.sin_addr),
+                method,
+                requestURI);
+
+
+
+
+/*
+           int html_size ;=20
+           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) !=
=3D 0 ){
+             printf("html: \n%s", buf);
+           }=20
+           fflush(stdout);
+ =20
+*/
+          =20
+
+
+        // Now parse method and httpVersion first, and then requestURI.=20
+        // 1. check GET keyword
+        if (strncmp(method, "GET", 3) !=3D 0 ){ //=20
+
+            // fclose(fd_clntsock); no need to turn this off, since this c=
lnt fails, we continue to next clnt (while 1)
+            // fd_clntsock created again & cover old one. Not simple die p=
rogram
+            // as long as program keep running, no need to close/free sinc=
e we do that at the end, unless die program.
+
+            // send error 501 http to clnt & output log
+            fprintf(stderr, "%d\n", 501);=20
+
+            char *html_501 =3D=20
+                "HTTP/1.0 501 Not Implemented"
+                "<html><body><h1>501 Not Implemented</h1></body></html>";
+
+            //printf("html : \n%s",html);
+            if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
+                die("send content failed");
+            }
+
+            continue;
+        }
+     =20
+        // 2. check whether http 1.0 or 1.1 protocol
+        if (strncmp("HTTP/1.0", httpVersion, 8) !=3D 0 && strncmp("HTTP/1.=
1", httpVersion, 8) !=3D 0) {
+       =20
+            fprintf(stderr, "\"%s %s %s\" %d\n",method, requestURI, httpVe=
rsion, 501);=20
+         =20
+            fclose(fd_clntsock);
+          =20
+
+          =20
+            char *html =3D cook_html(501);
+          =20
+            //size =3D snprintf(buf, sizeof(buf),"%s" , html);
+          =20
+            printf("html : \n%s",html);
+          =20
+            if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
+         =20
+                //free(html);
+         =20
+                die("send content failed");
+         =20
+            }
+         =20
+            free(html);=20
+         =20
+            continue;
+      =20
+        }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+       ///////////////   part 2 b
+
+
+           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
+
+       // http://clac.cs.columbia.edu:41782/mdb-lookup=20
+       if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){
+
+           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
+
+           const char *form =3D
+               "HTTP 200 OK\r\n"
+               "\r\n"
+               "<h1>mdb-lookup</h1>\n"
+               "<p>\n"
+               "<form method=3DGET action=3D/mdb-lookup>\n"
+               "lookup: <input type=3Dtext name=3Dkey>\n"
+               "<input type=3Dsubmit>\n"
+               "</form>\n"
+               "<p>\n";
+
+           if (send(clntsock, form, strlen(form), 0) !=3D strlen(form) ){
+               die("send content failed");
+           }
+
+
+           printf("\n\n send, you should see search page  \n\n");
+
+
+          continue;=20
+       }
+
+
+
+       // http://clac.cs.columbia.edu:41782/mdb-lookup?key=3Dhello=20
+       if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){
+
+           printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncmp(=
requestURI, "/mdb-lookup?key=3D",16 ));
+
+
+        /*
+        FILE *fd_clntsock;  // fp_servsock
+        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // fp=
_servsock =3D fdopen(servsock, "r")=20
+            die("fdopen failed");
+        }*/
+
+
+        // printf("why2");
+        // fflush(stdout);
+
+
+        /*
+           int html_size;=20
+           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) > 0=
 ){
+             printf("html: \n%s", buf);
+           }  =20
+
+
+        printf("||||||||||||||||||||||||||");
+        fflush(stdout);
+       =20
+        FILE *fd_clntsock_1;  // fp_servsock
+        if ((fd_clntsock_1 =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // =
fp_servsock =3D fdopen(servsock, "r")=20
+            die("fdopen failed");
+        }
+
+
+           //=20
+           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=
=3D 0 ){
+
+               printf("html: \n%s", buf);
+
+           }*/  =20
+       =20
+
+=20
+     =20
+           /*
+           // int html_size ;=20
+           // int i =3D 0;
+
+
+           // printf("\n%ld, %s \n", fread(buf,1,30,fd_clntsock), buf );=
=20
+           // printf("\n%ld\n", fread(buf,1,sizeof(buf),fd_clntsock));=20
+
+           // while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) =
>  0 ){
+
+           printf("_____ %d\n", i++);
+           fflush(stdout);
+             printf("html: \n%s", buf);
+             printf("88888 %d\n", i );
+             fflush(stdout);
+             break;
+            =20
+           } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =
=E4=BD=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=
=85=A5size? =20
+
+           /* // =E6=A3=80=E6=9F=A5 header
+           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
+               printf("\nHeaders: %s\n", buf);
+           }
+           fgets(buf,sizeof(buf), fd_clntsock);
+           printf("$$$$$$$$ %s", buf);
+
+           fgets(buf,sizeof(buf), fd_clntsock);
+           printf("*** $$$$$$$$ %s", buf);
+           */
+
+
+       =20
+        // printf("\n(%s)\n",requestURI);
+
+        for(int i=3D0; i<16; i++){
+            requestURI++;
+        }
+        strcat(requestURI, "\n");
+        // printf("\n(%s)\n",requestURI);
+
+
+
+        // =E6=88=91=E8=A6=81=E6=8A=8A=E4=B8=9C=E8=A5=BF search key send =
=E7=BB=99 mdb-lookup-server
+        //
+
+
+        printf("\n(%s)\n",requestURI);
+
+       // =E6=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=
=E4=BA=86=EF=BC=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2
+   =20
+    //printf("=1A=1A")   =20
+    if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strlen(requ=
estURI)) {
+	die("send failed");
+    }
+
+
+
+    /*
+           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
+               printf("\nHeaders: %s\n", buf);
+           }
+           */
+           // fgets(buf,sizeof(buf), fd_mdb);
+           // printf("$$$$$$$$ %s", buf);
+
+
+    /*
+           printf("\n\n 11111111111111111111111111111111------------------=
--------\n\n");
+
+           fgets(buf,sizeof(buf), fd_mdb);
+           printf("*** $$$$$$$$ %s", buf);
+
+           printf("\n\n 22222222222222222222222222222222------------------=
--------\n\n");
+
+           fgets(buf,sizeof(buf), fd_mdb);
+           printf("*** $$$$$$$$ %s", buf);
+      */
+
+
+
+
+  /*     =20
+    char html[10000];
+    strcpy(html,
+        "HTTP 200 OK\r\n"      =20
+        "\r\n"
+              =20
+        "<h1>mdb-lookup</h1>\n"
+              =20
+        "<p>\n"
+              =20
+        "<form method=3DGET action=3D/mdb-lookup>\n"
+              =20
+        "lookup: <input type=3Dtext name=3Dkey>\n"
+              =20
+        "<input type=3Dsubmit>\n"
+              =20
+        "</form>\n"
+              =20
+        "<p>\n"
+
+        "<p><table border>\n");
+
+
+        printf("0000000000000000000000000000000000000000000000000000000000=
000000\n");
+    char row[100];
+    while(fgets(buf, sizeof(buf), fd_mdb)!=3D NULL ){
+
+        if( strcmp(buf, "\n") =3D=3D 0){
+            printf("\n\n end \n\n");
+            break;
+        }
+
+        snprintf(row, sizeof(row), "<tr><td> %s\n", buf);
+        printf("%s\n", row );
+        strcat(html, row);
+
+     =20
+       =20
+    }
+
+    strcat(html, "</table>\n</body>\n</html>");
+
+
+    printf("\n\n%s\n\n", html);
+*/
+
+
+
+   =20
+    strcpy(buf,
+        "HTTP 200 OK\r\n"      =20
+        "\r\n"
+              =20
+        "<h1>mdb-lookup</h1>\n"
+              =20
+        "<p>\n"
+              =20
+        "<form method=3DGET action=3D/mdb-lookup>\n"
+              =20
+        "lookup: <input type=3Dtext name=3Dkey>\n"
+              =20
+        "<input type=3Dsubmit>\n"
+              =20
+        "</form>\n"
+              =20
+        "<p>\n"
+
+        "<p><table border>\n");
+
+   =20
+
+          =20
+    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+   =20
+        perror("send content failed");
+
+        break;
+
+    }
+
+    char row[100];
+    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
+
+        if( strcmp(row, "\n") =3D=3D 0){
+            printf("\n\n end \n\n");
+            break;
+        }
+
+
+        snprintf(buf, sizeof(buf), "<tr><td> %s\n", row);
+        //printf("%s\n", row) ;
+        //strcat(html, row);
+
+
+    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+   =20
+        perror("send content failed");
+
+        break;
+
+    }
+    }
+
+
+
+
+
+
+
+
+
+
+        continue;=20
+       }
+
+
+
+      =20
+       ////////////////////////////////////////////
+
+
+
+
+
+
+
+
+
+
+
+       // check requestURI !!!!!!!!!!!!!!!!
+       //
+      =20
+       // check web_root
+
+
+
+
+
+
+
+
+
+     =20
+
+
+
+
+
+       // printf("\nweb_root %s\n", web_root);
+
+
+       // log print out
+       fprintf(stderr, "\"%s %s %s\" %d OK\n",method, requestURI, httpVers=
ion, 200);
+
+       // retrive the file -- requestURI
+       // 1. make path
+       char full_path[100];  // should not be " char *full_path;" has to h=
ave len
+       strcpy(full_path, web_root);
+       strcat(full_path, requestURI);  // char *file_path =3D strcat(web_r=
oot, requestURI);
+
+
+
+       // int stat(const char *path, struct stat *buf);
+       // success returns 0 & fill buf, error return -1
+       // reference: https://www.ibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_7=
3/apis/stat.htm=20
+       struct stat status;
+       char full_path_1[strlen(full_path)];
+       strcpy(full_path_1, full_path);
+
+
+
+       // check ending char of path is '/' or not, return 400 error code  =
 =20
+       if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
+           // if ending with '/', attach index.html
+           strcat(full_path_1, "index.html");
+           // printf("***********%s\n", full_path_1);
+
+       }
+       /*
+       else{
+           // else send 400 error code
+           char *html =3D cook_html(400);
+           printf("html : \n%s",html);
+           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
+               free(html);
+               die("send content failed");
+           }
+           free(html);=20
+           fclose(fd_clntsock);
+           continue;
+       }*/
+
+
+
+       // if path/file exists, proceeds, else =20
+       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds -- file exists=
, then check directory/file
+
+           printf("**********  %s", full_path_1 );
+
+           // full_path ends with / or not
+           // printf("***********%s\n",full_path_1);
+           // printf("%c, %c\n", '/',full_path_1[strlen(full_path_1)-1] );
+           // if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
+           //        strcat(full_path_1, "index.html");
+           //        // printf("***********%s\n", full_path_1);
+           // }
+       }else{
+
+           //printf("\nfail does not exists:  %s\n", full_path_1 );
+
+           char *html =3D cook_html(404);
+           printf("html : \n%s",html);
+           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
+               //free(html);
+               die("send content failed");
+           }
+           free(html);=20
+           fclose(fd_clntsock);
+           continue;
+       }=20
+
+       // 2. send response headers
+       snprintf(buf, sizeof(buf),=20
+               "HTTP/1.0 200 OK\r\n"
+               "\r\n");
+
+       // 3. open file, read & send
+       // printf("\nfull_path_1: %s\n", full_path_1);
+       // printf("\nstat code: %d\n", stat(full_path_1, &status));
+       FILE *file_requested =3D fopen(full_path_1, "rb");
+       if( file_requested =3D=3D NULL)=20
+               die("fail open file");
+       int size_read;
+
+       size_read =3D strlen(buf); // should be 19, header=20
+       do{
+           printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
+           if( send(clntsock, buf, size_read, 0) !=3D size_read ){
+               perror("send content failed");
+               break;
+           }
+       }while(( size_read =3D fread(buf,1, sizeof(buf), file_requested)) >=
 0);
+
+
+       //if(feof(file_requested) )
+       //    printf("file has not been fully read");
+
+       fclose(file_requested);
+       fclose(fd_clntsock);
+
+       fclose(fd_mdb);
+
+
+    }// while (1)
+
+    return 0;
+}
--=20
2.17.1


=46rom dbe85f545b93c3d04f51b3eae63e7c4adce22c71 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 19:33:36 -0400
Subject: [PATCH 2/6] add makefile

---
 Makefile | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)
 create mode 100644 Makefile

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..a95373e
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,29 @@
+
+#
+# Makefile for lab 7, part 2
+#
+
+CC  =3D gcc
+CXX =3D g++
+
+CFLAGS   =3D -g -Wall $(INCLUDES)
+CXXFLAGS =3D -g -Wall $(INCLUDES)
+
+
+.PHONY: default
+default: http-server=20
+
+# header dependency
+## mdb-lookup-server.o: mdb.h
+
+
+
+.PHONY: clean
+clean:
+	rm -f *.o *~ a.out core http-server
+
+.PHONY: all
+all: clean default
+
+
+
--=20
2.17.1


=46rom 997c897e237b0e985f14ca4ea8e49e938dadd939 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 21:33:39 -0400
Subject: [PATCH 3/6] finish part2

---
 http-server.c | 500 ++++++++++++++------------------------------------
 1 file changed, 141 insertions(+), 359 deletions(-)

diff --git a/http-server.c b/http-server.c
index 3e57ef6..befd329 100644
--- a/http-server.c
+++ b/http-server.c
@@ -162,10 +162,10 @@ int main(int argc, char **argv) {
=20
     // +-------------------------------------------
=20
-    int count =3D 0;
+    //int count =3D 0;
     while (1) {
=20
-        printf("\n$ %d \n", count++);
+        //printf("\n$ %d \n", count++);
=20
         char buf[4096];
=20
@@ -234,17 +234,6 @@ int main(int argc, char **argv) {
=20
=20
=20
-/*
-           int html_size ;=20
-           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) !=
=3D 0 ){
-             printf("html: \n%s", buf);
-           }=20
-           fflush(stdout);
- =20
-*/
-          =20
-
-
         // Now parse method and httpVersion first, and then requestURI.=20
         // 1. check GET keyword
         if (strncmp(method, "GET", 3) !=3D 0 ){ //=20
@@ -254,15 +243,17 @@ int main(int argc, char **argv) {
             // as long as program keep running, no need to close/free sinc=
e we do that at the end, unless die program.
=20
             // send error 501 http to clnt & output log
-            fprintf(stderr, "%d\n", 501);=20
+            fprintf(stderr, "%d Not Implemented\n", 501);=20
=20
             char *html_501 =3D=20
-                "HTTP/1.0 501 Not Implemented"
+                "HTTP/1.0 501 Not Implemented\r\n\r\n"
                 "<html><body><h1>501 Not Implemented</h1></body></html>";
=20
             //printf("html : \n%s",html);
             if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
-                die("send content failed");
+               fclose(fd_mdb);
+               fclose(fd_clntsock);=20
+               die("send content failed");
             }
=20
             continue;
@@ -271,58 +262,59 @@ int main(int argc, char **argv) {
         // 2. check whether http 1.0 or 1.1 protocol
         if (strncmp("HTTP/1.0", httpVersion, 8) !=3D 0 && strncmp("HTTP/1.=
1", httpVersion, 8) !=3D 0) {
        =20
-            fprintf(stderr, "\"%s %s %s\" %d\n",method, requestURI, httpVe=
rsion, 501);=20
-         =20
-            fclose(fd_clntsock);
-          =20
+            fprintf(stderr, "%d Not Implemented\n", 501);=20
+            char *html_501 =3D=20
+                "HTTP/1.0 501 Not Implemented\r\n\r\n"
+                "<html><body><h1>501 Not Implemented</h1></body></html>";
=20
-          =20
-            char *html =3D cook_html(501);
-          =20
-            //size =3D snprintf(buf, sizeof(buf),"%s" , html);
-          =20
-            printf("html : \n%s",html);
-          =20
-            if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
-         =20
-                //free(html);
-         =20
-                die("send content failed");
-         =20
+            if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send content failed");
             }
-         =20
-            free(html);=20
-         =20
+
             continue;
-      =20
         }
=20
=20
=20
+        // 3. check URI starts with /, not ended with /..  not contains /.=
=2E/
=20
+        //printf("\n||||||| %s\n",requestURI);
+        if (strncmp("/", requestURI, 1) !=3D 0 || strstr(requestURI, "/../=
") || strstr(requestURI, "/..") )  {
+       =20
+            fprintf(stderr, "%d Bad Request\n", 400);=20
+            char *html_400 =3D=20
+                "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>";
+
+            if (send(clntsock, html_400, strlen(html_400), 0) !=3D strlen(=
html_400)){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send content failed");
+            }
=20
+            continue;
+        }
=20
=20
+        // printf("2333333333333333333333333333"); fflush(stdout);
=20
=20
=20
-
-
-
-
-
-
+        =20
=20
        ///////////////   part 2 b
=20
=20
-           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
+           //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
=20
        // http://clac.cs.columbia.edu:41782/mdb-lookup=20
        if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){
=20
-           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
-
+           //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
+      =20
+           fprintf(stderr, "200 OK\n");
            const char *form =3D
                "HTTP 200 OK\r\n"
                "\r\n"
@@ -335,296 +327,103 @@ int main(int argc, char **argv) {
                "<p>\n";
=20
            if (send(clntsock, form, strlen(form), 0) !=3D strlen(form) ){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
                die("send content failed");
            }
=20
-
-           printf("\n\n send, you should see search page  \n\n");
-
-
-          continue;=20
+           //printf("\n\n send, you should see search page  \n\n");
+           continue;=20
+     =20
        }
=20
=20
=20
+     =20
        // http://clac.cs.columbia.edu:41782/mdb-lookup?key=3Dhello=20
        if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){
=20
-           printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncmp(=
requestURI, "/mdb-lookup?key=3D",16 ));
-
-
-        /*
-        FILE *fd_clntsock;  // fp_servsock
-        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // fp=
_servsock =3D fdopen(servsock, "r")=20
-            die("fdopen failed");
-        }*/
-
-
-        // printf("why2");
-        // fflush(stdout);
-
-
-        /*
-           int html_size;=20
-           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) > 0=
 ){
-             printf("html: \n%s", buf);
-           }  =20
-
+           //printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncm=
p(requestURI, "/mdb-lookup?key=3D",16 ));
+     =20
+           // printf("\n(%s)\n",requestURI);
=20
-        printf("||||||||||||||||||||||||||");
-        fflush(stdout);
        =20
-        FILE *fd_clntsock_1;  // fp_servsock
-        if ((fd_clntsock_1 =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // =
fp_servsock =3D fdopen(servsock, "r")=20
-            die("fdopen failed");
-        }
-
-
-           //=20
-           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=
=3D 0 ){
-
-               printf("html: \n%s", buf);
-
-           }*/  =20
+           for(int i=3D0; i<16; i++){
+          =20
+               requestURI++;
        =20
-
-=20
-     =20
-           /*
-           // int html_size ;=20
-           // int i =3D 0;
-
-
-           // printf("\n%ld, %s \n", fread(buf,1,30,fd_clntsock), buf );=
=20
-           // printf("\n%ld\n", fread(buf,1,sizeof(buf),fd_clntsock));=20
-
-           // while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) =
>  0 ){
-
-           printf("_____ %d\n", i++);
-           fflush(stdout);
-             printf("html: \n%s", buf);
-             printf("88888 %d\n", i );
-             fflush(stdout);
-             break;
-            =20
-           } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =
=E4=BD=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=
=85=A5size? =20
-
-           /* // =E6=A3=80=E6=9F=A5 header
-           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
-               printf("\nHeaders: %s\n", buf);
            }
-           fgets(buf,sizeof(buf), fd_clntsock);
-           printf("$$$$$$$$ %s", buf);
-
-           fgets(buf,sizeof(buf), fd_clntsock);
-           printf("*** $$$$$$$$ %s", buf);
-           */
-
-
+          =20
+      =20
+           strcat(requestURI, "\n");
        =20
-        // printf("\n(%s)\n",requestURI);
-
-        for(int i=3D0; i<16; i++){
-            requestURI++;
-        }
-        strcat(requestURI, "\n");
-        // printf("\n(%s)\n",requestURI);
-
+           // printf("\n(%s)\n",requestURI);
=20
+           // send   =20
=20
-        // =E6=88=91=E8=A6=81=E6=8A=8A=E4=B8=9C=E8=A5=BF search key send =
=E7=BB=99 mdb-lookup-server
-        //
-
-
-        printf("\n(%s)\n",requestURI);
-
-       // =E6=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=
=E4=BA=86=EF=BC=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2
    =20
-    //printf("=1A=1A")   =20
-    if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strlen(requ=
estURI)) {
-	die("send failed");
-    }
-
-
-
-    /*
-           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
-               printf("\nHeaders: %s\n", buf);
+           if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strl=
en(requestURI)) {
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send failed");
            }
-           */
-           // fgets(buf,sizeof(buf), fd_mdb);
-           // printf("$$$$$$$$ %s", buf);
-
-
-    /*
-           printf("\n\n 11111111111111111111111111111111------------------=
--------\n\n");
-
-           fgets(buf,sizeof(buf), fd_mdb);
-           printf("*** $$$$$$$$ %s", buf);
-
-           printf("\n\n 22222222222222222222222222222222------------------=
--------\n\n");
-
-           fgets(buf,sizeof(buf), fd_mdb);
-           printf("*** $$$$$$$$ %s", buf);
-      */
-
-
-
-
-  /*     =20
-    char html[10000];
-    strcpy(html,
-        "HTTP 200 OK\r\n"      =20
-        "\r\n"
-              =20
-        "<h1>mdb-lookup</h1>\n"
-              =20
-        "<p>\n"
-              =20
-        "<form method=3DGET action=3D/mdb-lookup>\n"
-              =20
-        "lookup: <input type=3Dtext name=3Dkey>\n"
-              =20
-        "<input type=3Dsubmit>\n"
-              =20
-        "</form>\n"
-              =20
-        "<p>\n"
-
-        "<p><table border>\n");
-
-
-        printf("0000000000000000000000000000000000000000000000000000000000=
000000\n");
-    char row[100];
-    while(fgets(buf, sizeof(buf), fd_mdb)!=3D NULL ){
-
-        if( strcmp(buf, "\n") =3D=3D 0){
-            printf("\n\n end \n\n");
-            break;
-        }
-
-        snprintf(row, sizeof(row), "<tr><td> %s\n", buf);
-        printf("%s\n", row );
-        strcat(html, row);
-
-     =20
-       =20
-    }
-
-    strcat(html, "</table>\n</body>\n</html>");
-
-
-    printf("\n\n%s\n\n", html);
-*/
-
-
-
-   =20
-    strcpy(buf,
-        "HTTP 200 OK\r\n"      =20
-        "\r\n"
-              =20
-        "<h1>mdb-lookup</h1>\n"
-              =20
-        "<p>\n"
-              =20
-        "<form method=3DGET action=3D/mdb-lookup>\n"
-              =20
-        "lookup: <input type=3Dtext name=3Dkey>\n"
-              =20
-        "<input type=3Dsubmit>\n"
-              =20
-        "</form>\n"
-              =20
-        "<p>\n"
-
-        "<p><table border>\n");
-
+         =20
+      =20
+           fprintf(stderr, "200 OK\n");
+           strcpy(buf,
+                   "HTTP/1.0 200 OK\r\n"    =20
+                   "\r\n"
+                   "<h1>mdb-lookup</h1>\n"
+                   "<p>\n"
+                   "<form method=3DGET action=3D/mdb-lookup>\n"
+                   "lookup: <input type=3Dtext name=3Dkey>\n"
+                   "<input type=3Dsubmit>\n"
+                   "</form>\n"
+                   "<p>\n"
+                   "<p><table border>\n");
    =20
+           if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send contenct failed 2b)");
+           }
=20
+  =20
           =20
-    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
-   =20
-        perror("send content failed");
-
-        break;
-
-    }
-
-    char row[100];
-    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
-
-        if( strcmp(row, "\n") =3D=3D 0){
-            printf("\n\n end \n\n");
-            break;
-        }
-
-
-        snprintf(buf, sizeof(buf), "<tr><td> %s\n", row);
-        //printf("%s\n", row) ;
-        //strcat(html, row);
-
+         =20
+          =20
+           char row[100];
+         =20
+           int even =3D 0;
+          =20
+           while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
+               if( strcmp(row, "\n") =3D=3D 0){
+                   //printf("\n\n end \n\n");
+                   break;
+               }
=20
-    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+               if(even++%2 =3D=3D 0){
+              =20
+                   snprintf(buf, sizeof(buf), "<tr><td> %s\n", row);
+               }else{
+                   snprintf(buf, sizeof(buf), "<tr><td  bgcolor=3Dyellow> =
%s\n", row);
+
+               }
+               if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+                   fclose(fd_mdb);
+                   fclose(fd_clntsock);
+                   die("send contenct failed 2b)");
+               }
    =20
-        perror("send content failed");
-
-        break;
-
-    }
-    }
-
-
-
-
-
-
-
-
+           }
=20
=20
         continue;=20
-       }
-
-
-
-      =20
-       ////////////////////////////////////////////
+       }// end if ./mdb-lookup?key=3D
=20
=20
=20
-
-
-
-
-
-
-
-
-       // check requestURI !!!!!!!!!!!!!!!!
-       //
-      =20
-       // check web_root
-
-
-
-
-
-
-
-
-
-     =20
-
-
-
-
-
-       // printf("\nweb_root %s\n", web_root);
-
-
-       // log print out
-       fprintf(stderr, "\"%s %s %s\" %d OK\n",method, requestURI, httpVers=
ion, 200);
+       // part2 a) continue  //////////
=20
        // retrive the file -- requestURI
        // 1. make path
@@ -633,7 +432,6 @@ int main(int argc, char **argv) {
        strcat(full_path, requestURI);  // char *file_path =3D strcat(web_r=
oot, requestURI);
=20
=20
-
        // int stat(const char *path, struct stat *buf);
        // success returns 0 & fill buf, error return -1
        // reference: https://www.ibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_7=
3/apis/stat.htm=20
@@ -643,89 +441,73 @@ int main(int argc, char **argv) {
=20
=20
=20
-       // check ending char of path is '/' or not, return 400 error code  =
 =20
+       // check ending char of path is '/', if true, concat  index.html=20
        if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
-           // if ending with '/', attach index.html
            strcat(full_path_1, "index.html");
-           // printf("***********%s\n", full_path_1);
-
        }
-       /*
-       else{
-           // else send 400 error code
-           char *html =3D cook_html(400);
-           printf("html : \n%s",html);
-           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
-               free(html);
-               die("send content failed");
-           }
-           free(html);=20
-           fclose(fd_clntsock);
-           continue;
-       }*/
-
-
-
+      =20
+      =20
        // if path/file exists, proceeds, else =20
-       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds -- file exists=
, then check directory/file
-
-           printf("**********  %s", full_path_1 );
+       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds -- stat return=
 none 0,  file not exists, then check directory/file
=20
-           // full_path ends with / or not
-           // printf("***********%s\n",full_path_1);
-           // printf("%c, %c\n", '/',full_path_1[strlen(full_path_1)-1] );
-           // if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
-           //        strcat(full_path_1, "index.html");
-           //        // printf("***********%s\n", full_path_1);
-           // }
+           //printf("**********  %s", full_path_1 );
+      =20
        }else{
=20
            //printf("\nfail does not exists:  %s\n", full_path_1 );
+            fprintf(stderr, "%d Not Found\n", 404);=20
+            char *html_404 =3D=20
+                "HTTP/1.0 404 Not Found\r\n\r\n"
+                "<html><body><h1>404 Not Found</h1></body></html>";
+
+            if (send(clntsock, html_404, strlen(html_404), 0) !=3D strlen(=
html_404)){
+                   fclose(fd_mdb);
+                   fclose(fd_clntsock);
+                   die("send content failed");
+            }
=20
-           char *html =3D cook_html(404);
-           printf("html : \n%s",html);
-           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
-               //free(html);
-               die("send content failed");
-           }
-           free(html);=20
-           fclose(fd_clntsock);
-           continue;
+            continue;
        }=20
=20
-       // 2. send response headers
+
+       fprintf(stderr, "200 OK\n");
+
+
+       // 2. prepare response headers
        snprintf(buf, sizeof(buf),=20
                "HTTP/1.0 200 OK\r\n"
                "\r\n");
=20
        // 3. open file, read & send
-       // printf("\nfull_path_1: %s\n", full_path_1);
-       // printf("\nstat code: %d\n", stat(full_path_1, &status));
        FILE *file_requested =3D fopen(full_path_1, "rb");
-       if( file_requested =3D=3D NULL)=20
+       if( file_requested =3D=3D NULL){=20
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
                die("fail open file");
+       }
        int size_read;
=20
        size_read =3D strlen(buf); // should be 19, header=20
        do{
-           printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
+           //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
            if( send(clntsock, buf, size_read, 0) !=3D size_read ){
-               perror("send content failed");
-               break;
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send content failed");
            }
        }while(( size_read =3D fread(buf,1, sizeof(buf), file_requested)) >=
 0);
=20
=20
-       //if(feof(file_requested) )
-       //    printf("file has not been fully read");
-
        fclose(file_requested);
        fclose(fd_clntsock);
=20
-       fclose(fd_mdb);
-
-
+       fprintf(stdout, "\n");
     }// while (1)
=20
+      =20
+   =20
+
+=20
+    fclose(fd_mdb);
     return 0;
 }
--=20
2.17.1


=46rom 58ac4b4732ec355c52b3dab752eb8e3684cea079 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 22:22:07 -0400
Subject: [PATCH 4/6] finish test, part2 ab both work on firefox

---
 http-server.c | 78 +++++++++------------------------------------------
 1 file changed, 14 insertions(+), 64 deletions(-)

diff --git a/http-server.c b/http-server.c
index befd329..7387137 100644
--- a/http-server.c
+++ b/http-server.c
@@ -29,30 +29,6 @@ static void printUsage() {
     exit(1);
 }
=20
-char* cook_html(int code){ // char* content
-
-    char *html =3D (char *) malloc(1000 * sizeof(char));
-
-    char *error_code_prompt;
-    if(code =3D=3D 501)
-        error_code_prompt =3D  "Not Implemented";
-    if(code =3D=3D 400)
-        error_code_prompt =3D  "Bad Request";
-    if(code =3D=3D 404)
-        error_code_prompt =3D "Not Found";
-
-
-    snprintf(html, 1000,  //sizeof(html),=20
-            "HTTP/1.0 %d %s\r\n"
-            "\r\n"
-            //"<html>\r\n<body>\r\n<h1>%d %s</h1>\r\n</body>\r\n</html>\r\=
n",
-            "<html><body><h1>%d %s</h1></body></html>",
-            code, error_code_prompt, code, error_code_prompt);
-    printf("\n\n%s\\n\n", html);
-    return html;
-}
-
-
=20
=20
=20
@@ -115,7 +91,6 @@ int main(int argc, char **argv) {
     int mdb_sock;
     struct sockaddr_in mdb_serverAddr;
     struct hostent *mdb_he;
-    // char buf_2[BUF_SIZE];                    // necessary?
=20
     =20
     // get mdb-lookup server ip from mdb-server name
@@ -124,15 +99,6 @@ int main(int argc, char **argv) {
     }
     mdb_serverIP =3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);
=20
-    /* for debugging
-       printf("1: %s\n", mdb_serverName);
-       printf("2: %s\n", mdb_serverIP);
-       printf("3: %s\n", mdb_serverPort);
-       printf("4: %s\n", filePath);
-       printf("5: %s\n", fname);
-       */
-
-
     // create socket
     if ((mdb_sock =3D socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
 	die("socket failed");
@@ -300,23 +266,17 @@ int main(int argc, char **argv) {
=20
         // printf("2333333333333333333333333333"); fflush(stdout);
=20
-
-
         =20
=20
        ///////////////   part 2 b
=20
-
-           //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
-
        // http://clac.cs.columbia.edu:41782/mdb-lookup=20
        if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){
=20
            //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
-      =20
            fprintf(stderr, "200 OK\n");
            const char *form =3D
-               "HTTP 200 OK\r\n"
+               "HTTP/1.0 200 OK\r\n"
                "\r\n"
                "<h1>mdb-lookup</h1>\n"
                "<p>\n"
@@ -333,35 +293,24 @@ int main(int argc, char **argv) {
            }
=20
            //printf("\n\n send, you should see search page  \n\n");
+           fclose(fd_clntsock);
            continue;=20
      =20
        }
=20
-
-
      =20
        // http://clac.cs.columbia.edu:41782/mdb-lookup?key=3Dhello=20
        if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){
=20
            //printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncm=
p(requestURI, "/mdb-lookup?key=3D",16 ));
-     =20
            // printf("\n(%s)\n",requestURI);
-
-       =20
            for(int i=3D0; i<16; i++){
-          =20
                requestURI++;
-       =20
            }
-          =20
-      =20
            strcat(requestURI, "\n");
        =20
            // printf("\n(%s)\n",requestURI);
-
            // send   =20
-
-   =20
            if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strl=
en(requestURI)) {
                fclose(fd_mdb);
                fclose(fd_clntsock);
@@ -388,14 +337,8 @@ int main(int argc, char **argv) {
                die("send contenct failed 2b)");
            }
=20
-  =20
-          =20
-         =20
-          =20
            char row[100];
-         =20
            int even =3D 0;
-          =20
            while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
                if( strcmp(row, "\n") =3D=3D 0){
                    //printf("\n\n end \n\n");
@@ -417,8 +360,8 @@ int main(int argc, char **argv) {
    =20
            }
=20
-
-        continue;=20
+           fclose(fd_clntsock);
+           continue;=20
        }// end if ./mdb-lookup?key=3D
=20
=20
@@ -454,8 +397,15 @@ int main(int argc, char **argv) {
       =20
        }else{
=20
+           printf("**********  %s", full_path_1 );
+           fprintf(stderr, "%d Not Found\n", 404);=20
+           if( strcmp(full_path,"/mnt/disks/students221/yz4004/html/cs3157=
/tng/favicon.ico" ) =3D=3D 0 ){
+
+               break;
+           }
+
+
            //printf("\nfail does not exists:  %s\n", full_path_1 );
-            fprintf(stderr, "%d Not Found\n", 404);=20
             char *html_404 =3D=20
                 "HTTP/1.0 404 Not Found\r\n\r\n"
                 "<html><body><h1>404 Not Found</h1></body></html>";
@@ -492,6 +442,7 @@ int main(int argc, char **argv) {
            //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
            if( send(clntsock, buf, size_read, 0) !=3D size_read ){
                fclose(fd_mdb);
+               fclose(file_requested);
                fclose(fd_clntsock);
                die("send content failed");
            }
@@ -501,10 +452,9 @@ int main(int argc, char **argv) {
        fclose(file_requested);
        fclose(fd_clntsock);
=20
-       fprintf(stdout, "\n");
+       //fprintf(stdout, "\n");
     }// while (1)
=20
-      =20
    =20
=20
 =20
--=20
2.17.1


=46rom edbc31cfe47c1bfb59c17b691baed94f59b45d78 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 22:24:34 -0400
Subject: [PATCH 5/6] modify README

---
 README.txt | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/README.txt b/README.txt
index 66dfd3e..e571053 100644
--- a/README.txt
+++ b/README.txt
@@ -9,3 +9,10 @@ The description should indicate whether your solution for =
the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+
+
+Yixuan Zou
+yz4004
+lab7
+
+part2 a) b) both work on firefox.
--=20
2.17.1


=46rom 2195addaa7c9f6178a534a0e51477319b2fa53fc Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 23:44:57 -0400
Subject: [PATCH 6/6] modify error prompt

---
 http-server.c | 79 +++++++++++++++++++++++++++++++++++----------------
 1 file changed, 54 insertions(+), 25 deletions(-)

diff --git a/http-server.c b/http-server.c
index 7387137..ec99309 100644
--- a/http-server.c
+++ b/http-server.c
@@ -142,7 +142,7 @@ int main(int argc, char **argv) {
=20
         if ((clntsock =3D accept(servsock,
                         (struct sockaddr * ) &clntaddr, &clntlen)) < 0){
-            //perror("next clinet");
+            perror("clinet crash");
             //die("accept fail");
             continue;=20
         }
@@ -164,11 +164,16 @@ int main(int argc, char **argv) {
         char requestLine[1000];=20
         if(fgets(requestLine, sizeof(requestLine), fd_clntsock) =3D=3D NUL=
L ){
             // fail to read request line, (maybe clnt crash/close connecti=
on -- fail to send request), skip current clnt to next one.
-            fprintf(stderr, "clnt crashes");
-            //fclose(fd_clntsock); no need
+            // fprintf(stderr, "clnt crashes");
+            fclose(fd_clntsock); //no need?
             continue;
         }
=20
+       // check fgets error=20
+       if (ferror(fd_clntsock)){
+           perror("fd_clntsock error");
+       }
+
         // parse browser http request line
         char *token_separators =3D "\t \r\n"; // tab, space, new line
         char *method =3D strtok(requestLine, token_separators);
@@ -217,9 +222,10 @@ int main(int argc, char **argv) {
=20
             //printf("html : \n%s",html);
             if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);=20
-               die("send content failed");
+               //die("send content failed");
+               perror("send content failed");
             }
=20
             continue;
@@ -234,9 +240,10 @@ int main(int argc, char **argv) {
                 "<html><body><h1>501 Not Implemented</h1></body></html>";
=20
             if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);
-               die("send content failed");
+               //die("send content failed");
+               perror("send content failed");
             }
=20
             continue;
@@ -255,9 +262,10 @@ int main(int argc, char **argv) {
                 "<html><body><h1>400 Bad Request</h1></body></html>";
=20
             if (send(clntsock, html_400, strlen(html_400), 0) !=3D strlen(=
html_400)){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);
-               die("send content failed");
+               //die("send content failed");
+               perror("send content failed");
             }
=20
             continue;
@@ -287,9 +295,10 @@ int main(int argc, char **argv) {
                "<p>\n";
=20
            if (send(clntsock, form, strlen(form), 0) !=3D strlen(form) ){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);
-               die("send content failed");
+               //die("send content failed");
+               perror("send content failed");
            }
=20
            //printf("\n\n send, you should see search page  \n\n");
@@ -312,9 +321,10 @@ int main(int argc, char **argv) {
            // printf("\n(%s)\n",requestURI);
            // send   =20
            if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strl=
en(requestURI)) {
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);
-               die("send failed");
+               //die("send failed");
+               perror("send failed");
            }
          =20
       =20
@@ -332,9 +342,10 @@ int main(int argc, char **argv) {
                    "<p><table border>\n");
    =20
            if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);
-               die("send contenct failed 2b)");
+               //die("send contenct failed 2b)");
+               perror("send content failed");
            }
=20
            char row[100];
@@ -353,13 +364,18 @@ int main(int argc, char **argv) {
=20
                }
                if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
-                   fclose(fd_mdb);
+                   //fclose(fd_mdb);
                    fclose(fd_clntsock);
-                   die("send contenct failed 2b)");
+                   //die("send contenct failed 2b)");
+                   perror("send content failed");
                }
    =20
+           } // end while, fget from fb_mdb
+      =20
+           // check fgets fd_mdb=20
+           if (ferror(fd_mdb)){
+               perror("fgets fd_mdb error");
            }
-
            fclose(fd_clntsock);
            continue;=20
        }// end if ./mdb-lookup?key=3D
@@ -397,7 +413,7 @@ int main(int argc, char **argv) {
       =20
        }else{
=20
-           printf("**********  %s", full_path_1 );
+           //printf("**********  %s", full_path_1 );
            fprintf(stderr, "%d Not Found\n", 404);=20
            if( strcmp(full_path,"/mnt/disks/students221/yz4004/html/cs3157=
/tng/favicon.ico" ) =3D=3D 0 ){
=20
@@ -411,9 +427,10 @@ int main(int argc, char **argv) {
                 "<html><body><h1>404 Not Found</h1></body></html>";
=20
             if (send(clntsock, html_404, strlen(html_404), 0) !=3D strlen(=
html_404)){
-                   fclose(fd_mdb);
+                   //fclose(fd_mdb);
                    fclose(fd_clntsock);
-                   die("send content failed");
+                   //die("send content failed");
+                   perror("send content failed");
             }
=20
             continue;
@@ -441,14 +458,27 @@ int main(int argc, char **argv) {
        do{
            //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
            if( send(clntsock, buf, size_read, 0) !=3D size_read ){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(file_requested);
-               fclose(fd_clntsock);
-               die("send content failed");
+               perror("send content failed");
+               break;
+               //fclose(fd_clntsock);
+               //die("send content failed");
            }
        }while(( size_read =3D fread(buf,1, sizeof(buf), file_requested)) >=
 0);
=20
=20
+       // fread() returns 0 on EOF or on error
+       // so we need to check if there was an error.
+       if (ferror(file_requested)){
+           //fclose(fd_mdb);
+           fclose(fd_clntsock);
+           //die("fread failed");
+           perror("fread failed");
+       }
+  =20
+      =20
+
        fclose(file_requested);
        fclose(fd_clntsock);
=20
@@ -456,7 +486,6 @@ int main(int argc, char **argv) {
     }// while (1)
=20
    =20
-
 =20
     fclose(fd_mdb);
     return 0;
--=20
2.17.1


--/04w6evG8XlLl3ft
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab7.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 9c1b686e24e076e8292f46bee5102b36e24c340f Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Thu, 5 May 2022 19:33:12 -=
0400=0ASubject: [PATCH 1/6] draft 1=0A=0A---=0A http-server.c | 731 +++++++=
+++++++++++++++++++++++++++++++++++++++++++=0A 1 file changed, 731 insertio=
ns(+)=0A create mode 100644 http-server.c=0A=0Adiff --git a/http-server.c b=
/http-server.c=0Anew file mode 100644=0Aindex 0000000..3e57ef6=0A--- /dev/n=
ull=0A+++ b/http-server.c=0A@@ -0,0 +1,731 @@=0A+/*=0A+ * http-server.c=0A+=
 */=0A+=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <string.h>=
=0A+#include <sys/types.h>=0A+#include <sys/socket.h>=0A+#include <arpa/ine=
t.h>=0A+#include <unistd.h>=0A+#include <netdb.h>=0A+=0A+#include <assert.h=
>  =0A+#include <sys/wait.h>  =0A+#include <sys/stat.h>=0A+=0A+=0A+#define =
BUF_SIZE 4096=0A+=0A+static void die(const char *msg) {=0A+    perror(msg);=
=0A+    exit(1);=0A+}=0A+=0A+static void printUsage() {=0A+    fprintf(stde=
rr, "usage: http-server <server_port> <web_root> <mdb-lookup-host> <mdb-loo=
kup-port>\n");=0A+    fprintf(stderr, "   ex) http-server www.example.com 8=
0 /index.html\n");=0A+    exit(1);=0A+}=0A+=0A+char* cook_html(int code){ /=
/ char* content=0A+=0A+    char *html =3D (char *) malloc(1000 * sizeof(cha=
r));=0A+=0A+    char *error_code_prompt;=0A+    if(code =3D=3D 501)=0A+    =
    error_code_prompt =3D  "Not Implemented";=0A+    if(code =3D=3D 400)=0A=
+        error_code_prompt =3D  "Bad Request";=0A+    if(code =3D=3D 404)=
=0A+        error_code_prompt =3D "Not Found";=0A+=0A+=0A+    snprintf(html=
, 1000,  //sizeof(html), =0A+            "HTTP/1.0 %d %s\r\n"=0A+          =
  "\r\n"=0A+            //"<html>\r\n<body>\r\n<h1>%d %s</h1>\r\n</body>\r\=
n</html>\r\n",=0A+            "<html><body><h1>%d %s</h1></body></html>",=
=0A+            code, error_code_prompt, code, error_code_prompt);=0A+    p=
rintf("\n\n%s\\n\n", html);=0A+    return html;=0A+}=0A+=0A+=0A+=0A+=0A+=0A=
+int main(int argc, char **argv) {=0A+=0A+    // Ignore SIGPIPE so that we =
don=E2=80=99t terminate when we call=0A+    // send() on a disconnected soc=
ket=0A+    if (signal(SIGPIPE, SIG_IGN) =3D=3D SIG_ERR)=0A+        die("sig=
nal() failed"); =0A+    =0A+    if (argc !=3D 5) {=0A+	printUsage();=0A+   =
 }=0A+=0A+    // Assign server_port and web_root to correct command line ar=
guments=0A+=0A+    unsigned short serv_port =3D atoi(argv[1]);=0A+    const=
 char *web_root =3D argv[2];=0A+    =0A+=0A+    // Create a listening socke=
t (also called server socket) =0A+=0A+    int servsock;=0A+    if ((servsoc=
k =3D socket(AF_INET, SOCK_STREAM, 0)) < 0)=0A+        die("socket failed")=
;=0A+=0A+    // Construct local address structure=0A+=0A+    struct sockadd=
r_in servaddr;=0A+    memset(&servaddr, 0, sizeof(servaddr));=0A+    servad=
dr.sin_family =3D AF_INET;=0A+    servaddr.sin_addr.s_addr =3D htonl(INADDR=
_ANY); // any network interface=0A+    servaddr.sin_port =3D htons(serv_por=
t);=0A+=0A+    // Bind to the local address=0A+=0A+    if (bind(servsock, (=
struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)=0A+        die("bind f=
ailed");=0A+=0A+    // Start listening for incoming connections=0A+=0A+    =
if (listen(servsock, 5 /* queue size for connection requests */ ) < 0)=0A+ =
       die("listen failed");=0A+=0A+    int clntsock;=0A+    socklen_t clnt=
len;=0A+    struct sockaddr_in clntaddr;=0A+=0A+=0A+    // +---------------=
----------------------------=0A+    // part2 b=0A+=0A+    // create a mdb-l=
ookup-server sock, now I'm a client to mdb-lookup-server, and as a client, =
I only need server sock.=0A+=0A+    char *mdb_serverName =3D argv[3];=0A+  =
  char *mdb_serverIP;=0A+    unsigned short mdb_serverPort =3D atoi(argv[4]=
);=0A+=0A+=0A+    int mdb_sock;=0A+    struct sockaddr_in mdb_serverAddr;=
=0A+    struct hostent *mdb_he;=0A+    // char buf_2[BUF_SIZE];            =
        // necessary?=0A+=0A+     =0A+    // get mdb-lookup server ip from =
mdb-server name=0A+    if ((mdb_he =3D gethostbyname(mdb_serverName)) =3D=
=3D NULL) {=0A+	die("gethostbyname failed");=0A+    }=0A+    mdb_serverIP =
=3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);=0A+=0A+    /* for debuggi=
ng=0A+       printf("1: %s\n", mdb_serverName);=0A+       printf("2: %s\n",=
 mdb_serverIP);=0A+       printf("3: %s\n", mdb_serverPort);=0A+       prin=
tf("4: %s\n", filePath);=0A+       printf("5: %s\n", fname);=0A+       */=
=0A+=0A+=0A+    // create socket=0A+    if ((mdb_sock =3D socket(PF_INET, S=
OCK_STREAM, IPPROTO_TCP)) < 0) {=0A+	die("socket failed");=0A+    }=0A+=0A+=
=0A+    // construct mdb-lookup server address=0A+    memset(&mdb_serverAdd=
r, 0, sizeof(mdb_serverAddr));=0A+    mdb_serverAddr.sin_family =3D AF_INET=
;=0A+    mdb_serverAddr.sin_addr.s_addr =3D inet_addr(mdb_serverIP);=0A+   =
 mdb_serverAddr.sin_port =3D htons(mdb_serverPort);=0A+=0A+    // connect=
=0A+    if (connect(mdb_sock, (struct sockaddr *)&mdb_serverAddr, sizeof(md=
b_serverAddr)) < 0) {=0A+	die("connect failed");=0A+    }=0A+=0A+    =0A+  =
  =0A+    // wrap the socket with a file* so that we can read the socket us=
ing fgets()=0A+    FILE *fd_mdb;=0A+    if ((fd_mdb =3D fdopen(mdb_sock, "r=
")) =3D=3D NULL) {=0A+	die("fdopen failed mdb_sock");=0A+    }=0A+=0A+=0A+=
=0A+    // +-------------------------------------------=0A+=0A+    int coun=
t =3D 0;=0A+    while (1) {=0A+=0A+        printf("\n$ %d \n", count++);=0A=
+=0A+        char buf[4096];=0A+=0A+=0A+        // Accept an incoming conne=
ction=0A+=0A+        clntlen =3D sizeof(clntaddr); // initialize the in-out=
 parameter=0A+=0A+        if ((clntsock =3D accept(servsock,=0A+           =
             (struct sockaddr * ) &clntaddr, &clntlen)) < 0){=0A+          =
  //perror("next clinet");=0A+            //die("accept fail");=0A+        =
    continue; =0A+        }=0A+=0A+        // accept() returned a connected=
 socket (also called client socket)=0A+        // and filled in the client'=
s address into clntaddr=0A+=0A+=0A+        // fd_clntsock, for clnt/browser=
=0A+        FILE *fd_clntsock;  =0A+        if ((fd_clntsock =3D fdopen(cln=
tsock, "r")) =3D=3D NULL) {   =0A+           // if i cannot open clntsock, =
is it a clnt crash issue? No, my problem. die =0A+            die("fdopen f=
ailed");=0A+        }=0A+=0A+=0A+=0A+        // read GET request from FILE =
*fd_clntsock, clnt request from browser=0A+        char requestLine[1000]; =
=0A+        if(fgets(requestLine, sizeof(requestLine), fd_clntsock) =3D=3D =
NULL ){=0A+            // fail to read request line, (maybe clnt crash/clos=
e connection -- fail to send request), skip current clnt to next one.=0A+  =
          fprintf(stderr, "clnt crashes");=0A+            //fclose(fd_clnts=
ock); no need=0A+            continue;=0A+        }=0A+=0A+        // parse=
 browser http request line=0A+        char *token_separators =3D "\t \r\n";=
 // tab, space, new line=0A+        char *method =3D strtok(requestLine, to=
ken_separators);=0A+        //  printf("1 method:(%s)", method);=0A+       =
 // printf("1 requestLine:(%s)", requestLine);=0A+       =0A+        char *=
requestURI =3D strtok(NULL, token_separators);=0A+        // printf("2 requ=
estURI:(%s)", requestURI);=0A+        // printf("2 requestLine:(%s)", reque=
stLine);=0A+       =0A+        char *httpVersion =3D strtok(NULL, token_sep=
arators);=0A+        // printf("3 httpVersion:(%s)", httpVersion);=0A+     =
   // printf("3 requestLine:(%s)", requestLine);=0A+=0A+        /*=0A+     =
      1 method:(GET)=0A+           1 requestLine:(GET)=0A+           2 requ=
estURI:(/~yz4004/cs3157/tng/index.html)=0A+           2 requestLine:(GET)=
=0A+           3 httpVersion:(HTTP/1.1)=0A+           3 requestLine:(GET)$ =
1*/=0A+=0A+        // print log through stderr, whether it's legal or not. =
if wrong put error code later.=0A+        fprintf(stderr, "%s \"%s %s\" ",=
=0A+                inet_ntoa(clntaddr.sin_addr),=0A+                method=
,=0A+                requestURI);=0A+=0A+=0A+=0A+=0A+/*=0A+           int h=
tml_size ; =0A+           while((html_size =3D fread(buf,1,sizeof(buf),fd_c=
lntsock) ) !=3D 0 ){=0A+             printf("html: \n%s", buf);=0A+        =
   } =0A+           fflush(stdout);=0A+  =0A+*/=0A+           =0A+=0A+=0A+ =
       // Now parse method and httpVersion first, and then requestURI. =0A+=
        // 1. check GET keyword=0A+        if (strncmp(method, "GET", 3) !=
=3D 0 ){ // =0A+=0A+            // fclose(fd_clntsock); no need to turn thi=
s off, since this clnt fails, we continue to next clnt (while 1)=0A+       =
     // fd_clntsock created again & cover old one. Not simple die program=
=0A+            // as long as program keep running, no need to close/free s=
ince we do that at the end, unless die program.=0A+=0A+            // send =
error 501 http to clnt & output log=0A+            fprintf(stderr, "%d\n", =
501); =0A+=0A+            char *html_501 =3D =0A+                "HTTP/1.0 =
501 Not Implemented"=0A+                "<html><body><h1>501 Not Implemente=
d</h1></body></html>";=0A+=0A+            //printf("html : \n%s",html);=0A+=
            if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(h=
tml_501)){=0A+                die("send content failed");=0A+            }=
=0A+=0A+            continue;=0A+        }=0A+      =0A+        // 2. check=
 whether http 1.0 or 1.1 protocol=0A+        if (strncmp("HTTP/1.0", httpVe=
rsion, 8) !=3D 0 && strncmp("HTTP/1.1", httpVersion, 8) !=3D 0) {=0A+      =
  =0A+            fprintf(stderr, "\"%s %s %s\" %d\n",method, requestURI, h=
ttpVersion, 501); =0A+          =0A+            fclose(fd_clntsock);=0A+   =
        =0A+=0A+           =0A+            char *html =3D cook_html(501);=
=0A+           =0A+            //size =3D snprintf(buf, sizeof(buf),"%s" , =
html);=0A+           =0A+            printf("html : \n%s",html);=0A+       =
    =0A+            if (send(clntsock, html, strlen(html), 0) !=3D strlen(h=
tml) ){=0A+          =0A+                //free(html);=0A+          =0A+   =
             die("send content failed");=0A+          =0A+            }=0A+=
          =0A+            free(html); =0A+          =0A+            continu=
e;=0A+       =0A+        }=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=
=0A+=0A+=0A+=0A+=0A+=0A+       ///////////////   part 2 b=0A+=0A+=0A+      =
     printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requestUR=
I, "/mdb-lookup"));=0A+=0A+       // http://clac.cs.columbia.edu:41782/mdb-=
lookup =0A+       if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){=0A+=0A+ =
          printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requ=
estURI, "/mdb-lookup"));=0A+=0A+           const char *form =3D=0A+        =
       "HTTP 200 OK\r\n"=0A+               "\r\n"=0A+               "<h1>md=
b-lookup</h1>\n"=0A+               "<p>\n"=0A+               "<form method=
=3DGET action=3D/mdb-lookup>\n"=0A+               "lookup: <input type=3Dte=
xt name=3Dkey>\n"=0A+               "<input type=3Dsubmit>\n"=0A+          =
     "</form>\n"=0A+               "<p>\n";=0A+=0A+           if (send(clnt=
sock, form, strlen(form), 0) !=3D strlen(form) ){=0A+               die("se=
nd content failed");=0A+           }=0A+=0A+=0A+           printf("\n\n sen=
d, you should see search page  \n\n");=0A+=0A+=0A+          continue; =0A+ =
      }=0A+=0A+=0A+=0A+       // http://clac.cs.columbia.edu:41782/mdb-look=
up?key=3Dhello =0A+       if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =
=3D=3D0 ){=0A+=0A+           printf("2222222222222222  (%s), %d\n\n\n", req=
uestURI, strncmp(requestURI, "/mdb-lookup?key=3D",16 ));=0A+=0A+=0A+       =
 /*=0A+        FILE *fd_clntsock;  // fp_servsock=0A+        if ((fd_clntso=
ck =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // fp_servsock =3D fdopen(se=
rvsock, "r") =0A+            die("fdopen failed");=0A+        }*/=0A+=0A+=
=0A+        // printf("why2");=0A+        // fflush(stdout);=0A+=0A+=0A+   =
     /*=0A+           int html_size; =0A+           while((html_size =3D fr=
ead(buf,1,sizeof(buf),fd_clntsock) ) > 0 ){=0A+             printf("html: \=
n%s", buf);=0A+           }   =0A+=0A+=0A+        printf("|||||||||||||||||=
|||||||||");=0A+        fflush(stdout);=0A+        =0A+        FILE *fd_cln=
tsock_1;  // fp_servsock=0A+        if ((fd_clntsock_1 =3D fdopen(clntsock,=
 "r")) =3D=3D NULL) {   // fp_servsock =3D fdopen(servsock, "r") =0A+      =
      die("fdopen failed");=0A+        }=0A+=0A+=0A+           // =0A+     =
      while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=3D 0 =
){=0A+=0A+               printf("html: \n%s", buf);=0A+=0A+           }*/  =
 =0A+        =0A+=0A+ =0A+      =0A+           /*=0A+           // int html=
_size ; =0A+           // int i =3D 0;=0A+=0A+=0A+           // printf("\n%=
ld, %s \n", fread(buf,1,30,fd_clntsock), buf ); =0A+           // printf("\=
n%ld\n", fread(buf,1,sizeof(buf),fd_clntsock)); =0A+=0A+           // while=
((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) >  0 ){=0A+=0A+     =
      printf("_____ %d\n", i++);=0A+           fflush(stdout);=0A+         =
    printf("html: \n%s", buf);=0A+             printf("88888 %d\n", i );=0A=
+             fflush(stdout);=0A+             break;=0A+             =0A+  =
         } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =E4=
=BD=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=85=
=A5size?  =0A+=0A+           /* // =E6=A3=80=E6=9F=A5 header=0A+           =
while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){=0A+               pri=
ntf("\nHeaders: %s\n", buf);=0A+           }=0A+           fgets(buf,sizeof=
(buf), fd_clntsock);=0A+           printf("$$$$$$$$ %s", buf);=0A+=0A+     =
      fgets(buf,sizeof(buf), fd_clntsock);=0A+           printf("*** $$$$$$=
$$ %s", buf);=0A+           */=0A+=0A+=0A+        =0A+        // printf("\n=
(%s)\n",requestURI);=0A+=0A+        for(int i=3D0; i<16; i++){=0A+         =
   requestURI++;=0A+        }=0A+        strcat(requestURI, "\n");=0A+     =
   // printf("\n(%s)\n",requestURI);=0A+=0A+=0A+=0A+        // =E6=88=91=E8=
=A6=81=E6=8A=8A=E4=B8=9C=E8=A5=BF search key send =E7=BB=99 mdb-lookup-serv=
er=0A+        //=0A+=0A+=0A+        printf("\n(%s)\n",requestURI);=0A+=0A+ =
      // =E6=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=E4=
=BA=86=EF=BC=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2=0A+    =0A+    //pri=
ntf("=1A=1A")    =0A+    if (send(mdb_sock, requestURI, strlen(requestURI),=
 0) !=3D strlen(requestURI)) {=0A+	die("send failed");=0A+    }=0A+=0A+=0A+=
=0A+    /*=0A+           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NUL=
L){=0A+               printf("\nHeaders: %s\n", buf);=0A+           }=0A+  =
         */=0A+           // fgets(buf,sizeof(buf), fd_mdb);=0A+           =
// printf("$$$$$$$$ %s", buf);=0A+=0A+=0A+    /*=0A+           printf("\n\n=
 11111111111111111111111111111111--------------------------\n\n");=0A+=0A+ =
          fgets(buf,sizeof(buf), fd_mdb);=0A+           printf("*** $$$$$$$=
$ %s", buf);=0A+=0A+           printf("\n\n 2222222222222222222222222222222=
2--------------------------\n\n");=0A+=0A+           fgets(buf,sizeof(buf),=
 fd_mdb);=0A+           printf("*** $$$$$$$$ %s", buf);=0A+      */=0A+=0A+=
=0A+=0A+=0A+  /*      =0A+    char html[10000];=0A+    strcpy(html,=0A+    =
    "HTTP 200 OK\r\n"       =0A+        "\r\n"=0A+               =0A+      =
  "<h1>mdb-lookup</h1>\n"=0A+               =0A+        "<p>\n"=0A+        =
       =0A+        "<form method=3DGET action=3D/mdb-lookup>\n"=0A+        =
       =0A+        "lookup: <input type=3Dtext name=3Dkey>\n"=0A+          =
     =0A+        "<input type=3Dsubmit>\n"=0A+               =0A+        "<=
/form>\n"=0A+               =0A+        "<p>\n"=0A+=0A+        "<p><table b=
order>\n");=0A+=0A+=0A+        printf("000000000000000000000000000000000000=
0000000000000000000000000000\n");=0A+    char row[100];=0A+    while(fgets(=
buf, sizeof(buf), fd_mdb)!=3D NULL ){=0A+=0A+        if( strcmp(buf, "\n") =
=3D=3D 0){=0A+            printf("\n\n end \n\n");=0A+            break;=0A=
+        }=0A+=0A+        snprintf(row, sizeof(row), "<tr><td> %s\n", buf);=
=0A+        printf("%s\n", row );=0A+        strcat(html, row);=0A+=0A+    =
  =0A+        =0A+    }=0A+=0A+    strcat(html, "</table>\n</body>\n</html>=
");=0A+=0A+=0A+    printf("\n\n%s\n\n", html);=0A+*/=0A+=0A+=0A+=0A+    =0A=
+    strcpy(buf,=0A+        "HTTP 200 OK\r\n"       =0A+        "\r\n"=0A+ =
              =0A+        "<h1>mdb-lookup</h1>\n"=0A+               =0A+   =
     "<p>\n"=0A+               =0A+        "<form method=3DGET action=3D/md=
b-lookup>\n"=0A+               =0A+        "lookup: <input type=3Dtext name=
=3Dkey>\n"=0A+               =0A+        "<input type=3Dsubmit>\n"=0A+     =
          =0A+        "</form>\n"=0A+               =0A+        "<p>\n"=0A+=
=0A+        "<p><table border>\n");=0A+=0A+    =0A+=0A+           =0A+    i=
f( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){=0A+    =0A+     =
   perror("send content failed");=0A+=0A+        break;=0A+=0A+    }=0A+=0A=
+    char row[100];=0A+    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){=
=0A+=0A+        if( strcmp(row, "\n") =3D=3D 0){=0A+            printf("\n\=
n end \n\n");=0A+            break;=0A+        }=0A+=0A+=0A+        snprint=
f(buf, sizeof(buf), "<tr><td> %s\n", row);=0A+        //printf("%s\n", row)=
 ;=0A+        //strcat(html, row);=0A+=0A+=0A+    if( send(clntsock, buf, s=
trlen(buf), 0) !=3D strlen(buf) ){=0A+    =0A+        perror("send content =
failed");=0A+=0A+        break;=0A+=0A+    }=0A+    }=0A+=0A+=0A+=0A+=0A+=
=0A+=0A+=0A+=0A+=0A+=0A+        continue; =0A+       }=0A+=0A+=0A+=0A+     =
  =0A+       ////////////////////////////////////////////=0A+=0A+=0A+=0A+=
=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+       // check requestURI !!!!!!!!!!!!!!!!=
=0A+       //=0A+       =0A+       // check web_root=0A+=0A+=0A+=0A+=0A+=0A=
+=0A+=0A+=0A+=0A+      =0A+=0A+=0A+=0A+=0A+=0A+       // printf("\nweb_root=
 %s\n", web_root);=0A+=0A+=0A+       // log print out=0A+       fprintf(std=
err, "\"%s %s %s\" %d OK\n",method, requestURI, httpVersion, 200);=0A+=0A+ =
      // retrive the file -- requestURI=0A+       // 1. make path=0A+      =
 char full_path[100];  // should not be " char *full_path;" has to have len=
=0A+       strcpy(full_path, web_root);=0A+       strcat(full_path, request=
URI);  // char *file_path =3D strcat(web_root, requestURI);=0A+=0A+=0A+=0A+=
       // int stat(const char *path, struct stat *buf);=0A+       // succes=
s returns 0 & fill buf, error return -1=0A+       // reference: https://www=
=2Eibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_73/apis/stat.htm =0A+       stru=
ct stat status;=0A+       char full_path_1[strlen(full_path)];=0A+       st=
rcpy(full_path_1, full_path);=0A+=0A+=0A+=0A+       // check ending char of=
 path is '/' or not, return 400 error code    =0A+       if(full_path_1[str=
len(full_path_1)-1] =3D=3D '/' ){=0A+           // if ending with '/', atta=
ch index.html=0A+           strcat(full_path_1, "index.html");=0A+         =
  // printf("***********%s\n", full_path_1);=0A+=0A+       }=0A+       /*=
=0A+       else{=0A+           // else send 400 error code=0A+           ch=
ar *html =3D cook_html(400);=0A+           printf("html : \n%s",html);=0A+ =
          if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){=0A=
+               free(html);=0A+               die("send content failed");=
=0A+           }=0A+           free(html); =0A+           fclose(fd_clntsoc=
k);=0A+           continue;=0A+       }*/=0A+=0A+=0A+=0A+       // if path/=
file exists, proceeds, else  =0A+       if(stat(full_path_1, &status) =3D=
=3D 0){ // succeeds -- file exists, then check directory/file=0A+=0A+      =
     printf("**********  %s", full_path_1 );=0A+=0A+           // full_path=
 ends with / or not=0A+           // printf("***********%s\n",full_path_1);=
=0A+           // printf("%c, %c\n", '/',full_path_1[strlen(full_path_1)-1]=
 );=0A+           // if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){=0A=
+           //        strcat(full_path_1, "index.html");=0A+           //  =
      // printf("***********%s\n", full_path_1);=0A+           // }=0A+    =
   }else{=0A+=0A+           //printf("\nfail does not exists:  %s\n", full_=
path_1 );=0A+=0A+           char *html =3D cook_html(404);=0A+           pr=
intf("html : \n%s",html);=0A+           if (send(clntsock, html, strlen(htm=
l), 0) !=3D strlen(html) ){=0A+               //free(html);=0A+            =
   die("send content failed");=0A+           }=0A+           free(html); =
=0A+           fclose(fd_clntsock);=0A+           continue;=0A+       } =0A=
+=0A+       // 2. send response headers=0A+       snprintf(buf, sizeof(buf)=
, =0A+               "HTTP/1.0 200 OK\r\n"=0A+               "\r\n");=0A+=
=0A+       // 3. open file, read & send=0A+       // printf("\nfull_path_1:=
 %s\n", full_path_1);=0A+       // printf("\nstat code: %d\n", stat(full_pa=
th_1, &status));=0A+       FILE *file_requested =3D fopen(full_path_1, "rb"=
);=0A+       if( file_requested =3D=3D NULL) =0A+               die("fail o=
pen file");=0A+       int size_read;=0A+=0A+       size_read =3D strlen(buf=
); // should be 19, header =0A+       do{=0A+           printf("\n @@@@@@@@=
@@@@@@@@@@ %d \n",size_read); =0A+           if( send(clntsock, buf, size_r=
ead, 0) !=3D size_read ){=0A+               perror("send content failed");=
=0A+               break;=0A+           }=0A+       }while(( size_read =3D =
fread(buf,1, sizeof(buf), file_requested)) > 0);=0A+=0A+=0A+       //if(feo=
f(file_requested) )=0A+       //    printf("file has not been fully read");=
=0A+=0A+       fclose(file_requested);=0A+       fclose(fd_clntsock);=0A+=
=0A+       fclose(fd_mdb);=0A+=0A+=0A+    }// while (1)=0A+=0A+    return 0=
;=0A+}=0A-- =0A2.17.1=0A=0A=0AFrom dbe85f545b93c3d04f51b3eae63e7c4adce22c71=
 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: =
Thu, 5 May 2022 19:33:36 -0400=0ASubject: [PATCH 2/6] add makefile=0A=0A---=
=0A Makefile | 29 +++++++++++++++++++++++++++++=0A 1 file changed, 29 inser=
tions(+)=0A create mode 100644 Makefile=0A=0Adiff --git a/Makefile b/Makefi=
le=0Anew file mode 100644=0Aindex 0000000..a95373e=0A--- /dev/null=0A+++ b/=
Makefile=0A@@ -0,0 +1,29 @@=0A+=0A+#=0A+# Makefile for lab 7, part 2=0A+#=
=0A+=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=
=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+=0A+.PHONY: default=0A+default=
: http-server =0A+=0A+# header dependency=0A+## mdb-lookup-server.o: mdb.h=
=0A+=0A+=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.o *~ a.out core http-se=
rver=0A+=0A+.PHONY: all=0A+all: clean default=0A+=0A+=0A+=0A-- =0A2.17.1=0A=
=0A=0AFrom 997c897e237b0e985f14ca4ea8e49e938dadd939 Mon Sep 17 00:00:00 200=
1=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Thu, 5 May 2022 21:33:39=
 -0400=0ASubject: [PATCH 3/6] finish part2=0A=0A---=0A http-server.c | 500 =
++++++++++++++------------------------------------=0A 1 file changed, 141 i=
nsertions(+), 359 deletions(-)=0A=0Adiff --git a/http-server.c b/http-serve=
r.c=0Aindex 3e57ef6..befd329 100644=0A--- a/http-server.c=0A+++ b/http-serv=
er.c=0A@@ -162,10 +162,10 @@ int main(int argc, char **argv) {=0A =0A     /=
/ +-------------------------------------------=0A =0A-    int count =3D 0;=
=0A+    //int count =3D 0;=0A     while (1) {=0A =0A-        printf("\n$ %d=
 \n", count++);=0A+        //printf("\n$ %d \n", count++);=0A =0A         c=
har buf[4096];=0A =0A@@ -234,17 +234,6 @@ int main(int argc, char **argv) {=
=0A =0A =0A =0A-/*=0A-           int html_size ; =0A-           while((html=
_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) !=3D 0 ){=0A-             =
printf("html: \n%s", buf);=0A-           } =0A-           fflush(stdout);=
=0A-  =0A-*/=0A-           =0A-=0A-=0A         // Now parse method and http=
Version first, and then requestURI. =0A         // 1. check GET keyword=0A =
        if (strncmp(method, "GET", 3) !=3D 0 ){ // =0A@@ -254,15 +243,17 @@=
 int main(int argc, char **argv) {=0A             // as long as program kee=
p running, no need to close/free since we do that at the end, unless die pr=
ogram.=0A =0A             // send error 501 http to clnt & output log=0A-  =
          fprintf(stderr, "%d\n", 501); =0A+            fprintf(stderr, "%d=
 Not Implemented\n", 501); =0A =0A             char *html_501 =3D =0A-     =
           "HTTP/1.0 501 Not Implemented"=0A+                "HTTP/1.0 501 =
Not Implemented\r\n\r\n"=0A                 "<html><body><h1>501 Not Implem=
ented</h1></body></html>";=0A =0A             //printf("html : \n%s",html);=
=0A             if (send(clntsock, html_501, strlen(html_501), 0) !=3D strl=
en(html_501)){=0A-                die("send content failed");=0A+          =
     fclose(fd_mdb);=0A+               fclose(fd_clntsock); =0A+           =
    die("send content failed");=0A             }=0A =0A             continu=
e;=0A@@ -271,58 +262,59 @@ int main(int argc, char **argv) {=0A         // =
2. check whether http 1.0 or 1.1 protocol=0A         if (strncmp("HTTP/1.0"=
, httpVersion, 8) !=3D 0 && strncmp("HTTP/1.1", httpVersion, 8) !=3D 0) {=
=0A         =0A-            fprintf(stderr, "\"%s %s %s\" %d\n",method, req=
uestURI, httpVersion, 501); =0A-          =0A-            fclose(fd_clntsoc=
k);=0A-           =0A+            fprintf(stderr, "%d Not Implemented\n", 5=
01); =0A+            char *html_501 =3D =0A+                "HTTP/1.0 501 N=
ot Implemented\r\n\r\n"=0A+                "<html><body><h1>501 Not Impleme=
nted</h1></body></html>";=0A =0A-           =0A-            char *html =3D =
cook_html(501);=0A-           =0A-            //size =3D snprintf(buf, size=
of(buf),"%s" , html);=0A-           =0A-            printf("html : \n%s",ht=
ml);=0A-           =0A-            if (send(clntsock, html, strlen(html), 0=
) !=3D strlen(html) ){=0A-          =0A-                //free(html);=0A-  =
        =0A-                die("send content failed");=0A-          =0A+  =
          if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(htm=
l_501)){=0A+               fclose(fd_mdb);=0A+               fclose(fd_clnt=
sock);=0A+               die("send content failed");=0A             }=0A-  =
        =0A-            free(html); =0A-          =0A+=0A             conti=
nue;=0A-       =0A         }=0A =0A =0A =0A+        // 3. check URI starts =
with /, not ended with /..  not contains /../=0A =0A+        //printf("\n||=
||||| %s\n",requestURI);=0A+        if (strncmp("/", requestURI, 1) !=3D 0 =
|| strstr(requestURI, "/../") || strstr(requestURI, "/..") )  {=0A+        =
=0A+            fprintf(stderr, "%d Bad Request\n", 400); =0A+            c=
har *html_400 =3D =0A+                "HTTP/1.0 400 Bad Request\r\n\r\n"=0A=
+                "<html><body><h1>400 Bad Request</h1></body></html>";=0A+=
=0A+            if (send(clntsock, html_400, strlen(html_400), 0) !=3D strl=
en(html_400)){=0A+               fclose(fd_mdb);=0A+               fclose(f=
d_clntsock);=0A+               die("send content failed");=0A+            }=
=0A =0A+            continue;=0A+        }=0A =0A =0A+        // printf("23=
33333333333333333333333333"); fflush(stdout);=0A =0A =0A =0A-=0A-=0A-=0A-=
=0A-=0A-=0A+         =0A =0A        ///////////////   part 2 b=0A =0A =0A- =
          printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requ=
estURI, "/mdb-lookup"));=0A+           //printf("111111111111111  (%s), %d\=
n\n\n", requestURI, strcmp(requestURI, "/mdb-lookup"));=0A =0A        // ht=
tp://clac.cs.columbia.edu:41782/mdb-lookup =0A        if (strcmp(requestURI=
, "/mdb-lookup") =3D=3D0 ){=0A =0A-           printf("111111111111111  (%s)=
, %d\n\n\n", requestURI, strcmp(requestURI, "/mdb-lookup"));=0A-=0A+       =
    //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requestU=
RI, "/mdb-lookup"));=0A+       =0A+           fprintf(stderr, "200 OK\n");=
=0A            const char *form =3D=0A                "HTTP 200 OK\r\n"=0A =
               "\r\n"=0A@@ -335,296 +327,103 @@ int main(int argc, char **a=
rgv) {=0A                "<p>\n";=0A =0A            if (send(clntsock, form=
, strlen(form), 0) !=3D strlen(form) ){=0A+               fclose(fd_mdb);=
=0A+               fclose(fd_clntsock);=0A                die("send content=
 failed");=0A            }=0A =0A-=0A-           printf("\n\n send, you sho=
uld see search page  \n\n");=0A-=0A-=0A-          continue; =0A+           =
//printf("\n\n send, you should see search page  \n\n");=0A+           cont=
inue; =0A+      =0A        }=0A =0A =0A =0A+      =0A        // http://clac=
=2Ecs.columbia.edu:41782/mdb-lookup?key=3Dhello =0A        if (strncmp(requ=
estURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){=0A =0A-           printf("22222=
22222222222  (%s), %d\n\n\n", requestURI, strncmp(requestURI, "/mdb-lookup?=
key=3D",16 ));=0A-=0A-=0A-        /*=0A-        FILE *fd_clntsock;  // fp_s=
ervsock=0A-        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL)=
 {   // fp_servsock =3D fdopen(servsock, "r") =0A-            die("fdopen f=
ailed");=0A-        }*/=0A-=0A-=0A-        // printf("why2");=0A-        //=
 fflush(stdout);=0A-=0A-=0A-        /*=0A-           int html_size; =0A-   =
        while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) > 0 ){=
=0A-             printf("html: \n%s", buf);=0A-           }   =0A-=0A+     =
      //printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncmp(requ=
estURI, "/mdb-lookup?key=3D",16 ));=0A+      =0A+           // printf("\n(%=
s)\n",requestURI);=0A =0A-        printf("||||||||||||||||||||||||||");=0A-=
        fflush(stdout);=0A         =0A-        FILE *fd_clntsock_1;  // fp_=
servsock=0A-        if ((fd_clntsock_1 =3D fdopen(clntsock, "r")) =3D=3D NU=
LL) {   // fp_servsock =3D fdopen(servsock, "r") =0A-            die("fdope=
n failed");=0A-        }=0A-=0A-=0A-           // =0A-           while((htm=
l_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=3D 0 ){=0A-=0A-      =
         printf("html: \n%s", buf);=0A-=0A-           }*/   =0A+           =
for(int i=3D0; i<16; i++){=0A+           =0A+               requestURI++;=
=0A         =0A-=0A- =0A-      =0A-           /*=0A-           // int html_=
size ; =0A-           // int i =3D 0;=0A-=0A-=0A-           // printf("\n%l=
d, %s \n", fread(buf,1,30,fd_clntsock), buf ); =0A-           // printf("\n=
%ld\n", fread(buf,1,sizeof(buf),fd_clntsock)); =0A-=0A-           // while(=
(html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) >  0 ){=0A-=0A-      =
     printf("_____ %d\n", i++);=0A-           fflush(stdout);=0A-          =
   printf("html: \n%s", buf);=0A-             printf("88888 %d\n", i );=0A-=
             fflush(stdout);=0A-             break;=0A-             =0A-   =
        } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =E4=BD=
=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=85=A5s=
ize?  =0A-=0A-           /* // =E6=A3=80=E6=9F=A5 header=0A-           whil=
e(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){=0A-               printf(=
"\nHeaders: %s\n", buf);=0A            }=0A-           fgets(buf,sizeof(buf=
), fd_clntsock);=0A-           printf("$$$$$$$$ %s", buf);=0A-=0A-         =
  fgets(buf,sizeof(buf), fd_clntsock);=0A-           printf("*** $$$$$$$$ %=
s", buf);=0A-           */=0A-=0A-=0A+           =0A+       =0A+           =
strcat(requestURI, "\n");=0A         =0A-        // printf("\n(%s)\n",reque=
stURI);=0A-=0A-        for(int i=3D0; i<16; i++){=0A-            requestURI=
++;=0A-        }=0A-        strcat(requestURI, "\n");=0A-        // printf(=
"\n(%s)\n",requestURI);=0A-=0A+           // printf("\n(%s)\n",requestURI);=
=0A =0A+           // send    =0A =0A-        // =E6=88=91=E8=A6=81=E6=8A=
=8A=E4=B8=9C=E8=A5=BF search key send =E7=BB=99 mdb-lookup-server=0A-      =
  //=0A-=0A-=0A-        printf("\n(%s)\n",requestURI);=0A-=0A-       // =E6=
=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=E4=BA=86=EF=BC=
=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2=0A     =0A-    //printf("=1A=1A"=
)    =0A-    if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D str=
len(requestURI)) {=0A-	die("send failed");=0A-    }=0A-=0A-=0A-=0A-    /*=
=0A-           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){=0A-   =
            printf("\nHeaders: %s\n", buf);=0A+           if (send(mdb_sock=
, requestURI, strlen(requestURI), 0) !=3D strlen(requestURI)) {=0A+        =
       fclose(fd_mdb);=0A+               fclose(fd_clntsock);=0A+          =
     die("send failed");=0A            }=0A-           */=0A-           // =
fgets(buf,sizeof(buf), fd_mdb);=0A-           // printf("$$$$$$$$ %s", buf)=
;=0A-=0A-=0A-    /*=0A-           printf("\n\n 1111111111111111111111111111=
1111--------------------------\n\n");=0A-=0A-           fgets(buf,sizeof(bu=
f), fd_mdb);=0A-           printf("*** $$$$$$$$ %s", buf);=0A-=0A-         =
  printf("\n\n 22222222222222222222222222222222--------------------------\n=
\n");=0A-=0A-           fgets(buf,sizeof(buf), fd_mdb);=0A-           print=
f("*** $$$$$$$$ %s", buf);=0A-      */=0A-=0A-=0A-=0A-=0A-  /*      =0A-   =
 char html[10000];=0A-    strcpy(html,=0A-        "HTTP 200 OK\r\n"       =
=0A-        "\r\n"=0A-               =0A-        "<h1>mdb-lookup</h1>\n"=0A=
-               =0A-        "<p>\n"=0A-               =0A-        "<form me=
thod=3DGET action=3D/mdb-lookup>\n"=0A-               =0A-        "lookup: =
<input type=3Dtext name=3Dkey>\n"=0A-               =0A-        "<input typ=
e=3Dsubmit>\n"=0A-               =0A-        "</form>\n"=0A-               =
=0A-        "<p>\n"=0A-=0A-        "<p><table border>\n");=0A-=0A-=0A-     =
   printf("0000000000000000000000000000000000000000000000000000000000000000=
\n");=0A-    char row[100];=0A-    while(fgets(buf, sizeof(buf), fd_mdb)!=
=3D NULL ){=0A-=0A-        if( strcmp(buf, "\n") =3D=3D 0){=0A-            =
printf("\n\n end \n\n");=0A-            break;=0A-        }=0A-=0A-        =
snprintf(row, sizeof(row), "<tr><td> %s\n", buf);=0A-        printf("%s\n",=
 row );=0A-        strcat(html, row);=0A-=0A-      =0A-        =0A-    }=0A=
-=0A-    strcat(html, "</table>\n</body>\n</html>");=0A-=0A-=0A-    printf(=
"\n\n%s\n\n", html);=0A-*/=0A-=0A-=0A-=0A-    =0A-    strcpy(buf,=0A-      =
  "HTTP 200 OK\r\n"       =0A-        "\r\n"=0A-               =0A-        =
"<h1>mdb-lookup</h1>\n"=0A-               =0A-        "<p>\n"=0A-          =
     =0A-        "<form method=3DGET action=3D/mdb-lookup>\n"=0A-          =
     =0A-        "lookup: <input type=3Dtext name=3Dkey>\n"=0A-            =
   =0A-        "<input type=3Dsubmit>\n"=0A-               =0A-        "</f=
orm>\n"=0A-               =0A-        "<p>\n"=0A-=0A-        "<p><table bor=
der>\n");=0A-=0A+          =0A+       =0A+           fprintf(stderr, "200 O=
K\n");=0A+           strcpy(buf,=0A+                   "HTTP/1.0 200 OK\r\n=
"     =0A+                   "\r\n"=0A+                   "<h1>mdb-lookup</=
h1>\n"=0A+                   "<p>\n"=0A+                   "<form method=3D=
GET action=3D/mdb-lookup>\n"=0A+                   "lookup: <input type=3Dt=
ext name=3Dkey>\n"=0A+                   "<input type=3Dsubmit>\n"=0A+     =
              "</form>\n"=0A+                   "<p>\n"=0A+                =
   "<p><table border>\n");=0A     =0A+           if( send(clntsock, buf, st=
rlen(buf), 0) !=3D strlen(buf) ){=0A+               fclose(fd_mdb);=0A+    =
           fclose(fd_clntsock);=0A+               die("send contenct failed=
 2b)");=0A+           }=0A =0A+   =0A            =0A-    if( send(clntsock,=
 buf, strlen(buf), 0) !=3D strlen(buf) ){=0A-    =0A-        perror("send c=
ontent failed");=0A-=0A-        break;=0A-=0A-    }=0A-=0A-    char row[100=
];=0A-    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){=0A-=0A-        i=
f( strcmp(row, "\n") =3D=3D 0){=0A-            printf("\n\n end \n\n");=0A-=
            break;=0A-        }=0A-=0A-=0A-        snprintf(buf, sizeof(buf=
), "<tr><td> %s\n", row);=0A-        //printf("%s\n", row) ;=0A-        //s=
trcat(html, row);=0A-=0A+          =0A+           =0A+           char row[1=
00];=0A+          =0A+           int even =3D 0;=0A+           =0A+        =
   while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){=0A+               if( s=
trcmp(row, "\n") =3D=3D 0){=0A+                   //printf("\n\n end \n\n")=
;=0A+                   break;=0A+               }=0A =0A-    if( send(clnt=
sock, buf, strlen(buf), 0) !=3D strlen(buf) ){=0A+               if(even++%=
2 =3D=3D 0){=0A+               =0A+                   snprintf(buf, sizeof(=
buf), "<tr><td> %s\n", row);=0A+               }else{=0A+                  =
 snprintf(buf, sizeof(buf), "<tr><td  bgcolor=3Dyellow> %s\n", row);=0A+=0A=
+               }=0A+               if( send(clntsock, buf, strlen(buf), 0)=
 !=3D strlen(buf) ){=0A+                   fclose(fd_mdb);=0A+             =
      fclose(fd_clntsock);=0A+                   die("send contenct failed =
2b)");=0A+               }=0A     =0A-        perror("send content failed")=
;=0A-=0A-        break;=0A-=0A-    }=0A-    }=0A-=0A-=0A-=0A-=0A-=0A-=0A-=
=0A-=0A+           }=0A =0A =0A         continue; =0A-       }=0A-=0A-=0A-=
=0A-       =0A-       ////////////////////////////////////////////=0A+     =
  }// end if ./mdb-lookup?key=3D=0A =0A =0A =0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A=
-=0A-       // check requestURI !!!!!!!!!!!!!!!!=0A-       //=0A-       =0A=
-       // check web_root=0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A-      =0A-=
=0A-=0A-=0A-=0A-=0A-       // printf("\nweb_root %s\n", web_root);=0A-=0A-=
=0A-       // log print out=0A-       fprintf(stderr, "\"%s %s %s\" %d OK\n=
",method, requestURI, httpVersion, 200);=0A+       // part2 a) continue  //=
////////=0A =0A        // retrive the file -- requestURI=0A        // 1. ma=
ke path=0A@@ -633,7 +432,6 @@ int main(int argc, char **argv) {=0A        s=
trcat(full_path, requestURI);  // char *file_path =3D strcat(web_root, requ=
estURI);=0A =0A =0A-=0A        // int stat(const char *path, struct stat *b=
uf);=0A        // success returns 0 & fill buf, error return -1=0A        /=
/ reference: https://www.ibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_73/apis/st=
at.htm =0A@@ -643,89 +441,73 @@ int main(int argc, char **argv) {=0A =0A =
=0A =0A-       // check ending char of path is '/' or not, return 400 error=
 code    =0A+       // check ending char of path is '/', if true, concat  i=
ndex.html =0A        if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){=0A=
-           // if ending with '/', attach index.html=0A            strcat(f=
ull_path_1, "index.html");=0A-           // printf("***********%s\n", full_=
path_1);=0A-=0A        }=0A-       /*=0A-       else{=0A-           // else=
 send 400 error code=0A-           char *html =3D cook_html(400);=0A-      =
     printf("html : \n%s",html);=0A-           if (send(clntsock, html, str=
len(html), 0) !=3D strlen(html) ){=0A-               free(html);=0A-       =
        die("send content failed");=0A-           }=0A-           free(html=
); =0A-           fclose(fd_clntsock);=0A-           continue;=0A-       }*=
/=0A-=0A-=0A-=0A+       =0A+       =0A        // if path/file exists, proce=
eds, else  =0A-       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds =
-- file exists, then check directory/file=0A-=0A-           printf("*******=
***  %s", full_path_1 );=0A+       if(stat(full_path_1, &status) =3D=3D 0){=
 // succeeds -- stat return none 0,  file not exists, then check directory/=
file=0A =0A-           // full_path ends with / or not=0A-           // pri=
ntf("***********%s\n",full_path_1);=0A-           // printf("%c, %c\n", '/'=
,full_path_1[strlen(full_path_1)-1] );=0A-           // if(full_path_1[strl=
en(full_path_1)-1] =3D=3D '/' ){=0A-           //        strcat(full_path_1=
, "index.html");=0A-           //        // printf("***********%s\n", full_=
path_1);=0A-           // }=0A+           //printf("**********  %s", full_p=
ath_1 );=0A+       =0A        }else{=0A =0A            //printf("\nfail doe=
s not exists:  %s\n", full_path_1 );=0A+            fprintf(stderr, "%d Not=
 Found\n", 404); =0A+            char *html_404 =3D =0A+                "HT=
TP/1.0 404 Not Found\r\n\r\n"=0A+                "<html><body><h1>404 Not F=
ound</h1></body></html>";=0A+=0A+            if (send(clntsock, html_404, s=
trlen(html_404), 0) !=3D strlen(html_404)){=0A+                   fclose(fd=
_mdb);=0A+                   fclose(fd_clntsock);=0A+                   die=
("send content failed");=0A+            }=0A =0A-           char *html =3D =
cook_html(404);=0A-           printf("html : \n%s",html);=0A-           if =
(send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){=0A-            =
   //free(html);=0A-               die("send content failed");=0A-         =
  }=0A-           free(html); =0A-           fclose(fd_clntsock);=0A-      =
     continue;=0A+            continue;=0A        } =0A =0A-       // 2. se=
nd response headers=0A+=0A+       fprintf(stderr, "200 OK\n");=0A+=0A+=0A+ =
      // 2. prepare response headers=0A        snprintf(buf, sizeof(buf), =
=0A                "HTTP/1.0 200 OK\r\n"=0A                "\r\n");=0A =0A =
       // 3. open file, read & send=0A-       // printf("\nfull_path_1: %s\=
n", full_path_1);=0A-       // printf("\nstat code: %d\n", stat(full_path_1=
, &status));=0A        FILE *file_requested =3D fopen(full_path_1, "rb");=
=0A-       if( file_requested =3D=3D NULL) =0A+       if( file_requested =
=3D=3D NULL){ =0A+               fclose(fd_mdb);=0A+               fclose(f=
d_clntsock);=0A                die("fail open file");=0A+       }=0A       =
 int size_read;=0A =0A        size_read =3D strlen(buf); // should be 19, h=
eader =0A        do{=0A-           printf("\n @@@@@@@@@@@@@@@@@@ %d \n",siz=
e_read); =0A+           //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read); =
=0A            if( send(clntsock, buf, size_read, 0) !=3D size_read ){=0A- =
              perror("send content failed");=0A-               break;=0A+  =
             fclose(fd_mdb);=0A+               fclose(fd_clntsock);=0A+    =
           die("send content failed");=0A            }=0A        }while(( s=
ize_read =3D fread(buf,1, sizeof(buf), file_requested)) > 0);=0A =0A =0A-  =
     //if(feof(file_requested) )=0A-       //    printf("file has not been =
fully read");=0A-=0A        fclose(file_requested);=0A        fclose(fd_cln=
tsock);=0A =0A-       fclose(fd_mdb);=0A-=0A-=0A+       fprintf(stdout, "\n=
");=0A     }// while (1)=0A =0A+       =0A+    =0A+=0A+ =0A+    fclose(fd_m=
db);=0A     return 0;=0A }=0A-- =0A2.17.1=0A=0A=0AFrom 58ac4b4732ec355c52b3=
dab752eb8e3684cea079 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@co=
lumbia.edu>=0ADate: Thu, 5 May 2022 22:22:07 -0400=0ASubject: [PATCH 4/6] f=
inish test, part2 ab both work on firefox=0A=0A---=0A http-server.c | 78 ++=
+++++++------------------------------------------=0A 1 file changed, 14 ins=
ertions(+), 64 deletions(-)=0A=0Adiff --git a/http-server.c b/http-server.c=
=0Aindex befd329..7387137 100644=0A--- a/http-server.c=0A+++ b/http-server.=
c=0A@@ -29,30 +29,6 @@ static void printUsage() {=0A     exit(1);=0A }=0A =
=0A-char* cook_html(int code){ // char* content=0A-=0A-    char *html =3D (=
char *) malloc(1000 * sizeof(char));=0A-=0A-    char *error_code_prompt;=0A=
-    if(code =3D=3D 501)=0A-        error_code_prompt =3D  "Not Implemented=
";=0A-    if(code =3D=3D 400)=0A-        error_code_prompt =3D  "Bad Reques=
t";=0A-    if(code =3D=3D 404)=0A-        error_code_prompt =3D "Not Found"=
;=0A-=0A-=0A-    snprintf(html, 1000,  //sizeof(html), =0A-            "HTT=
P/1.0 %d %s\r\n"=0A-            "\r\n"=0A-            //"<html>\r\n<body>\r=
\n<h1>%d %s</h1>\r\n</body>\r\n</html>\r\n",=0A-            "<html><body><h=
1>%d %s</h1></body></html>",=0A-            code, error_code_prompt, code, =
error_code_prompt);=0A-    printf("\n\n%s\\n\n", html);=0A-    return html;=
=0A-}=0A-=0A-=0A =0A =0A =0A@@ -115,7 +91,6 @@ int main(int argc, char **ar=
gv) {=0A     int mdb_sock;=0A     struct sockaddr_in mdb_serverAddr;=0A    =
 struct hostent *mdb_he;=0A-    // char buf_2[BUF_SIZE];                   =
 // necessary?=0A =0A      =0A     // get mdb-lookup server ip from mdb-ser=
ver name=0A@@ -124,15 +99,6 @@ int main(int argc, char **argv) {=0A     }=
=0A     mdb_serverIP =3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);=0A =
=0A-    /* for debugging=0A-       printf("1: %s\n", mdb_serverName);=0A-  =
     printf("2: %s\n", mdb_serverIP);=0A-       printf("3: %s\n", mdb_serve=
rPort);=0A-       printf("4: %s\n", filePath);=0A-       printf("5: %s\n", =
fname);=0A-       */=0A-=0A-=0A     // create socket=0A     if ((mdb_sock =
=3D socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {=0A 	die("socket faile=
d");=0A@@ -300,23 +266,17 @@ int main(int argc, char **argv) {=0A =0A      =
   // printf("2333333333333333333333333333"); fflush(stdout);=0A =0A-=0A-=
=0A          =0A =0A        ///////////////   part 2 b=0A =0A-=0A-         =
  //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requestURI=
, "/mdb-lookup"));=0A-=0A        // http://clac.cs.columbia.edu:41782/mdb-l=
ookup =0A        if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){=0A =0A   =
         //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(req=
uestURI, "/mdb-lookup"));=0A-       =0A            fprintf(stderr, "200 OK\=
n");=0A            const char *form =3D=0A-               "HTTP 200 OK\r\n"=
=0A+               "HTTP/1.0 200 OK\r\n"=0A                "\r\n"=0A       =
         "<h1>mdb-lookup</h1>\n"=0A                "<p>\n"=0A@@ -333,35 +29=
3,24 @@ int main(int argc, char **argv) {=0A            }=0A =0A           =
 //printf("\n\n send, you should see search page  \n\n");=0A+           fcl=
ose(fd_clntsock);=0A            continue; =0A       =0A        }=0A =0A-=0A=
-=0A       =0A        // http://clac.cs.columbia.edu:41782/mdb-lookup?key=
=3Dhello =0A        if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D=
0 ){=0A =0A            //printf("2222222222222222  (%s), %d\n\n\n", request=
URI, strncmp(requestURI, "/mdb-lookup?key=3D",16 ));=0A-      =0A          =
  // printf("\n(%s)\n",requestURI);=0A-=0A-        =0A            for(int i=
=3D0; i<16; i++){=0A-           =0A                requestURI++;=0A-       =
 =0A            }=0A-           =0A-       =0A            strcat(requestURI=
, "\n");=0A         =0A            // printf("\n(%s)\n",requestURI);=0A-=0A=
            // send    =0A-=0A-    =0A            if (send(mdb_sock, reques=
tURI, strlen(requestURI), 0) !=3D strlen(requestURI)) {=0A                f=
close(fd_mdb);=0A                fclose(fd_clntsock);=0A@@ -388,14 +337,8 @=
@ int main(int argc, char **argv) {=0A                die("send contenct fa=
iled 2b)");=0A            }=0A =0A-   =0A-           =0A-          =0A-    =
       =0A            char row[100];=0A-          =0A            int even =
=3D 0;=0A-           =0A            while(fgets(row, sizeof(row), fd_mdb)!=
=3D NULL){=0A                if( strcmp(row, "\n") =3D=3D 0){=0A           =
         //printf("\n\n end \n\n");=0A@@ -417,8 +360,8 @@ int main(int argc=
, char **argv) {=0A     =0A            }=0A =0A-=0A-        continue; =0A+ =
          fclose(fd_clntsock);=0A+           continue; =0A        }// end i=
f ./mdb-lookup?key=3D=0A =0A =0A@@ -454,8 +397,15 @@ int main(int argc, cha=
r **argv) {=0A        =0A        }else{=0A =0A+           printf("*********=
*  %s", full_path_1 );=0A+           fprintf(stderr, "%d Not Found\n", 404)=
; =0A+           if( strcmp(full_path,"/mnt/disks/students221/yz4004/html/c=
s3157/tng/favicon.ico" ) =3D=3D 0 ){=0A+=0A+               break;=0A+      =
     }=0A+=0A+=0A            //printf("\nfail does not exists:  %s\n", full=
_path_1 );=0A-            fprintf(stderr, "%d Not Found\n", 404); =0A      =
       char *html_404 =3D =0A                 "HTTP/1.0 404 Not Found\r\n\r=
\n"=0A                 "<html><body><h1>404 Not Found</h1></body></html>";=
=0A@@ -492,6 +442,7 @@ int main(int argc, char **argv) {=0A            //pr=
intf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read); =0A            if( send(clnt=
sock, buf, size_read, 0) !=3D size_read ){=0A                fclose(fd_mdb)=
;=0A+               fclose(file_requested);=0A                fclose(fd_cln=
tsock);=0A                die("send content failed");=0A            }=0A@@ =
-501,10 +452,9 @@ int main(int argc, char **argv) {=0A        fclose(file_r=
equested);=0A        fclose(fd_clntsock);=0A =0A-       fprintf(stdout, "\n=
");=0A+       //fprintf(stdout, "\n");=0A     }// while (1)=0A =0A-       =
=0A     =0A =0A  =0A-- =0A2.17.1=0A=0A=0AFrom edbc31cfe47c1bfb59c17b691baed=
94f59b45d78 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.ed=
u>=0ADate: Thu, 5 May 2022 22:24:34 -0400=0ASubject: [PATCH 5/6] modify REA=
DME=0A=0A---=0A README.txt | 7 +++++++=0A 1 file changed, 7 insertions(+)=
=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 66dfd3e..e571053 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -9,3 +9,10 @@ The description s=
hould indicate whether your solution for the part is=0A working or not.  Yo=
u may also want to include anything else you would=0A like to communicate t=
o the grader such as extra functionalities you=0A implemented or how you tr=
ied to fix your non-working code.=0A+=0A+=0A+Yixuan Zou=0A+yz4004=0A+lab7=
=0A+=0A+part2 a) b) both work on firefox.=0A-- =0A2.17.1=0A=0A=0AFrom 2195a=
ddaa7c9f6178a534a0e51477319b2fa53fc Mon Sep 17 00:00:00 2001=0AFrom: Yixuan=
_Zou <yz4004@columbia.edu>=0ADate: Thu, 5 May 2022 23:44:57 -0400=0ASubject=
: [PATCH 6/6] modify error prompt=0A=0A---=0A http-server.c | 79 ++++++++++=
+++++++++++++++++++++++++----------------=0A 1 file changed, 54 insertions(=
+), 25 deletions(-)=0A=0Adiff --git a/http-server.c b/http-server.c=0Aindex=
 7387137..ec99309 100644=0A--- a/http-server.c=0A+++ b/http-server.c=0A@@ -=
142,7 +142,7 @@ int main(int argc, char **argv) {=0A =0A         if ((clnts=
ock =3D accept(servsock,=0A                         (struct sockaddr * ) &c=
lntaddr, &clntlen)) < 0){=0A-            //perror("next clinet");=0A+      =
      perror("clinet crash");=0A             //die("accept fail");=0A      =
       continue; =0A         }=0A@@ -164,11 +164,16 @@ int main(int argc, c=
har **argv) {=0A         char requestLine[1000]; =0A         if(fgets(reque=
stLine, sizeof(requestLine), fd_clntsock) =3D=3D NULL ){=0A             // =
fail to read request line, (maybe clnt crash/close connection -- fail to se=
nd request), skip current clnt to next one.=0A-            fprintf(stderr, =
"clnt crashes");=0A-            //fclose(fd_clntsock); no need=0A+         =
   // fprintf(stderr, "clnt crashes");=0A+            fclose(fd_clntsock); =
//no need?=0A             continue;=0A         }=0A =0A+       // check fge=
ts error =0A+       if (ferror(fd_clntsock)){=0A+           perror("fd_clnt=
sock error");=0A+       }=0A+=0A         // parse browser http request line=
=0A         char *token_separators =3D "\t \r\n"; // tab, space, new line=
=0A         char *method =3D strtok(requestLine, token_separators);=0A@@ -2=
17,9 +222,10 @@ int main(int argc, char **argv) {=0A =0A             //prin=
tf("html : \n%s",html);=0A             if (send(clntsock, html_501, strlen(=
html_501), 0) !=3D strlen(html_501)){=0A-               fclose(fd_mdb);=0A+=
               //fclose(fd_mdb);=0A                fclose(fd_clntsock); =0A=
-               die("send content failed");=0A+               //die("send c=
ontent failed");=0A+               perror("send content failed");=0A       =
      }=0A =0A             continue;=0A@@ -234,9 +240,10 @@ int main(int ar=
gc, char **argv) {=0A                 "<html><body><h1>501 Not Implemented<=
/h1></body></html>";=0A =0A             if (send(clntsock, html_501, strlen=
(html_501), 0) !=3D strlen(html_501)){=0A-               fclose(fd_mdb);=0A=
+               //fclose(fd_mdb);=0A                fclose(fd_clntsock);=0A=
-               die("send content failed");=0A+               //die("send c=
ontent failed");=0A+               perror("send content failed");=0A       =
      }=0A =0A             continue;=0A@@ -255,9 +262,10 @@ int main(int ar=
gc, char **argv) {=0A                 "<html><body><h1>400 Bad Request</h1>=
</body></html>";=0A =0A             if (send(clntsock, html_400, strlen(htm=
l_400), 0) !=3D strlen(html_400)){=0A-               fclose(fd_mdb);=0A+   =
            //fclose(fd_mdb);=0A                fclose(fd_clntsock);=0A-   =
            die("send content failed");=0A+               //die("send conte=
nt failed");=0A+               perror("send content failed");=0A           =
  }=0A =0A             continue;=0A@@ -287,9 +295,10 @@ int main(int argc, =
char **argv) {=0A                "<p>\n";=0A =0A            if (send(clntso=
ck, form, strlen(form), 0) !=3D strlen(form) ){=0A-               fclose(fd=
_mdb);=0A+               //fclose(fd_mdb);=0A                fclose(fd_clnt=
sock);=0A-               die("send content failed");=0A+               //di=
e("send content failed");=0A+               perror("send content failed");=
=0A            }=0A =0A            //printf("\n\n send, you should see sear=
ch page  \n\n");=0A@@ -312,9 +321,10 @@ int main(int argc, char **argv) {=
=0A            // printf("\n(%s)\n",requestURI);=0A            // send    =
=0A            if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D s=
trlen(requestURI)) {=0A-               fclose(fd_mdb);=0A+               //=
fclose(fd_mdb);=0A                fclose(fd_clntsock);=0A-               di=
e("send failed");=0A+               //die("send failed");=0A+              =
 perror("send failed");=0A            }=0A           =0A        =0A@@ -332,=
9 +342,10 @@ int main(int argc, char **argv) {=0A                    "<p><t=
able border>\n");=0A     =0A            if( send(clntsock, buf, strlen(buf)=
, 0) !=3D strlen(buf) ){=0A-               fclose(fd_mdb);=0A+             =
  //fclose(fd_mdb);=0A                fclose(fd_clntsock);=0A-             =
  die("send contenct failed 2b)");=0A+               //die("send contenct f=
ailed 2b)");=0A+               perror("send content failed");=0A           =
 }=0A =0A            char row[100];=0A@@ -353,13 +364,18 @@ int main(int ar=
gc, char **argv) {=0A =0A                }=0A                if( send(clnts=
ock, buf, strlen(buf), 0) !=3D strlen(buf) ){=0A-                   fclose(=
fd_mdb);=0A+                   //fclose(fd_mdb);=0A                    fclo=
se(fd_clntsock);=0A-                   die("send contenct failed 2b)");=0A+=
                   //die("send contenct failed 2b)");=0A+                  =
 perror("send content failed");=0A                }=0A     =0A+           }=
 // end while, fget from fb_mdb=0A+       =0A+           // check fgets fd_=
mdb =0A+           if (ferror(fd_mdb)){=0A+               perror("fgets fd_=
mdb error");=0A            }=0A-=0A            fclose(fd_clntsock);=0A     =
       continue; =0A        }// end if ./mdb-lookup?key=3D=0A@@ -397,7 +413=
,7 @@ int main(int argc, char **argv) {=0A        =0A        }else{=0A =0A-=
           printf("**********  %s", full_path_1 );=0A+           //printf("=
**********  %s", full_path_1 );=0A            fprintf(stderr, "%d Not Found=
\n", 404); =0A            if( strcmp(full_path,"/mnt/disks/students221/yz40=
04/html/cs3157/tng/favicon.ico" ) =3D=3D 0 ){=0A =0A@@ -411,9 +427,10 @@ in=
t main(int argc, char **argv) {=0A                 "<html><body><h1>404 Not=
 Found</h1></body></html>";=0A =0A             if (send(clntsock, html_404,=
 strlen(html_404), 0) !=3D strlen(html_404)){=0A-                   fclose(=
fd_mdb);=0A+                   //fclose(fd_mdb);=0A                    fclo=
se(fd_clntsock);=0A-                   die("send content failed");=0A+     =
              //die("send content failed");=0A+                   perror("s=
end content failed");=0A             }=0A =0A             continue;=0A@@ -4=
41,14 +458,27 @@ int main(int argc, char **argv) {=0A        do{=0A        =
    //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read); =0A            if( s=
end(clntsock, buf, size_read, 0) !=3D size_read ){=0A-               fclose=
(fd_mdb);=0A+               //fclose(fd_mdb);=0A                fclose(file=
_requested);=0A-               fclose(fd_clntsock);=0A-               die("=
send content failed");=0A+               perror("send content failed");=0A+=
               break;=0A+               //fclose(fd_clntsock);=0A+         =
      //die("send content failed");=0A            }=0A        }while(( size=
_read =3D fread(buf,1, sizeof(buf), file_requested)) > 0);=0A =0A =0A+     =
  // fread() returns 0 on EOF or on error=0A+       // so we need to check =
if there was an error.=0A+       if (ferror(file_requested)){=0A+          =
 //fclose(fd_mdb);=0A+           fclose(fd_clntsock);=0A+           //die("=
fread failed");=0A+           perror("fread failed");=0A+       }=0A+   =0A=
+       =0A+=0A        fclose(file_requested);=0A        fclose(fd_clntsock=
);=0A =0A@@ -456,7 +486,6 @@ int main(int argc, char **argv) {=0A     }// w=
hile (1)=0A =0A     =0A-=0A  =0A     fclose(fd_mdb);=0A     return 0;=0A-- =
=0A2.17.1=0A=0A
--/04w6evG8XlLl3ft--

From do.not.reply@cloud.cs.columbia.edu Thu May  5 23:49:25 2022
Date: Thu, 5 May 2022 23:49:25 -0400
From: do.not.reply@cloud.cs.columbia.edu
To: cs3157@gmail.com, yz4004@columbia.edu, yz4004@barnard.edu
Subject: yz4004-lab7.mbox
Message-ID: <20220506034925.GA3880@clac.cs.columbia.edu>
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary="envbJBWh7q8WU6mo"
Content-Disposition: inline
User-Agent: Mutt/1.9.4 (2018-02-28)
Status: RO
Content-Length: 112560
Lines: 2783


--envbJBWh7q8WU6mo
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

=46rom 9c1b686e24e076e8292f46bee5102b36e24c340f Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 19:33:12 -0400
Subject: [PATCH 1/7] draft 1

---
 http-server.c | 731 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 731 insertions(+)
 create mode 100644 http-server.c

diff --git a/http-server.c b/http-server.c
new file mode 100644
index 0000000..3e57ef6
--- /dev/null
+++ b/http-server.c
@@ -0,0 +1,731 @@
+/*
+ * http-server.c
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <netdb.h>
+
+#include <assert.h> =20
+#include <sys/wait.h> =20
+#include <sys/stat.h>
+
+
+#define BUF_SIZE 4096
+
+static void die(const char *msg) {
+    perror(msg);
+    exit(1);
+}
+
+static void printUsage() {
+    fprintf(stderr, "usage: http-server <server_port> <web_root> <mdb-look=
up-host> <mdb-lookup-port>\n");
+    fprintf(stderr, "   ex) http-server www.example.com 80 /index.html\n");
+    exit(1);
+}
+
+char* cook_html(int code){ // char* content
+
+    char *html =3D (char *) malloc(1000 * sizeof(char));
+
+    char *error_code_prompt;
+    if(code =3D=3D 501)
+        error_code_prompt =3D  "Not Implemented";
+    if(code =3D=3D 400)
+        error_code_prompt =3D  "Bad Request";
+    if(code =3D=3D 404)
+        error_code_prompt =3D "Not Found";
+
+
+    snprintf(html, 1000,  //sizeof(html),=20
+            "HTTP/1.0 %d %s\r\n"
+            "\r\n"
+            //"<html>\r\n<body>\r\n<h1>%d %s</h1>\r\n</body>\r\n</html>\r\=
n",
+            "<html><body><h1>%d %s</h1></body></html>",
+            code, error_code_prompt, code, error_code_prompt);
+    printf("\n\n%s\\n\n", html);
+    return html;
+}
+
+
+
+
+
+int main(int argc, char **argv) {
+
+    // Ignore SIGPIPE so that we don=E2=80=99t terminate when we call
+    // send() on a disconnected socket
+    if (signal(SIGPIPE, SIG_IGN) =3D=3D SIG_ERR)
+        die("signal() failed");=20
+   =20
+    if (argc !=3D 5) {
+	printUsage();
+    }
+
+    // Assign server_port and web_root to correct command line arguments
+
+    unsigned short serv_port =3D atoi(argv[1]);
+    const char *web_root =3D argv[2];
+   =20
+
+    // Create a listening socket (also called server socket)=20
+
+    int servsock;
+    if ((servsock =3D socket(AF_INET, SOCK_STREAM, 0)) < 0)
+        die("socket failed");
+
+    // Construct local address structure
+
+    struct sockaddr_in servaddr;
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family =3D AF_INET;
+    servaddr.sin_addr.s_addr =3D htonl(INADDR_ANY); // any network interfa=
ce
+    servaddr.sin_port =3D htons(serv_port);
+
+    // Bind to the local address
+
+    if (bind(servsock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < =
0)
+        die("bind failed");
+
+    // Start listening for incoming connections
+
+    if (listen(servsock, 5 /* queue size for connection requests */ ) < 0)
+        die("listen failed");
+
+    int clntsock;
+    socklen_t clntlen;
+    struct sockaddr_in clntaddr;
+
+
+    // +-------------------------------------------
+    // part2 b
+
+    // create a mdb-lookup-server sock, now I'm a client to mdb-lookup-ser=
ver, and as a client, I only need server sock.
+
+    char *mdb_serverName =3D argv[3];
+    char *mdb_serverIP;
+    unsigned short mdb_serverPort =3D atoi(argv[4]);
+
+
+    int mdb_sock;
+    struct sockaddr_in mdb_serverAddr;
+    struct hostent *mdb_he;
+    // char buf_2[BUF_SIZE];                    // necessary?
+
+    =20
+    // get mdb-lookup server ip from mdb-server name
+    if ((mdb_he =3D gethostbyname(mdb_serverName)) =3D=3D NULL) {
+	die("gethostbyname failed");
+    }
+    mdb_serverIP =3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);
+
+    /* for debugging
+       printf("1: %s\n", mdb_serverName);
+       printf("2: %s\n", mdb_serverIP);
+       printf("3: %s\n", mdb_serverPort);
+       printf("4: %s\n", filePath);
+       printf("5: %s\n", fname);
+       */
+
+
+    // create socket
+    if ((mdb_sock =3D socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
+	die("socket failed");
+    }
+
+
+    // construct mdb-lookup server address
+    memset(&mdb_serverAddr, 0, sizeof(mdb_serverAddr));
+    mdb_serverAddr.sin_family =3D AF_INET;
+    mdb_serverAddr.sin_addr.s_addr =3D inet_addr(mdb_serverIP);
+    mdb_serverAddr.sin_port =3D htons(mdb_serverPort);
+
+    // connect
+    if (connect(mdb_sock, (struct sockaddr *)&mdb_serverAddr, sizeof(mdb_s=
erverAddr)) < 0) {
+	die("connect failed");
+    }
+
+   =20
+   =20
+    // wrap the socket with a file* so that we can read the socket using f=
gets()
+    FILE *fd_mdb;
+    if ((fd_mdb =3D fdopen(mdb_sock, "r")) =3D=3D NULL) {
+	die("fdopen failed mdb_sock");
+    }
+
+
+
+    // +-------------------------------------------
+
+    int count =3D 0;
+    while (1) {
+
+        printf("\n$ %d \n", count++);
+
+        char buf[4096];
+
+
+        // Accept an incoming connection
+
+        clntlen =3D sizeof(clntaddr); // initialize the in-out parameter
+
+        if ((clntsock =3D accept(servsock,
+                        (struct sockaddr * ) &clntaddr, &clntlen)) < 0){
+            //perror("next clinet");
+            //die("accept fail");
+            continue;=20
+        }
+
+        // accept() returned a connected socket (also called client socket)
+        // and filled in the client's address into clntaddr
+
+
+        // fd_clntsock, for clnt/browser
+        FILE *fd_clntsock; =20
+        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL) {  =20
+           // if i cannot open clntsock, is it a clnt crash issue? No, my =
problem. die=20
+            die("fdopen failed");
+        }
+
+
+
+        // read GET request from FILE *fd_clntsock, clnt request from brow=
ser
+        char requestLine[1000];=20
+        if(fgets(requestLine, sizeof(requestLine), fd_clntsock) =3D=3D NUL=
L ){
+            // fail to read request line, (maybe clnt crash/close connecti=
on -- fail to send request), skip current clnt to next one.
+            fprintf(stderr, "clnt crashes");
+            //fclose(fd_clntsock); no need
+            continue;
+        }
+
+        // parse browser http request line
+        char *token_separators =3D "\t \r\n"; // tab, space, new line
+        char *method =3D strtok(requestLine, token_separators);
+        //  printf("1 method:(%s)", method);
+        // printf("1 requestLine:(%s)", requestLine);
+      =20
+        char *requestURI =3D strtok(NULL, token_separators);
+        // printf("2 requestURI:(%s)", requestURI);
+        // printf("2 requestLine:(%s)", requestLine);
+      =20
+        char *httpVersion =3D strtok(NULL, token_separators);
+        // printf("3 httpVersion:(%s)", httpVersion);
+        // printf("3 requestLine:(%s)", requestLine);
+
+        /*
+           1 method:(GET)
+           1 requestLine:(GET)
+           2 requestURI:(/~yz4004/cs3157/tng/index.html)
+           2 requestLine:(GET)
+           3 httpVersion:(HTTP/1.1)
+           3 requestLine:(GET)$ 1*/
+
+        // print log through stderr, whether it's legal or not. if wrong p=
ut error code later.
+        fprintf(stderr, "%s \"%s %s\" ",
+                inet_ntoa(clntaddr.sin_addr),
+                method,
+                requestURI);
+
+
+
+
+/*
+           int html_size ;=20
+           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) !=
=3D 0 ){
+             printf("html: \n%s", buf);
+           }=20
+           fflush(stdout);
+ =20
+*/
+          =20
+
+
+        // Now parse method and httpVersion first, and then requestURI.=20
+        // 1. check GET keyword
+        if (strncmp(method, "GET", 3) !=3D 0 ){ //=20
+
+            // fclose(fd_clntsock); no need to turn this off, since this c=
lnt fails, we continue to next clnt (while 1)
+            // fd_clntsock created again & cover old one. Not simple die p=
rogram
+            // as long as program keep running, no need to close/free sinc=
e we do that at the end, unless die program.
+
+            // send error 501 http to clnt & output log
+            fprintf(stderr, "%d\n", 501);=20
+
+            char *html_501 =3D=20
+                "HTTP/1.0 501 Not Implemented"
+                "<html><body><h1>501 Not Implemented</h1></body></html>";
+
+            //printf("html : \n%s",html);
+            if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
+                die("send content failed");
+            }
+
+            continue;
+        }
+     =20
+        // 2. check whether http 1.0 or 1.1 protocol
+        if (strncmp("HTTP/1.0", httpVersion, 8) !=3D 0 && strncmp("HTTP/1.=
1", httpVersion, 8) !=3D 0) {
+       =20
+            fprintf(stderr, "\"%s %s %s\" %d\n",method, requestURI, httpVe=
rsion, 501);=20
+         =20
+            fclose(fd_clntsock);
+          =20
+
+          =20
+            char *html =3D cook_html(501);
+          =20
+            //size =3D snprintf(buf, sizeof(buf),"%s" , html);
+          =20
+            printf("html : \n%s",html);
+          =20
+            if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
+         =20
+                //free(html);
+         =20
+                die("send content failed");
+         =20
+            }
+         =20
+            free(html);=20
+         =20
+            continue;
+      =20
+        }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+       ///////////////   part 2 b
+
+
+           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
+
+       // http://clac.cs.columbia.edu:41782/mdb-lookup=20
+       if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){
+
+           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
+
+           const char *form =3D
+               "HTTP 200 OK\r\n"
+               "\r\n"
+               "<h1>mdb-lookup</h1>\n"
+               "<p>\n"
+               "<form method=3DGET action=3D/mdb-lookup>\n"
+               "lookup: <input type=3Dtext name=3Dkey>\n"
+               "<input type=3Dsubmit>\n"
+               "</form>\n"
+               "<p>\n";
+
+           if (send(clntsock, form, strlen(form), 0) !=3D strlen(form) ){
+               die("send content failed");
+           }
+
+
+           printf("\n\n send, you should see search page  \n\n");
+
+
+          continue;=20
+       }
+
+
+
+       // http://clac.cs.columbia.edu:41782/mdb-lookup?key=3Dhello=20
+       if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){
+
+           printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncmp(=
requestURI, "/mdb-lookup?key=3D",16 ));
+
+
+        /*
+        FILE *fd_clntsock;  // fp_servsock
+        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // fp=
_servsock =3D fdopen(servsock, "r")=20
+            die("fdopen failed");
+        }*/
+
+
+        // printf("why2");
+        // fflush(stdout);
+
+
+        /*
+           int html_size;=20
+           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) > 0=
 ){
+             printf("html: \n%s", buf);
+           }  =20
+
+
+        printf("||||||||||||||||||||||||||");
+        fflush(stdout);
+       =20
+        FILE *fd_clntsock_1;  // fp_servsock
+        if ((fd_clntsock_1 =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // =
fp_servsock =3D fdopen(servsock, "r")=20
+            die("fdopen failed");
+        }
+
+
+           //=20
+           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=
=3D 0 ){
+
+               printf("html: \n%s", buf);
+
+           }*/  =20
+       =20
+
+=20
+     =20
+           /*
+           // int html_size ;=20
+           // int i =3D 0;
+
+
+           // printf("\n%ld, %s \n", fread(buf,1,30,fd_clntsock), buf );=
=20
+           // printf("\n%ld\n", fread(buf,1,sizeof(buf),fd_clntsock));=20
+
+           // while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) =
>  0 ){
+
+           printf("_____ %d\n", i++);
+           fflush(stdout);
+             printf("html: \n%s", buf);
+             printf("88888 %d\n", i );
+             fflush(stdout);
+             break;
+            =20
+           } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =
=E4=BD=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=
=85=A5size? =20
+
+           /* // =E6=A3=80=E6=9F=A5 header
+           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
+               printf("\nHeaders: %s\n", buf);
+           }
+           fgets(buf,sizeof(buf), fd_clntsock);
+           printf("$$$$$$$$ %s", buf);
+
+           fgets(buf,sizeof(buf), fd_clntsock);
+           printf("*** $$$$$$$$ %s", buf);
+           */
+
+
+       =20
+        // printf("\n(%s)\n",requestURI);
+
+        for(int i=3D0; i<16; i++){
+            requestURI++;
+        }
+        strcat(requestURI, "\n");
+        // printf("\n(%s)\n",requestURI);
+
+
+
+        // =E6=88=91=E8=A6=81=E6=8A=8A=E4=B8=9C=E8=A5=BF search key send =
=E7=BB=99 mdb-lookup-server
+        //
+
+
+        printf("\n(%s)\n",requestURI);
+
+       // =E6=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=
=E4=BA=86=EF=BC=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2
+   =20
+    //printf("=1A=1A")   =20
+    if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strlen(requ=
estURI)) {
+	die("send failed");
+    }
+
+
+
+    /*
+           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
+               printf("\nHeaders: %s\n", buf);
+           }
+           */
+           // fgets(buf,sizeof(buf), fd_mdb);
+           // printf("$$$$$$$$ %s", buf);
+
+
+    /*
+           printf("\n\n 11111111111111111111111111111111------------------=
--------\n\n");
+
+           fgets(buf,sizeof(buf), fd_mdb);
+           printf("*** $$$$$$$$ %s", buf);
+
+           printf("\n\n 22222222222222222222222222222222------------------=
--------\n\n");
+
+           fgets(buf,sizeof(buf), fd_mdb);
+           printf("*** $$$$$$$$ %s", buf);
+      */
+
+
+
+
+  /*     =20
+    char html[10000];
+    strcpy(html,
+        "HTTP 200 OK\r\n"      =20
+        "\r\n"
+              =20
+        "<h1>mdb-lookup</h1>\n"
+              =20
+        "<p>\n"
+              =20
+        "<form method=3DGET action=3D/mdb-lookup>\n"
+              =20
+        "lookup: <input type=3Dtext name=3Dkey>\n"
+              =20
+        "<input type=3Dsubmit>\n"
+              =20
+        "</form>\n"
+              =20
+        "<p>\n"
+
+        "<p><table border>\n");
+
+
+        printf("0000000000000000000000000000000000000000000000000000000000=
000000\n");
+    char row[100];
+    while(fgets(buf, sizeof(buf), fd_mdb)!=3D NULL ){
+
+        if( strcmp(buf, "\n") =3D=3D 0){
+            printf("\n\n end \n\n");
+            break;
+        }
+
+        snprintf(row, sizeof(row), "<tr><td> %s\n", buf);
+        printf("%s\n", row );
+        strcat(html, row);
+
+     =20
+       =20
+    }
+
+    strcat(html, "</table>\n</body>\n</html>");
+
+
+    printf("\n\n%s\n\n", html);
+*/
+
+
+
+   =20
+    strcpy(buf,
+        "HTTP 200 OK\r\n"      =20
+        "\r\n"
+              =20
+        "<h1>mdb-lookup</h1>\n"
+              =20
+        "<p>\n"
+              =20
+        "<form method=3DGET action=3D/mdb-lookup>\n"
+              =20
+        "lookup: <input type=3Dtext name=3Dkey>\n"
+              =20
+        "<input type=3Dsubmit>\n"
+              =20
+        "</form>\n"
+              =20
+        "<p>\n"
+
+        "<p><table border>\n");
+
+   =20
+
+          =20
+    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+   =20
+        perror("send content failed");
+
+        break;
+
+    }
+
+    char row[100];
+    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
+
+        if( strcmp(row, "\n") =3D=3D 0){
+            printf("\n\n end \n\n");
+            break;
+        }
+
+
+        snprintf(buf, sizeof(buf), "<tr><td> %s\n", row);
+        //printf("%s\n", row) ;
+        //strcat(html, row);
+
+
+    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+   =20
+        perror("send content failed");
+
+        break;
+
+    }
+    }
+
+
+
+
+
+
+
+
+
+
+        continue;=20
+       }
+
+
+
+      =20
+       ////////////////////////////////////////////
+
+
+
+
+
+
+
+
+
+
+
+       // check requestURI !!!!!!!!!!!!!!!!
+       //
+      =20
+       // check web_root
+
+
+
+
+
+
+
+
+
+     =20
+
+
+
+
+
+       // printf("\nweb_root %s\n", web_root);
+
+
+       // log print out
+       fprintf(stderr, "\"%s %s %s\" %d OK\n",method, requestURI, httpVers=
ion, 200);
+
+       // retrive the file -- requestURI
+       // 1. make path
+       char full_path[100];  // should not be " char *full_path;" has to h=
ave len
+       strcpy(full_path, web_root);
+       strcat(full_path, requestURI);  // char *file_path =3D strcat(web_r=
oot, requestURI);
+
+
+
+       // int stat(const char *path, struct stat *buf);
+       // success returns 0 & fill buf, error return -1
+       // reference: https://www.ibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_7=
3/apis/stat.htm=20
+       struct stat status;
+       char full_path_1[strlen(full_path)];
+       strcpy(full_path_1, full_path);
+
+
+
+       // check ending char of path is '/' or not, return 400 error code  =
 =20
+       if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
+           // if ending with '/', attach index.html
+           strcat(full_path_1, "index.html");
+           // printf("***********%s\n", full_path_1);
+
+       }
+       /*
+       else{
+           // else send 400 error code
+           char *html =3D cook_html(400);
+           printf("html : \n%s",html);
+           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
+               free(html);
+               die("send content failed");
+           }
+           free(html);=20
+           fclose(fd_clntsock);
+           continue;
+       }*/
+
+
+
+       // if path/file exists, proceeds, else =20
+       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds -- file exists=
, then check directory/file
+
+           printf("**********  %s", full_path_1 );
+
+           // full_path ends with / or not
+           // printf("***********%s\n",full_path_1);
+           // printf("%c, %c\n", '/',full_path_1[strlen(full_path_1)-1] );
+           // if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
+           //        strcat(full_path_1, "index.html");
+           //        // printf("***********%s\n", full_path_1);
+           // }
+       }else{
+
+           //printf("\nfail does not exists:  %s\n", full_path_1 );
+
+           char *html =3D cook_html(404);
+           printf("html : \n%s",html);
+           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
+               //free(html);
+               die("send content failed");
+           }
+           free(html);=20
+           fclose(fd_clntsock);
+           continue;
+       }=20
+
+       // 2. send response headers
+       snprintf(buf, sizeof(buf),=20
+               "HTTP/1.0 200 OK\r\n"
+               "\r\n");
+
+       // 3. open file, read & send
+       // printf("\nfull_path_1: %s\n", full_path_1);
+       // printf("\nstat code: %d\n", stat(full_path_1, &status));
+       FILE *file_requested =3D fopen(full_path_1, "rb");
+       if( file_requested =3D=3D NULL)=20
+               die("fail open file");
+       int size_read;
+
+       size_read =3D strlen(buf); // should be 19, header=20
+       do{
+           printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
+           if( send(clntsock, buf, size_read, 0) !=3D size_read ){
+               perror("send content failed");
+               break;
+           }
+       }while(( size_read =3D fread(buf,1, sizeof(buf), file_requested)) >=
 0);
+
+
+       //if(feof(file_requested) )
+       //    printf("file has not been fully read");
+
+       fclose(file_requested);
+       fclose(fd_clntsock);
+
+       fclose(fd_mdb);
+
+
+    }// while (1)
+
+    return 0;
+}
--=20
2.17.1


=46rom dbe85f545b93c3d04f51b3eae63e7c4adce22c71 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 19:33:36 -0400
Subject: [PATCH 2/7] add makefile

---
 Makefile | 29 +++++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)
 create mode 100644 Makefile

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..a95373e
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,29 @@
+
+#
+# Makefile for lab 7, part 2
+#
+
+CC  =3D gcc
+CXX =3D g++
+
+CFLAGS   =3D -g -Wall $(INCLUDES)
+CXXFLAGS =3D -g -Wall $(INCLUDES)
+
+
+.PHONY: default
+default: http-server=20
+
+# header dependency
+## mdb-lookup-server.o: mdb.h
+
+
+
+.PHONY: clean
+clean:
+	rm -f *.o *~ a.out core http-server
+
+.PHONY: all
+all: clean default
+
+
+
--=20
2.17.1


=46rom 997c897e237b0e985f14ca4ea8e49e938dadd939 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 21:33:39 -0400
Subject: [PATCH 3/7] finish part2

---
 http-server.c | 500 ++++++++++++++------------------------------------
 1 file changed, 141 insertions(+), 359 deletions(-)

diff --git a/http-server.c b/http-server.c
index 3e57ef6..befd329 100644
--- a/http-server.c
+++ b/http-server.c
@@ -162,10 +162,10 @@ int main(int argc, char **argv) {
=20
     // +-------------------------------------------
=20
-    int count =3D 0;
+    //int count =3D 0;
     while (1) {
=20
-        printf("\n$ %d \n", count++);
+        //printf("\n$ %d \n", count++);
=20
         char buf[4096];
=20
@@ -234,17 +234,6 @@ int main(int argc, char **argv) {
=20
=20
=20
-/*
-           int html_size ;=20
-           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) !=
=3D 0 ){
-             printf("html: \n%s", buf);
-           }=20
-           fflush(stdout);
- =20
-*/
-          =20
-
-
         // Now parse method and httpVersion first, and then requestURI.=20
         // 1. check GET keyword
         if (strncmp(method, "GET", 3) !=3D 0 ){ //=20
@@ -254,15 +243,17 @@ int main(int argc, char **argv) {
             // as long as program keep running, no need to close/free sinc=
e we do that at the end, unless die program.
=20
             // send error 501 http to clnt & output log
-            fprintf(stderr, "%d\n", 501);=20
+            fprintf(stderr, "%d Not Implemented\n", 501);=20
=20
             char *html_501 =3D=20
-                "HTTP/1.0 501 Not Implemented"
+                "HTTP/1.0 501 Not Implemented\r\n\r\n"
                 "<html><body><h1>501 Not Implemented</h1></body></html>";
=20
             //printf("html : \n%s",html);
             if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
-                die("send content failed");
+               fclose(fd_mdb);
+               fclose(fd_clntsock);=20
+               die("send content failed");
             }
=20
             continue;
@@ -271,58 +262,59 @@ int main(int argc, char **argv) {
         // 2. check whether http 1.0 or 1.1 protocol
         if (strncmp("HTTP/1.0", httpVersion, 8) !=3D 0 && strncmp("HTTP/1.=
1", httpVersion, 8) !=3D 0) {
        =20
-            fprintf(stderr, "\"%s %s %s\" %d\n",method, requestURI, httpVe=
rsion, 501);=20
-         =20
-            fclose(fd_clntsock);
-          =20
+            fprintf(stderr, "%d Not Implemented\n", 501);=20
+            char *html_501 =3D=20
+                "HTTP/1.0 501 Not Implemented\r\n\r\n"
+                "<html><body><h1>501 Not Implemented</h1></body></html>";
=20
-          =20
-            char *html =3D cook_html(501);
-          =20
-            //size =3D snprintf(buf, sizeof(buf),"%s" , html);
-          =20
-            printf("html : \n%s",html);
-          =20
-            if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
-         =20
-                //free(html);
-         =20
-                die("send content failed");
-         =20
+            if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send content failed");
             }
-         =20
-            free(html);=20
-         =20
+
             continue;
-      =20
         }
=20
=20
=20
+        // 3. check URI starts with /, not ended with /..  not contains /.=
=2E/
=20
+        //printf("\n||||||| %s\n",requestURI);
+        if (strncmp("/", requestURI, 1) !=3D 0 || strstr(requestURI, "/../=
") || strstr(requestURI, "/..") )  {
+       =20
+            fprintf(stderr, "%d Bad Request\n", 400);=20
+            char *html_400 =3D=20
+                "HTTP/1.0 400 Bad Request\r\n\r\n"
+                "<html><body><h1>400 Bad Request</h1></body></html>";
+
+            if (send(clntsock, html_400, strlen(html_400), 0) !=3D strlen(=
html_400)){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send content failed");
+            }
=20
+            continue;
+        }
=20
=20
+        // printf("2333333333333333333333333333"); fflush(stdout);
=20
=20
=20
-
-
-
-
-
-
+        =20
=20
        ///////////////   part 2 b
=20
=20
-           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
+           //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
=20
        // http://clac.cs.columbia.edu:41782/mdb-lookup=20
        if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){
=20
-           printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(re=
questURI, "/mdb-lookup"));
-
+           //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
+      =20
+           fprintf(stderr, "200 OK\n");
            const char *form =3D
                "HTTP 200 OK\r\n"
                "\r\n"
@@ -335,296 +327,103 @@ int main(int argc, char **argv) {
                "<p>\n";
=20
            if (send(clntsock, form, strlen(form), 0) !=3D strlen(form) ){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
                die("send content failed");
            }
=20
-
-           printf("\n\n send, you should see search page  \n\n");
-
-
-          continue;=20
+           //printf("\n\n send, you should see search page  \n\n");
+           continue;=20
+     =20
        }
=20
=20
=20
+     =20
        // http://clac.cs.columbia.edu:41782/mdb-lookup?key=3Dhello=20
        if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){
=20
-           printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncmp(=
requestURI, "/mdb-lookup?key=3D",16 ));
-
-
-        /*
-        FILE *fd_clntsock;  // fp_servsock
-        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // fp=
_servsock =3D fdopen(servsock, "r")=20
-            die("fdopen failed");
-        }*/
-
-
-        // printf("why2");
-        // fflush(stdout);
-
-
-        /*
-           int html_size;=20
-           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) > 0=
 ){
-             printf("html: \n%s", buf);
-           }  =20
-
+           //printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncm=
p(requestURI, "/mdb-lookup?key=3D",16 ));
+     =20
+           // printf("\n(%s)\n",requestURI);
=20
-        printf("||||||||||||||||||||||||||");
-        fflush(stdout);
        =20
-        FILE *fd_clntsock_1;  // fp_servsock
-        if ((fd_clntsock_1 =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // =
fp_servsock =3D fdopen(servsock, "r")=20
-            die("fdopen failed");
-        }
-
-
-           //=20
-           while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=
=3D 0 ){
-
-               printf("html: \n%s", buf);
-
-           }*/  =20
+           for(int i=3D0; i<16; i++){
+          =20
+               requestURI++;
        =20
-
-=20
-     =20
-           /*
-           // int html_size ;=20
-           // int i =3D 0;
-
-
-           // printf("\n%ld, %s \n", fread(buf,1,30,fd_clntsock), buf );=
=20
-           // printf("\n%ld\n", fread(buf,1,sizeof(buf),fd_clntsock));=20
-
-           // while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) =
>  0 ){
-
-           printf("_____ %d\n", i++);
-           fflush(stdout);
-             printf("html: \n%s", buf);
-             printf("88888 %d\n", i );
-             fflush(stdout);
-             break;
-            =20
-           } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =
=E4=BD=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=
=85=A5size? =20
-
-           /* // =E6=A3=80=E6=9F=A5 header
-           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
-               printf("\nHeaders: %s\n", buf);
            }
-           fgets(buf,sizeof(buf), fd_clntsock);
-           printf("$$$$$$$$ %s", buf);
-
-           fgets(buf,sizeof(buf), fd_clntsock);
-           printf("*** $$$$$$$$ %s", buf);
-           */
-
-
+          =20
+      =20
+           strcat(requestURI, "\n");
        =20
-        // printf("\n(%s)\n",requestURI);
-
-        for(int i=3D0; i<16; i++){
-            requestURI++;
-        }
-        strcat(requestURI, "\n");
-        // printf("\n(%s)\n",requestURI);
-
+           // printf("\n(%s)\n",requestURI);
=20
+           // send   =20
=20
-        // =E6=88=91=E8=A6=81=E6=8A=8A=E4=B8=9C=E8=A5=BF search key send =
=E7=BB=99 mdb-lookup-server
-        //
-
-
-        printf("\n(%s)\n",requestURI);
-
-       // =E6=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=
=E4=BA=86=EF=BC=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2
    =20
-    //printf("=1A=1A")   =20
-    if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strlen(requ=
estURI)) {
-	die("send failed");
-    }
-
-
-
-    /*
-           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){
-               printf("\nHeaders: %s\n", buf);
+           if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strl=
en(requestURI)) {
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send failed");
            }
-           */
-           // fgets(buf,sizeof(buf), fd_mdb);
-           // printf("$$$$$$$$ %s", buf);
-
-
-    /*
-           printf("\n\n 11111111111111111111111111111111------------------=
--------\n\n");
-
-           fgets(buf,sizeof(buf), fd_mdb);
-           printf("*** $$$$$$$$ %s", buf);
-
-           printf("\n\n 22222222222222222222222222222222------------------=
--------\n\n");
-
-           fgets(buf,sizeof(buf), fd_mdb);
-           printf("*** $$$$$$$$ %s", buf);
-      */
-
-
-
-
-  /*     =20
-    char html[10000];
-    strcpy(html,
-        "HTTP 200 OK\r\n"      =20
-        "\r\n"
-              =20
-        "<h1>mdb-lookup</h1>\n"
-              =20
-        "<p>\n"
-              =20
-        "<form method=3DGET action=3D/mdb-lookup>\n"
-              =20
-        "lookup: <input type=3Dtext name=3Dkey>\n"
-              =20
-        "<input type=3Dsubmit>\n"
-              =20
-        "</form>\n"
-              =20
-        "<p>\n"
-
-        "<p><table border>\n");
-
-
-        printf("0000000000000000000000000000000000000000000000000000000000=
000000\n");
-    char row[100];
-    while(fgets(buf, sizeof(buf), fd_mdb)!=3D NULL ){
-
-        if( strcmp(buf, "\n") =3D=3D 0){
-            printf("\n\n end \n\n");
-            break;
-        }
-
-        snprintf(row, sizeof(row), "<tr><td> %s\n", buf);
-        printf("%s\n", row );
-        strcat(html, row);
-
-     =20
-       =20
-    }
-
-    strcat(html, "</table>\n</body>\n</html>");
-
-
-    printf("\n\n%s\n\n", html);
-*/
-
-
-
-   =20
-    strcpy(buf,
-        "HTTP 200 OK\r\n"      =20
-        "\r\n"
-              =20
-        "<h1>mdb-lookup</h1>\n"
-              =20
-        "<p>\n"
-              =20
-        "<form method=3DGET action=3D/mdb-lookup>\n"
-              =20
-        "lookup: <input type=3Dtext name=3Dkey>\n"
-              =20
-        "<input type=3Dsubmit>\n"
-              =20
-        "</form>\n"
-              =20
-        "<p>\n"
-
-        "<p><table border>\n");
-
+         =20
+      =20
+           fprintf(stderr, "200 OK\n");
+           strcpy(buf,
+                   "HTTP/1.0 200 OK\r\n"    =20
+                   "\r\n"
+                   "<h1>mdb-lookup</h1>\n"
+                   "<p>\n"
+                   "<form method=3DGET action=3D/mdb-lookup>\n"
+                   "lookup: <input type=3Dtext name=3Dkey>\n"
+                   "<input type=3Dsubmit>\n"
+                   "</form>\n"
+                   "<p>\n"
+                   "<p><table border>\n");
    =20
+           if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send contenct failed 2b)");
+           }
=20
+  =20
           =20
-    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
-   =20
-        perror("send content failed");
-
-        break;
-
-    }
-
-    char row[100];
-    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
-
-        if( strcmp(row, "\n") =3D=3D 0){
-            printf("\n\n end \n\n");
-            break;
-        }
-
-
-        snprintf(buf, sizeof(buf), "<tr><td> %s\n", row);
-        //printf("%s\n", row) ;
-        //strcat(html, row);
-
+         =20
+          =20
+           char row[100];
+         =20
+           int even =3D 0;
+          =20
+           while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
+               if( strcmp(row, "\n") =3D=3D 0){
+                   //printf("\n\n end \n\n");
+                   break;
+               }
=20
-    if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+               if(even++%2 =3D=3D 0){
+              =20
+                   snprintf(buf, sizeof(buf), "<tr><td> %s\n", row);
+               }else{
+                   snprintf(buf, sizeof(buf), "<tr><td  bgcolor=3Dyellow> =
%s\n", row);
+
+               }
+               if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
+                   fclose(fd_mdb);
+                   fclose(fd_clntsock);
+                   die("send contenct failed 2b)");
+               }
    =20
-        perror("send content failed");
-
-        break;
-
-    }
-    }
-
-
-
-
-
-
-
-
+           }
=20
=20
         continue;=20
-       }
-
-
-
-      =20
-       ////////////////////////////////////////////
+       }// end if ./mdb-lookup?key=3D
=20
=20
=20
-
-
-
-
-
-
-
-
-       // check requestURI !!!!!!!!!!!!!!!!
-       //
-      =20
-       // check web_root
-
-
-
-
-
-
-
-
-
-     =20
-
-
-
-
-
-       // printf("\nweb_root %s\n", web_root);
-
-
-       // log print out
-       fprintf(stderr, "\"%s %s %s\" %d OK\n",method, requestURI, httpVers=
ion, 200);
+       // part2 a) continue  //////////
=20
        // retrive the file -- requestURI
        // 1. make path
@@ -633,7 +432,6 @@ int main(int argc, char **argv) {
        strcat(full_path, requestURI);  // char *file_path =3D strcat(web_r=
oot, requestURI);
=20
=20
-
        // int stat(const char *path, struct stat *buf);
        // success returns 0 & fill buf, error return -1
        // reference: https://www.ibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_7=
3/apis/stat.htm=20
@@ -643,89 +441,73 @@ int main(int argc, char **argv) {
=20
=20
=20
-       // check ending char of path is '/' or not, return 400 error code  =
 =20
+       // check ending char of path is '/', if true, concat  index.html=20
        if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
-           // if ending with '/', attach index.html
            strcat(full_path_1, "index.html");
-           // printf("***********%s\n", full_path_1);
-
        }
-       /*
-       else{
-           // else send 400 error code
-           char *html =3D cook_html(400);
-           printf("html : \n%s",html);
-           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
-               free(html);
-               die("send content failed");
-           }
-           free(html);=20
-           fclose(fd_clntsock);
-           continue;
-       }*/
-
-
-
+      =20
+      =20
        // if path/file exists, proceeds, else =20
-       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds -- file exists=
, then check directory/file
-
-           printf("**********  %s", full_path_1 );
+       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds -- stat return=
 none 0,  file not exists, then check directory/file
=20
-           // full_path ends with / or not
-           // printf("***********%s\n",full_path_1);
-           // printf("%c, %c\n", '/',full_path_1[strlen(full_path_1)-1] );
-           // if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){
-           //        strcat(full_path_1, "index.html");
-           //        // printf("***********%s\n", full_path_1);
-           // }
+           //printf("**********  %s", full_path_1 );
+      =20
        }else{
=20
            //printf("\nfail does not exists:  %s\n", full_path_1 );
+            fprintf(stderr, "%d Not Found\n", 404);=20
+            char *html_404 =3D=20
+                "HTTP/1.0 404 Not Found\r\n\r\n"
+                "<html><body><h1>404 Not Found</h1></body></html>";
+
+            if (send(clntsock, html_404, strlen(html_404), 0) !=3D strlen(=
html_404)){
+                   fclose(fd_mdb);
+                   fclose(fd_clntsock);
+                   die("send content failed");
+            }
=20
-           char *html =3D cook_html(404);
-           printf("html : \n%s",html);
-           if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){
-               //free(html);
-               die("send content failed");
-           }
-           free(html);=20
-           fclose(fd_clntsock);
-           continue;
+            continue;
        }=20
=20
-       // 2. send response headers
+
+       fprintf(stderr, "200 OK\n");
+
+
+       // 2. prepare response headers
        snprintf(buf, sizeof(buf),=20
                "HTTP/1.0 200 OK\r\n"
                "\r\n");
=20
        // 3. open file, read & send
-       // printf("\nfull_path_1: %s\n", full_path_1);
-       // printf("\nstat code: %d\n", stat(full_path_1, &status));
        FILE *file_requested =3D fopen(full_path_1, "rb");
-       if( file_requested =3D=3D NULL)=20
+       if( file_requested =3D=3D NULL){=20
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
                die("fail open file");
+       }
        int size_read;
=20
        size_read =3D strlen(buf); // should be 19, header=20
        do{
-           printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
+           //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
            if( send(clntsock, buf, size_read, 0) !=3D size_read ){
-               perror("send content failed");
-               break;
+               fclose(fd_mdb);
+               fclose(fd_clntsock);
+               die("send content failed");
            }
        }while(( size_read =3D fread(buf,1, sizeof(buf), file_requested)) >=
 0);
=20
=20
-       //if(feof(file_requested) )
-       //    printf("file has not been fully read");
-
        fclose(file_requested);
        fclose(fd_clntsock);
=20
-       fclose(fd_mdb);
-
-
+       fprintf(stdout, "\n");
     }// while (1)
=20
+      =20
+   =20
+
+=20
+    fclose(fd_mdb);
     return 0;
 }
--=20
2.17.1


=46rom 58ac4b4732ec355c52b3dab752eb8e3684cea079 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 22:22:07 -0400
Subject: [PATCH 4/7] finish test, part2 ab both work on firefox

---
 http-server.c | 78 +++++++++------------------------------------------
 1 file changed, 14 insertions(+), 64 deletions(-)

diff --git a/http-server.c b/http-server.c
index befd329..7387137 100644
--- a/http-server.c
+++ b/http-server.c
@@ -29,30 +29,6 @@ static void printUsage() {
     exit(1);
 }
=20
-char* cook_html(int code){ // char* content
-
-    char *html =3D (char *) malloc(1000 * sizeof(char));
-
-    char *error_code_prompt;
-    if(code =3D=3D 501)
-        error_code_prompt =3D  "Not Implemented";
-    if(code =3D=3D 400)
-        error_code_prompt =3D  "Bad Request";
-    if(code =3D=3D 404)
-        error_code_prompt =3D "Not Found";
-
-
-    snprintf(html, 1000,  //sizeof(html),=20
-            "HTTP/1.0 %d %s\r\n"
-            "\r\n"
-            //"<html>\r\n<body>\r\n<h1>%d %s</h1>\r\n</body>\r\n</html>\r\=
n",
-            "<html><body><h1>%d %s</h1></body></html>",
-            code, error_code_prompt, code, error_code_prompt);
-    printf("\n\n%s\\n\n", html);
-    return html;
-}
-
-
=20
=20
=20
@@ -115,7 +91,6 @@ int main(int argc, char **argv) {
     int mdb_sock;
     struct sockaddr_in mdb_serverAddr;
     struct hostent *mdb_he;
-    // char buf_2[BUF_SIZE];                    // necessary?
=20
     =20
     // get mdb-lookup server ip from mdb-server name
@@ -124,15 +99,6 @@ int main(int argc, char **argv) {
     }
     mdb_serverIP =3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);
=20
-    /* for debugging
-       printf("1: %s\n", mdb_serverName);
-       printf("2: %s\n", mdb_serverIP);
-       printf("3: %s\n", mdb_serverPort);
-       printf("4: %s\n", filePath);
-       printf("5: %s\n", fname);
-       */
-
-
     // create socket
     if ((mdb_sock =3D socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
 	die("socket failed");
@@ -300,23 +266,17 @@ int main(int argc, char **argv) {
=20
         // printf("2333333333333333333333333333"); fflush(stdout);
=20
-
-
         =20
=20
        ///////////////   part 2 b
=20
-
-           //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
-
        // http://clac.cs.columbia.edu:41782/mdb-lookup=20
        if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){
=20
            //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(=
requestURI, "/mdb-lookup"));
-      =20
            fprintf(stderr, "200 OK\n");
            const char *form =3D
-               "HTTP 200 OK\r\n"
+               "HTTP/1.0 200 OK\r\n"
                "\r\n"
                "<h1>mdb-lookup</h1>\n"
                "<p>\n"
@@ -333,35 +293,24 @@ int main(int argc, char **argv) {
            }
=20
            //printf("\n\n send, you should see search page  \n\n");
+           fclose(fd_clntsock);
            continue;=20
      =20
        }
=20
-
-
      =20
        // http://clac.cs.columbia.edu:41782/mdb-lookup?key=3Dhello=20
        if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){
=20
            //printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncm=
p(requestURI, "/mdb-lookup?key=3D",16 ));
-     =20
            // printf("\n(%s)\n",requestURI);
-
-       =20
            for(int i=3D0; i<16; i++){
-          =20
                requestURI++;
-       =20
            }
-          =20
-      =20
            strcat(requestURI, "\n");
        =20
            // printf("\n(%s)\n",requestURI);
-
            // send   =20
-
-   =20
            if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strl=
en(requestURI)) {
                fclose(fd_mdb);
                fclose(fd_clntsock);
@@ -388,14 +337,8 @@ int main(int argc, char **argv) {
                die("send contenct failed 2b)");
            }
=20
-  =20
-          =20
-         =20
-          =20
            char row[100];
-         =20
            int even =3D 0;
-          =20
            while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){
                if( strcmp(row, "\n") =3D=3D 0){
                    //printf("\n\n end \n\n");
@@ -417,8 +360,8 @@ int main(int argc, char **argv) {
    =20
            }
=20
-
-        continue;=20
+           fclose(fd_clntsock);
+           continue;=20
        }// end if ./mdb-lookup?key=3D
=20
=20
@@ -454,8 +397,15 @@ int main(int argc, char **argv) {
       =20
        }else{
=20
+           printf("**********  %s", full_path_1 );
+           fprintf(stderr, "%d Not Found\n", 404);=20
+           if( strcmp(full_path,"/mnt/disks/students221/yz4004/html/cs3157=
/tng/favicon.ico" ) =3D=3D 0 ){
+
+               break;
+           }
+
+
            //printf("\nfail does not exists:  %s\n", full_path_1 );
-            fprintf(stderr, "%d Not Found\n", 404);=20
             char *html_404 =3D=20
                 "HTTP/1.0 404 Not Found\r\n\r\n"
                 "<html><body><h1>404 Not Found</h1></body></html>";
@@ -492,6 +442,7 @@ int main(int argc, char **argv) {
            //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
            if( send(clntsock, buf, size_read, 0) !=3D size_read ){
                fclose(fd_mdb);
+               fclose(file_requested);
                fclose(fd_clntsock);
                die("send content failed");
            }
@@ -501,10 +452,9 @@ int main(int argc, char **argv) {
        fclose(file_requested);
        fclose(fd_clntsock);
=20
-       fprintf(stdout, "\n");
+       //fprintf(stdout, "\n");
     }// while (1)
=20
-      =20
    =20
=20
 =20
--=20
2.17.1


=46rom edbc31cfe47c1bfb59c17b691baed94f59b45d78 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 22:24:34 -0400
Subject: [PATCH 5/7] modify README

---
 README.txt | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/README.txt b/README.txt
index 66dfd3e..e571053 100644
--- a/README.txt
+++ b/README.txt
@@ -9,3 +9,10 @@ The description should indicate whether your solution for =
the part is
 working or not.  You may also want to include anything else you would
 like to communicate to the grader such as extra functionalities you
 implemented or how you tried to fix your non-working code.
+
+
+Yixuan Zou
+yz4004
+lab7
+
+part2 a) b) both work on firefox.
--=20
2.17.1


=46rom 2195addaa7c9f6178a534a0e51477319b2fa53fc Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 23:44:57 -0400
Subject: [PATCH 6/7] modify error prompt

---
 http-server.c | 79 +++++++++++++++++++++++++++++++++++----------------
 1 file changed, 54 insertions(+), 25 deletions(-)

diff --git a/http-server.c b/http-server.c
index 7387137..ec99309 100644
--- a/http-server.c
+++ b/http-server.c
@@ -142,7 +142,7 @@ int main(int argc, char **argv) {
=20
         if ((clntsock =3D accept(servsock,
                         (struct sockaddr * ) &clntaddr, &clntlen)) < 0){
-            //perror("next clinet");
+            perror("clinet crash");
             //die("accept fail");
             continue;=20
         }
@@ -164,11 +164,16 @@ int main(int argc, char **argv) {
         char requestLine[1000];=20
         if(fgets(requestLine, sizeof(requestLine), fd_clntsock) =3D=3D NUL=
L ){
             // fail to read request line, (maybe clnt crash/close connecti=
on -- fail to send request), skip current clnt to next one.
-            fprintf(stderr, "clnt crashes");
-            //fclose(fd_clntsock); no need
+            // fprintf(stderr, "clnt crashes");
+            fclose(fd_clntsock); //no need?
             continue;
         }
=20
+       // check fgets error=20
+       if (ferror(fd_clntsock)){
+           perror("fd_clntsock error");
+       }
+
         // parse browser http request line
         char *token_separators =3D "\t \r\n"; // tab, space, new line
         char *method =3D strtok(requestLine, token_separators);
@@ -217,9 +222,10 @@ int main(int argc, char **argv) {
=20
             //printf("html : \n%s",html);
             if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);=20
-               die("send content failed");
+               //die("send content failed");
+               perror("send content failed");
             }
=20
             continue;
@@ -234,9 +240,10 @@ int main(int argc, char **argv) {
                 "<html><body><h1>501 Not Implemented</h1></body></html>";
=20
             if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(=
html_501)){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);
-               die("send content failed");
+               //die("send content failed");
+               perror("send content failed");
             }
=20
             continue;
@@ -255,9 +262,10 @@ int main(int argc, char **argv) {
                 "<html><body><h1>400 Bad Request</h1></body></html>";
=20
             if (send(clntsock, html_400, strlen(html_400), 0) !=3D strlen(=
html_400)){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);
-               die("send content failed");
+               //die("send content failed");
+               perror("send content failed");
             }
=20
             continue;
@@ -287,9 +295,10 @@ int main(int argc, char **argv) {
                "<p>\n";
=20
            if (send(clntsock, form, strlen(form), 0) !=3D strlen(form) ){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);
-               die("send content failed");
+               //die("send content failed");
+               perror("send content failed");
            }
=20
            //printf("\n\n send, you should see search page  \n\n");
@@ -312,9 +321,10 @@ int main(int argc, char **argv) {
            // printf("\n(%s)\n",requestURI);
            // send   =20
            if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D strl=
en(requestURI)) {
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);
-               die("send failed");
+               //die("send failed");
+               perror("send failed");
            }
          =20
       =20
@@ -332,9 +342,10 @@ int main(int argc, char **argv) {
                    "<p><table border>\n");
    =20
            if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(fd_clntsock);
-               die("send contenct failed 2b)");
+               //die("send contenct failed 2b)");
+               perror("send content failed");
            }
=20
            char row[100];
@@ -353,13 +364,18 @@ int main(int argc, char **argv) {
=20
                }
                if( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){
-                   fclose(fd_mdb);
+                   //fclose(fd_mdb);
                    fclose(fd_clntsock);
-                   die("send contenct failed 2b)");
+                   //die("send contenct failed 2b)");
+                   perror("send content failed");
                }
    =20
+           } // end while, fget from fb_mdb
+      =20
+           // check fgets fd_mdb=20
+           if (ferror(fd_mdb)){
+               perror("fgets fd_mdb error");
            }
-
            fclose(fd_clntsock);
            continue;=20
        }// end if ./mdb-lookup?key=3D
@@ -397,7 +413,7 @@ int main(int argc, char **argv) {
       =20
        }else{
=20
-           printf("**********  %s", full_path_1 );
+           //printf("**********  %s", full_path_1 );
            fprintf(stderr, "%d Not Found\n", 404);=20
            if( strcmp(full_path,"/mnt/disks/students221/yz4004/html/cs3157=
/tng/favicon.ico" ) =3D=3D 0 ){
=20
@@ -411,9 +427,10 @@ int main(int argc, char **argv) {
                 "<html><body><h1>404 Not Found</h1></body></html>";
=20
             if (send(clntsock, html_404, strlen(html_404), 0) !=3D strlen(=
html_404)){
-                   fclose(fd_mdb);
+                   //fclose(fd_mdb);
                    fclose(fd_clntsock);
-                   die("send content failed");
+                   //die("send content failed");
+                   perror("send content failed");
             }
=20
             continue;
@@ -441,14 +458,27 @@ int main(int argc, char **argv) {
        do{
            //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
            if( send(clntsock, buf, size_read, 0) !=3D size_read ){
-               fclose(fd_mdb);
+               //fclose(fd_mdb);
                fclose(file_requested);
-               fclose(fd_clntsock);
-               die("send content failed");
+               perror("send content failed");
+               break;
+               //fclose(fd_clntsock);
+               //die("send content failed");
            }
        }while(( size_read =3D fread(buf,1, sizeof(buf), file_requested)) >=
 0);
=20
=20
+       // fread() returns 0 on EOF or on error
+       // so we need to check if there was an error.
+       if (ferror(file_requested)){
+           //fclose(fd_mdb);
+           fclose(fd_clntsock);
+           //die("fread failed");
+           perror("fread failed");
+       }
+  =20
+      =20
+
        fclose(file_requested);
        fclose(fd_clntsock);
=20
@@ -456,7 +486,6 @@ int main(int argc, char **argv) {
     }// while (1)
=20
    =20
-
 =20
     fclose(fd_mdb);
     return 0;
--=20
2.17.1


=46rom 1117997b16556f63572b46290f26a6665eb50f62 Mon Sep 17 00:00:00 2001
=46rom: Yixuan_Zou <yz4004@columbia.edu>
Date: Thu, 5 May 2022 23:48:50 -0400
Subject: [PATCH 7/7] modify error prompt

---
 http-server.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/http-server.c b/http-server.c
index ec99309..a09df07 100644
--- a/http-server.c
+++ b/http-server.c
@@ -459,7 +459,7 @@ int main(int argc, char **argv) {
            //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read);=20
            if( send(clntsock, buf, size_read, 0) !=3D size_read ){
                //fclose(fd_mdb);
-               fclose(file_requested);
+               //fclose(file_requested);
                perror("send content failed");
                break;
                //fclose(fd_clntsock);
--=20
2.17.1


--envbJBWh7q8WU6mo
Content-Type: application/mbox
Content-Disposition: attachment; filename="yz4004-lab7.mbox"
Content-Transfer-Encoding: quoted-printable

=46rom 9c1b686e24e076e8292f46bee5102b36e24c340f Mon Sep 17 00:00:00 2001=0A=
=46rom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Thu, 5 May 2022 19:33:12 -=
0400=0ASubject: [PATCH 1/7] draft 1=0A=0A---=0A http-server.c | 731 +++++++=
+++++++++++++++++++++++++++++++++++++++++++=0A 1 file changed, 731 insertio=
ns(+)=0A create mode 100644 http-server.c=0A=0Adiff --git a/http-server.c b=
/http-server.c=0Anew file mode 100644=0Aindex 0000000..3e57ef6=0A--- /dev/n=
ull=0A+++ b/http-server.c=0A@@ -0,0 +1,731 @@=0A+/*=0A+ * http-server.c=0A+=
 */=0A+=0A+#include <stdio.h>=0A+#include <stdlib.h>=0A+#include <string.h>=
=0A+#include <sys/types.h>=0A+#include <sys/socket.h>=0A+#include <arpa/ine=
t.h>=0A+#include <unistd.h>=0A+#include <netdb.h>=0A+=0A+#include <assert.h=
>  =0A+#include <sys/wait.h>  =0A+#include <sys/stat.h>=0A+=0A+=0A+#define =
BUF_SIZE 4096=0A+=0A+static void die(const char *msg) {=0A+    perror(msg);=
=0A+    exit(1);=0A+}=0A+=0A+static void printUsage() {=0A+    fprintf(stde=
rr, "usage: http-server <server_port> <web_root> <mdb-lookup-host> <mdb-loo=
kup-port>\n");=0A+    fprintf(stderr, "   ex) http-server www.example.com 8=
0 /index.html\n");=0A+    exit(1);=0A+}=0A+=0A+char* cook_html(int code){ /=
/ char* content=0A+=0A+    char *html =3D (char *) malloc(1000 * sizeof(cha=
r));=0A+=0A+    char *error_code_prompt;=0A+    if(code =3D=3D 501)=0A+    =
    error_code_prompt =3D  "Not Implemented";=0A+    if(code =3D=3D 400)=0A=
+        error_code_prompt =3D  "Bad Request";=0A+    if(code =3D=3D 404)=
=0A+        error_code_prompt =3D "Not Found";=0A+=0A+=0A+    snprintf(html=
, 1000,  //sizeof(html), =0A+            "HTTP/1.0 %d %s\r\n"=0A+          =
  "\r\n"=0A+            //"<html>\r\n<body>\r\n<h1>%d %s</h1>\r\n</body>\r\=
n</html>\r\n",=0A+            "<html><body><h1>%d %s</h1></body></html>",=
=0A+            code, error_code_prompt, code, error_code_prompt);=0A+    p=
rintf("\n\n%s\\n\n", html);=0A+    return html;=0A+}=0A+=0A+=0A+=0A+=0A+=0A=
+int main(int argc, char **argv) {=0A+=0A+    // Ignore SIGPIPE so that we =
don=E2=80=99t terminate when we call=0A+    // send() on a disconnected soc=
ket=0A+    if (signal(SIGPIPE, SIG_IGN) =3D=3D SIG_ERR)=0A+        die("sig=
nal() failed"); =0A+    =0A+    if (argc !=3D 5) {=0A+	printUsage();=0A+   =
 }=0A+=0A+    // Assign server_port and web_root to correct command line ar=
guments=0A+=0A+    unsigned short serv_port =3D atoi(argv[1]);=0A+    const=
 char *web_root =3D argv[2];=0A+    =0A+=0A+    // Create a listening socke=
t (also called server socket) =0A+=0A+    int servsock;=0A+    if ((servsoc=
k =3D socket(AF_INET, SOCK_STREAM, 0)) < 0)=0A+        die("socket failed")=
;=0A+=0A+    // Construct local address structure=0A+=0A+    struct sockadd=
r_in servaddr;=0A+    memset(&servaddr, 0, sizeof(servaddr));=0A+    servad=
dr.sin_family =3D AF_INET;=0A+    servaddr.sin_addr.s_addr =3D htonl(INADDR=
_ANY); // any network interface=0A+    servaddr.sin_port =3D htons(serv_por=
t);=0A+=0A+    // Bind to the local address=0A+=0A+    if (bind(servsock, (=
struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)=0A+        die("bind f=
ailed");=0A+=0A+    // Start listening for incoming connections=0A+=0A+    =
if (listen(servsock, 5 /* queue size for connection requests */ ) < 0)=0A+ =
       die("listen failed");=0A+=0A+    int clntsock;=0A+    socklen_t clnt=
len;=0A+    struct sockaddr_in clntaddr;=0A+=0A+=0A+    // +---------------=
----------------------------=0A+    // part2 b=0A+=0A+    // create a mdb-l=
ookup-server sock, now I'm a client to mdb-lookup-server, and as a client, =
I only need server sock.=0A+=0A+    char *mdb_serverName =3D argv[3];=0A+  =
  char *mdb_serverIP;=0A+    unsigned short mdb_serverPort =3D atoi(argv[4]=
);=0A+=0A+=0A+    int mdb_sock;=0A+    struct sockaddr_in mdb_serverAddr;=
=0A+    struct hostent *mdb_he;=0A+    // char buf_2[BUF_SIZE];            =
        // necessary?=0A+=0A+     =0A+    // get mdb-lookup server ip from =
mdb-server name=0A+    if ((mdb_he =3D gethostbyname(mdb_serverName)) =3D=
=3D NULL) {=0A+	die("gethostbyname failed");=0A+    }=0A+    mdb_serverIP =
=3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);=0A+=0A+    /* for debuggi=
ng=0A+       printf("1: %s\n", mdb_serverName);=0A+       printf("2: %s\n",=
 mdb_serverIP);=0A+       printf("3: %s\n", mdb_serverPort);=0A+       prin=
tf("4: %s\n", filePath);=0A+       printf("5: %s\n", fname);=0A+       */=
=0A+=0A+=0A+    // create socket=0A+    if ((mdb_sock =3D socket(PF_INET, S=
OCK_STREAM, IPPROTO_TCP)) < 0) {=0A+	die("socket failed");=0A+    }=0A+=0A+=
=0A+    // construct mdb-lookup server address=0A+    memset(&mdb_serverAdd=
r, 0, sizeof(mdb_serverAddr));=0A+    mdb_serverAddr.sin_family =3D AF_INET=
;=0A+    mdb_serverAddr.sin_addr.s_addr =3D inet_addr(mdb_serverIP);=0A+   =
 mdb_serverAddr.sin_port =3D htons(mdb_serverPort);=0A+=0A+    // connect=
=0A+    if (connect(mdb_sock, (struct sockaddr *)&mdb_serverAddr, sizeof(md=
b_serverAddr)) < 0) {=0A+	die("connect failed");=0A+    }=0A+=0A+    =0A+  =
  =0A+    // wrap the socket with a file* so that we can read the socket us=
ing fgets()=0A+    FILE *fd_mdb;=0A+    if ((fd_mdb =3D fdopen(mdb_sock, "r=
")) =3D=3D NULL) {=0A+	die("fdopen failed mdb_sock");=0A+    }=0A+=0A+=0A+=
=0A+    // +-------------------------------------------=0A+=0A+    int coun=
t =3D 0;=0A+    while (1) {=0A+=0A+        printf("\n$ %d \n", count++);=0A=
+=0A+        char buf[4096];=0A+=0A+=0A+        // Accept an incoming conne=
ction=0A+=0A+        clntlen =3D sizeof(clntaddr); // initialize the in-out=
 parameter=0A+=0A+        if ((clntsock =3D accept(servsock,=0A+           =
             (struct sockaddr * ) &clntaddr, &clntlen)) < 0){=0A+          =
  //perror("next clinet");=0A+            //die("accept fail");=0A+        =
    continue; =0A+        }=0A+=0A+        // accept() returned a connected=
 socket (also called client socket)=0A+        // and filled in the client'=
s address into clntaddr=0A+=0A+=0A+        // fd_clntsock, for clnt/browser=
=0A+        FILE *fd_clntsock;  =0A+        if ((fd_clntsock =3D fdopen(cln=
tsock, "r")) =3D=3D NULL) {   =0A+           // if i cannot open clntsock, =
is it a clnt crash issue? No, my problem. die =0A+            die("fdopen f=
ailed");=0A+        }=0A+=0A+=0A+=0A+        // read GET request from FILE =
*fd_clntsock, clnt request from browser=0A+        char requestLine[1000]; =
=0A+        if(fgets(requestLine, sizeof(requestLine), fd_clntsock) =3D=3D =
NULL ){=0A+            // fail to read request line, (maybe clnt crash/clos=
e connection -- fail to send request), skip current clnt to next one.=0A+  =
          fprintf(stderr, "clnt crashes");=0A+            //fclose(fd_clnts=
ock); no need=0A+            continue;=0A+        }=0A+=0A+        // parse=
 browser http request line=0A+        char *token_separators =3D "\t \r\n";=
 // tab, space, new line=0A+        char *method =3D strtok(requestLine, to=
ken_separators);=0A+        //  printf("1 method:(%s)", method);=0A+       =
 // printf("1 requestLine:(%s)", requestLine);=0A+       =0A+        char *=
requestURI =3D strtok(NULL, token_separators);=0A+        // printf("2 requ=
estURI:(%s)", requestURI);=0A+        // printf("2 requestLine:(%s)", reque=
stLine);=0A+       =0A+        char *httpVersion =3D strtok(NULL, token_sep=
arators);=0A+        // printf("3 httpVersion:(%s)", httpVersion);=0A+     =
   // printf("3 requestLine:(%s)", requestLine);=0A+=0A+        /*=0A+     =
      1 method:(GET)=0A+           1 requestLine:(GET)=0A+           2 requ=
estURI:(/~yz4004/cs3157/tng/index.html)=0A+           2 requestLine:(GET)=
=0A+           3 httpVersion:(HTTP/1.1)=0A+           3 requestLine:(GET)$ =
1*/=0A+=0A+        // print log through stderr, whether it's legal or not. =
if wrong put error code later.=0A+        fprintf(stderr, "%s \"%s %s\" ",=
=0A+                inet_ntoa(clntaddr.sin_addr),=0A+                method=
,=0A+                requestURI);=0A+=0A+=0A+=0A+=0A+/*=0A+           int h=
tml_size ; =0A+           while((html_size =3D fread(buf,1,sizeof(buf),fd_c=
lntsock) ) !=3D 0 ){=0A+             printf("html: \n%s", buf);=0A+        =
   } =0A+           fflush(stdout);=0A+  =0A+*/=0A+           =0A+=0A+=0A+ =
       // Now parse method and httpVersion first, and then requestURI. =0A+=
        // 1. check GET keyword=0A+        if (strncmp(method, "GET", 3) !=
=3D 0 ){ // =0A+=0A+            // fclose(fd_clntsock); no need to turn thi=
s off, since this clnt fails, we continue to next clnt (while 1)=0A+       =
     // fd_clntsock created again & cover old one. Not simple die program=
=0A+            // as long as program keep running, no need to close/free s=
ince we do that at the end, unless die program.=0A+=0A+            // send =
error 501 http to clnt & output log=0A+            fprintf(stderr, "%d\n", =
501); =0A+=0A+            char *html_501 =3D =0A+                "HTTP/1.0 =
501 Not Implemented"=0A+                "<html><body><h1>501 Not Implemente=
d</h1></body></html>";=0A+=0A+            //printf("html : \n%s",html);=0A+=
            if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(h=
tml_501)){=0A+                die("send content failed");=0A+            }=
=0A+=0A+            continue;=0A+        }=0A+      =0A+        // 2. check=
 whether http 1.0 or 1.1 protocol=0A+        if (strncmp("HTTP/1.0", httpVe=
rsion, 8) !=3D 0 && strncmp("HTTP/1.1", httpVersion, 8) !=3D 0) {=0A+      =
  =0A+            fprintf(stderr, "\"%s %s %s\" %d\n",method, requestURI, h=
ttpVersion, 501); =0A+          =0A+            fclose(fd_clntsock);=0A+   =
        =0A+=0A+           =0A+            char *html =3D cook_html(501);=
=0A+           =0A+            //size =3D snprintf(buf, sizeof(buf),"%s" , =
html);=0A+           =0A+            printf("html : \n%s",html);=0A+       =
    =0A+            if (send(clntsock, html, strlen(html), 0) !=3D strlen(h=
tml) ){=0A+          =0A+                //free(html);=0A+          =0A+   =
             die("send content failed");=0A+          =0A+            }=0A+=
          =0A+            free(html); =0A+          =0A+            continu=
e;=0A+       =0A+        }=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+=
=0A+=0A+=0A+=0A+=0A+=0A+       ///////////////   part 2 b=0A+=0A+=0A+      =
     printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requestUR=
I, "/mdb-lookup"));=0A+=0A+       // http://clac.cs.columbia.edu:41782/mdb-=
lookup =0A+       if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){=0A+=0A+ =
          printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requ=
estURI, "/mdb-lookup"));=0A+=0A+           const char *form =3D=0A+        =
       "HTTP 200 OK\r\n"=0A+               "\r\n"=0A+               "<h1>md=
b-lookup</h1>\n"=0A+               "<p>\n"=0A+               "<form method=
=3DGET action=3D/mdb-lookup>\n"=0A+               "lookup: <input type=3Dte=
xt name=3Dkey>\n"=0A+               "<input type=3Dsubmit>\n"=0A+          =
     "</form>\n"=0A+               "<p>\n";=0A+=0A+           if (send(clnt=
sock, form, strlen(form), 0) !=3D strlen(form) ){=0A+               die("se=
nd content failed");=0A+           }=0A+=0A+=0A+           printf("\n\n sen=
d, you should see search page  \n\n");=0A+=0A+=0A+          continue; =0A+ =
      }=0A+=0A+=0A+=0A+       // http://clac.cs.columbia.edu:41782/mdb-look=
up?key=3Dhello =0A+       if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =
=3D=3D0 ){=0A+=0A+           printf("2222222222222222  (%s), %d\n\n\n", req=
uestURI, strncmp(requestURI, "/mdb-lookup?key=3D",16 ));=0A+=0A+=0A+       =
 /*=0A+        FILE *fd_clntsock;  // fp_servsock=0A+        if ((fd_clntso=
ck =3D fdopen(clntsock, "r")) =3D=3D NULL) {   // fp_servsock =3D fdopen(se=
rvsock, "r") =0A+            die("fdopen failed");=0A+        }*/=0A+=0A+=
=0A+        // printf("why2");=0A+        // fflush(stdout);=0A+=0A+=0A+   =
     /*=0A+           int html_size; =0A+           while((html_size =3D fr=
ead(buf,1,sizeof(buf),fd_clntsock) ) > 0 ){=0A+             printf("html: \=
n%s", buf);=0A+           }   =0A+=0A+=0A+        printf("|||||||||||||||||=
|||||||||");=0A+        fflush(stdout);=0A+        =0A+        FILE *fd_cln=
tsock_1;  // fp_servsock=0A+        if ((fd_clntsock_1 =3D fdopen(clntsock,=
 "r")) =3D=3D NULL) {   // fp_servsock =3D fdopen(servsock, "r") =0A+      =
      die("fdopen failed");=0A+        }=0A+=0A+=0A+           // =0A+     =
      while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=3D 0 =
){=0A+=0A+               printf("html: \n%s", buf);=0A+=0A+           }*/  =
 =0A+        =0A+=0A+ =0A+      =0A+           /*=0A+           // int html=
_size ; =0A+           // int i =3D 0;=0A+=0A+=0A+           // printf("\n%=
ld, %s \n", fread(buf,1,30,fd_clntsock), buf ); =0A+           // printf("\=
n%ld\n", fread(buf,1,sizeof(buf),fd_clntsock)); =0A+=0A+           // while=
((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) >  0 ){=0A+=0A+     =
      printf("_____ %d\n", i++);=0A+           fflush(stdout);=0A+         =
    printf("html: \n%s", buf);=0A+             printf("88888 %d\n", i );=0A=
+             fflush(stdout);=0A+             break;=0A+             =0A+  =
         } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =E4=
=BD=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=85=
=A5size?  =0A+=0A+           /* // =E6=A3=80=E6=9F=A5 header=0A+           =
while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){=0A+               pri=
ntf("\nHeaders: %s\n", buf);=0A+           }=0A+           fgets(buf,sizeof=
(buf), fd_clntsock);=0A+           printf("$$$$$$$$ %s", buf);=0A+=0A+     =
      fgets(buf,sizeof(buf), fd_clntsock);=0A+           printf("*** $$$$$$=
$$ %s", buf);=0A+           */=0A+=0A+=0A+        =0A+        // printf("\n=
(%s)\n",requestURI);=0A+=0A+        for(int i=3D0; i<16; i++){=0A+         =
   requestURI++;=0A+        }=0A+        strcat(requestURI, "\n");=0A+     =
   // printf("\n(%s)\n",requestURI);=0A+=0A+=0A+=0A+        // =E6=88=91=E8=
=A6=81=E6=8A=8A=E4=B8=9C=E8=A5=BF search key send =E7=BB=99 mdb-lookup-serv=
er=0A+        //=0A+=0A+=0A+        printf("\n(%s)\n",requestURI);=0A+=0A+ =
      // =E6=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=E4=
=BA=86=EF=BC=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2=0A+    =0A+    //pri=
ntf("=1A=1A")    =0A+    if (send(mdb_sock, requestURI, strlen(requestURI),=
 0) !=3D strlen(requestURI)) {=0A+	die("send failed");=0A+    }=0A+=0A+=0A+=
=0A+    /*=0A+           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NUL=
L){=0A+               printf("\nHeaders: %s\n", buf);=0A+           }=0A+  =
         */=0A+           // fgets(buf,sizeof(buf), fd_mdb);=0A+           =
// printf("$$$$$$$$ %s", buf);=0A+=0A+=0A+    /*=0A+           printf("\n\n=
 11111111111111111111111111111111--------------------------\n\n");=0A+=0A+ =
          fgets(buf,sizeof(buf), fd_mdb);=0A+           printf("*** $$$$$$$=
$ %s", buf);=0A+=0A+           printf("\n\n 2222222222222222222222222222222=
2--------------------------\n\n");=0A+=0A+           fgets(buf,sizeof(buf),=
 fd_mdb);=0A+           printf("*** $$$$$$$$ %s", buf);=0A+      */=0A+=0A+=
=0A+=0A+=0A+  /*      =0A+    char html[10000];=0A+    strcpy(html,=0A+    =
    "HTTP 200 OK\r\n"       =0A+        "\r\n"=0A+               =0A+      =
  "<h1>mdb-lookup</h1>\n"=0A+               =0A+        "<p>\n"=0A+        =
       =0A+        "<form method=3DGET action=3D/mdb-lookup>\n"=0A+        =
       =0A+        "lookup: <input type=3Dtext name=3Dkey>\n"=0A+          =
     =0A+        "<input type=3Dsubmit>\n"=0A+               =0A+        "<=
/form>\n"=0A+               =0A+        "<p>\n"=0A+=0A+        "<p><table b=
order>\n");=0A+=0A+=0A+        printf("000000000000000000000000000000000000=
0000000000000000000000000000\n");=0A+    char row[100];=0A+    while(fgets(=
buf, sizeof(buf), fd_mdb)!=3D NULL ){=0A+=0A+        if( strcmp(buf, "\n") =
=3D=3D 0){=0A+            printf("\n\n end \n\n");=0A+            break;=0A=
+        }=0A+=0A+        snprintf(row, sizeof(row), "<tr><td> %s\n", buf);=
=0A+        printf("%s\n", row );=0A+        strcat(html, row);=0A+=0A+    =
  =0A+        =0A+    }=0A+=0A+    strcat(html, "</table>\n</body>\n</html>=
");=0A+=0A+=0A+    printf("\n\n%s\n\n", html);=0A+*/=0A+=0A+=0A+=0A+    =0A=
+    strcpy(buf,=0A+        "HTTP 200 OK\r\n"       =0A+        "\r\n"=0A+ =
              =0A+        "<h1>mdb-lookup</h1>\n"=0A+               =0A+   =
     "<p>\n"=0A+               =0A+        "<form method=3DGET action=3D/md=
b-lookup>\n"=0A+               =0A+        "lookup: <input type=3Dtext name=
=3Dkey>\n"=0A+               =0A+        "<input type=3Dsubmit>\n"=0A+     =
          =0A+        "</form>\n"=0A+               =0A+        "<p>\n"=0A+=
=0A+        "<p><table border>\n");=0A+=0A+    =0A+=0A+           =0A+    i=
f( send(clntsock, buf, strlen(buf), 0) !=3D strlen(buf) ){=0A+    =0A+     =
   perror("send content failed");=0A+=0A+        break;=0A+=0A+    }=0A+=0A=
+    char row[100];=0A+    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){=
=0A+=0A+        if( strcmp(row, "\n") =3D=3D 0){=0A+            printf("\n\=
n end \n\n");=0A+            break;=0A+        }=0A+=0A+=0A+        snprint=
f(buf, sizeof(buf), "<tr><td> %s\n", row);=0A+        //printf("%s\n", row)=
 ;=0A+        //strcat(html, row);=0A+=0A+=0A+    if( send(clntsock, buf, s=
trlen(buf), 0) !=3D strlen(buf) ){=0A+    =0A+        perror("send content =
failed");=0A+=0A+        break;=0A+=0A+    }=0A+    }=0A+=0A+=0A+=0A+=0A+=
=0A+=0A+=0A+=0A+=0A+=0A+        continue; =0A+       }=0A+=0A+=0A+=0A+     =
  =0A+       ////////////////////////////////////////////=0A+=0A+=0A+=0A+=
=0A+=0A+=0A+=0A+=0A+=0A+=0A+=0A+       // check requestURI !!!!!!!!!!!!!!!!=
=0A+       //=0A+       =0A+       // check web_root=0A+=0A+=0A+=0A+=0A+=0A=
+=0A+=0A+=0A+=0A+      =0A+=0A+=0A+=0A+=0A+=0A+       // printf("\nweb_root=
 %s\n", web_root);=0A+=0A+=0A+       // log print out=0A+       fprintf(std=
err, "\"%s %s %s\" %d OK\n",method, requestURI, httpVersion, 200);=0A+=0A+ =
      // retrive the file -- requestURI=0A+       // 1. make path=0A+      =
 char full_path[100];  // should not be " char *full_path;" has to have len=
=0A+       strcpy(full_path, web_root);=0A+       strcat(full_path, request=
URI);  // char *file_path =3D strcat(web_root, requestURI);=0A+=0A+=0A+=0A+=
       // int stat(const char *path, struct stat *buf);=0A+       // succes=
s returns 0 & fill buf, error return -1=0A+       // reference: https://www=
=2Eibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_73/apis/stat.htm =0A+       stru=
ct stat status;=0A+       char full_path_1[strlen(full_path)];=0A+       st=
rcpy(full_path_1, full_path);=0A+=0A+=0A+=0A+       // check ending char of=
 path is '/' or not, return 400 error code    =0A+       if(full_path_1[str=
len(full_path_1)-1] =3D=3D '/' ){=0A+           // if ending with '/', atta=
ch index.html=0A+           strcat(full_path_1, "index.html");=0A+         =
  // printf("***********%s\n", full_path_1);=0A+=0A+       }=0A+       /*=
=0A+       else{=0A+           // else send 400 error code=0A+           ch=
ar *html =3D cook_html(400);=0A+           printf("html : \n%s",html);=0A+ =
          if (send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){=0A=
+               free(html);=0A+               die("send content failed");=
=0A+           }=0A+           free(html); =0A+           fclose(fd_clntsoc=
k);=0A+           continue;=0A+       }*/=0A+=0A+=0A+=0A+       // if path/=
file exists, proceeds, else  =0A+       if(stat(full_path_1, &status) =3D=
=3D 0){ // succeeds -- file exists, then check directory/file=0A+=0A+      =
     printf("**********  %s", full_path_1 );=0A+=0A+           // full_path=
 ends with / or not=0A+           // printf("***********%s\n",full_path_1);=
=0A+           // printf("%c, %c\n", '/',full_path_1[strlen(full_path_1)-1]=
 );=0A+           // if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){=0A=
+           //        strcat(full_path_1, "index.html");=0A+           //  =
      // printf("***********%s\n", full_path_1);=0A+           // }=0A+    =
   }else{=0A+=0A+           //printf("\nfail does not exists:  %s\n", full_=
path_1 );=0A+=0A+           char *html =3D cook_html(404);=0A+           pr=
intf("html : \n%s",html);=0A+           if (send(clntsock, html, strlen(htm=
l), 0) !=3D strlen(html) ){=0A+               //free(html);=0A+            =
   die("send content failed");=0A+           }=0A+           free(html); =
=0A+           fclose(fd_clntsock);=0A+           continue;=0A+       } =0A=
+=0A+       // 2. send response headers=0A+       snprintf(buf, sizeof(buf)=
, =0A+               "HTTP/1.0 200 OK\r\n"=0A+               "\r\n");=0A+=
=0A+       // 3. open file, read & send=0A+       // printf("\nfull_path_1:=
 %s\n", full_path_1);=0A+       // printf("\nstat code: %d\n", stat(full_pa=
th_1, &status));=0A+       FILE *file_requested =3D fopen(full_path_1, "rb"=
);=0A+       if( file_requested =3D=3D NULL) =0A+               die("fail o=
pen file");=0A+       int size_read;=0A+=0A+       size_read =3D strlen(buf=
); // should be 19, header =0A+       do{=0A+           printf("\n @@@@@@@@=
@@@@@@@@@@ %d \n",size_read); =0A+           if( send(clntsock, buf, size_r=
ead, 0) !=3D size_read ){=0A+               perror("send content failed");=
=0A+               break;=0A+           }=0A+       }while(( size_read =3D =
fread(buf,1, sizeof(buf), file_requested)) > 0);=0A+=0A+=0A+       //if(feo=
f(file_requested) )=0A+       //    printf("file has not been fully read");=
=0A+=0A+       fclose(file_requested);=0A+       fclose(fd_clntsock);=0A+=
=0A+       fclose(fd_mdb);=0A+=0A+=0A+    }// while (1)=0A+=0A+    return 0=
;=0A+}=0A-- =0A2.17.1=0A=0A=0AFrom dbe85f545b93c3d04f51b3eae63e7c4adce22c71=
 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: =
Thu, 5 May 2022 19:33:36 -0400=0ASubject: [PATCH 2/7] add makefile=0A=0A---=
=0A Makefile | 29 +++++++++++++++++++++++++++++=0A 1 file changed, 29 inser=
tions(+)=0A create mode 100644 Makefile=0A=0Adiff --git a/Makefile b/Makefi=
le=0Anew file mode 100644=0Aindex 0000000..a95373e=0A--- /dev/null=0A+++ b/=
Makefile=0A@@ -0,0 +1,29 @@=0A+=0A+#=0A+# Makefile for lab 7, part 2=0A+#=
=0A+=0A+CC  =3D gcc=0A+CXX =3D g++=0A+=0A+CFLAGS   =3D -g -Wall $(INCLUDES)=
=0A+CXXFLAGS =3D -g -Wall $(INCLUDES)=0A+=0A+=0A+.PHONY: default=0A+default=
: http-server =0A+=0A+# header dependency=0A+## mdb-lookup-server.o: mdb.h=
=0A+=0A+=0A+=0A+.PHONY: clean=0A+clean:=0A+	rm -f *.o *~ a.out core http-se=
rver=0A+=0A+.PHONY: all=0A+all: clean default=0A+=0A+=0A+=0A-- =0A2.17.1=0A=
=0A=0AFrom 997c897e237b0e985f14ca4ea8e49e938dadd939 Mon Sep 17 00:00:00 200=
1=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Thu, 5 May 2022 21:33:39=
 -0400=0ASubject: [PATCH 3/7] finish part2=0A=0A---=0A http-server.c | 500 =
++++++++++++++------------------------------------=0A 1 file changed, 141 i=
nsertions(+), 359 deletions(-)=0A=0Adiff --git a/http-server.c b/http-serve=
r.c=0Aindex 3e57ef6..befd329 100644=0A--- a/http-server.c=0A+++ b/http-serv=
er.c=0A@@ -162,10 +162,10 @@ int main(int argc, char **argv) {=0A =0A     /=
/ +-------------------------------------------=0A =0A-    int count =3D 0;=
=0A+    //int count =3D 0;=0A     while (1) {=0A =0A-        printf("\n$ %d=
 \n", count++);=0A+        //printf("\n$ %d \n", count++);=0A =0A         c=
har buf[4096];=0A =0A@@ -234,17 +234,6 @@ int main(int argc, char **argv) {=
=0A =0A =0A =0A-/*=0A-           int html_size ; =0A-           while((html=
_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) !=3D 0 ){=0A-             =
printf("html: \n%s", buf);=0A-           } =0A-           fflush(stdout);=
=0A-  =0A-*/=0A-           =0A-=0A-=0A         // Now parse method and http=
Version first, and then requestURI. =0A         // 1. check GET keyword=0A =
        if (strncmp(method, "GET", 3) !=3D 0 ){ // =0A@@ -254,15 +243,17 @@=
 int main(int argc, char **argv) {=0A             // as long as program kee=
p running, no need to close/free since we do that at the end, unless die pr=
ogram.=0A =0A             // send error 501 http to clnt & output log=0A-  =
          fprintf(stderr, "%d\n", 501); =0A+            fprintf(stderr, "%d=
 Not Implemented\n", 501); =0A =0A             char *html_501 =3D =0A-     =
           "HTTP/1.0 501 Not Implemented"=0A+                "HTTP/1.0 501 =
Not Implemented\r\n\r\n"=0A                 "<html><body><h1>501 Not Implem=
ented</h1></body></html>";=0A =0A             //printf("html : \n%s",html);=
=0A             if (send(clntsock, html_501, strlen(html_501), 0) !=3D strl=
en(html_501)){=0A-                die("send content failed");=0A+          =
     fclose(fd_mdb);=0A+               fclose(fd_clntsock); =0A+           =
    die("send content failed");=0A             }=0A =0A             continu=
e;=0A@@ -271,58 +262,59 @@ int main(int argc, char **argv) {=0A         // =
2. check whether http 1.0 or 1.1 protocol=0A         if (strncmp("HTTP/1.0"=
, httpVersion, 8) !=3D 0 && strncmp("HTTP/1.1", httpVersion, 8) !=3D 0) {=
=0A         =0A-            fprintf(stderr, "\"%s %s %s\" %d\n",method, req=
uestURI, httpVersion, 501); =0A-          =0A-            fclose(fd_clntsoc=
k);=0A-           =0A+            fprintf(stderr, "%d Not Implemented\n", 5=
01); =0A+            char *html_501 =3D =0A+                "HTTP/1.0 501 N=
ot Implemented\r\n\r\n"=0A+                "<html><body><h1>501 Not Impleme=
nted</h1></body></html>";=0A =0A-           =0A-            char *html =3D =
cook_html(501);=0A-           =0A-            //size =3D snprintf(buf, size=
of(buf),"%s" , html);=0A-           =0A-            printf("html : \n%s",ht=
ml);=0A-           =0A-            if (send(clntsock, html, strlen(html), 0=
) !=3D strlen(html) ){=0A-          =0A-                //free(html);=0A-  =
        =0A-                die("send content failed");=0A-          =0A+  =
          if (send(clntsock, html_501, strlen(html_501), 0) !=3D strlen(htm=
l_501)){=0A+               fclose(fd_mdb);=0A+               fclose(fd_clnt=
sock);=0A+               die("send content failed");=0A             }=0A-  =
        =0A-            free(html); =0A-          =0A+=0A             conti=
nue;=0A-       =0A         }=0A =0A =0A =0A+        // 3. check URI starts =
with /, not ended with /..  not contains /../=0A =0A+        //printf("\n||=
||||| %s\n",requestURI);=0A+        if (strncmp("/", requestURI, 1) !=3D 0 =
|| strstr(requestURI, "/../") || strstr(requestURI, "/..") )  {=0A+        =
=0A+            fprintf(stderr, "%d Bad Request\n", 400); =0A+            c=
har *html_400 =3D =0A+                "HTTP/1.0 400 Bad Request\r\n\r\n"=0A=
+                "<html><body><h1>400 Bad Request</h1></body></html>";=0A+=
=0A+            if (send(clntsock, html_400, strlen(html_400), 0) !=3D strl=
en(html_400)){=0A+               fclose(fd_mdb);=0A+               fclose(f=
d_clntsock);=0A+               die("send content failed");=0A+            }=
=0A =0A+            continue;=0A+        }=0A =0A =0A+        // printf("23=
33333333333333333333333333"); fflush(stdout);=0A =0A =0A =0A-=0A-=0A-=0A-=
=0A-=0A-=0A+         =0A =0A        ///////////////   part 2 b=0A =0A =0A- =
          printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requ=
estURI, "/mdb-lookup"));=0A+           //printf("111111111111111  (%s), %d\=
n\n\n", requestURI, strcmp(requestURI, "/mdb-lookup"));=0A =0A        // ht=
tp://clac.cs.columbia.edu:41782/mdb-lookup =0A        if (strcmp(requestURI=
, "/mdb-lookup") =3D=3D0 ){=0A =0A-           printf("111111111111111  (%s)=
, %d\n\n\n", requestURI, strcmp(requestURI, "/mdb-lookup"));=0A-=0A+       =
    //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requestU=
RI, "/mdb-lookup"));=0A+       =0A+           fprintf(stderr, "200 OK\n");=
=0A            const char *form =3D=0A                "HTTP 200 OK\r\n"=0A =
               "\r\n"=0A@@ -335,296 +327,103 @@ int main(int argc, char **a=
rgv) {=0A                "<p>\n";=0A =0A            if (send(clntsock, form=
, strlen(form), 0) !=3D strlen(form) ){=0A+               fclose(fd_mdb);=
=0A+               fclose(fd_clntsock);=0A                die("send content=
 failed");=0A            }=0A =0A-=0A-           printf("\n\n send, you sho=
uld see search page  \n\n");=0A-=0A-=0A-          continue; =0A+           =
//printf("\n\n send, you should see search page  \n\n");=0A+           cont=
inue; =0A+      =0A        }=0A =0A =0A =0A+      =0A        // http://clac=
=2Ecs.columbia.edu:41782/mdb-lookup?key=3Dhello =0A        if (strncmp(requ=
estURI, "/mdb-lookup?key=3D",16) =3D=3D0 ){=0A =0A-           printf("22222=
22222222222  (%s), %d\n\n\n", requestURI, strncmp(requestURI, "/mdb-lookup?=
key=3D",16 ));=0A-=0A-=0A-        /*=0A-        FILE *fd_clntsock;  // fp_s=
ervsock=0A-        if ((fd_clntsock =3D fdopen(clntsock, "r")) =3D=3D NULL)=
 {   // fp_servsock =3D fdopen(servsock, "r") =0A-            die("fdopen f=
ailed");=0A-        }*/=0A-=0A-=0A-        // printf("why2");=0A-        //=
 fflush(stdout);=0A-=0A-=0A-        /*=0A-           int html_size; =0A-   =
        while((html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) > 0 ){=
=0A-             printf("html: \n%s", buf);=0A-           }   =0A-=0A+     =
      //printf("2222222222222222  (%s), %d\n\n\n", requestURI, strncmp(requ=
estURI, "/mdb-lookup?key=3D",16 ));=0A+      =0A+           // printf("\n(%=
s)\n",requestURI);=0A =0A-        printf("||||||||||||||||||||||||||");=0A-=
        fflush(stdout);=0A         =0A-        FILE *fd_clntsock_1;  // fp_=
servsock=0A-        if ((fd_clntsock_1 =3D fdopen(clntsock, "r")) =3D=3D NU=
LL) {   // fp_servsock =3D fdopen(servsock, "r") =0A-            die("fdope=
n failed");=0A-        }=0A-=0A-=0A-           // =0A-           while((htm=
l_size =3D fread(buf,1,sizeof(buf),fd_clntsock_1) ) !=3D 0 ){=0A-=0A-      =
         printf("html: \n%s", buf);=0A-=0A-           }*/   =0A+           =
for(int i=3D0; i<16; i++){=0A+           =0A+               requestURI++;=
=0A         =0A-=0A- =0A-      =0A-           /*=0A-           // int html_=
size ; =0A-           // int i =3D 0;=0A-=0A-=0A-           // printf("\n%l=
d, %s \n", fread(buf,1,30,fd_clntsock), buf ); =0A-           // printf("\n=
%ld\n", fread(buf,1,sizeof(buf),fd_clntsock)); =0A-=0A-           // while(=
(html_size =3D fread(buf,1,sizeof(buf),fd_clntsock) ) >  0 ){=0A-=0A-      =
     printf("_____ %d\n", i++);=0A-           fflush(stdout);=0A-          =
   printf("html: \n%s", buf);=0A-             printf("88888 %d\n", i );=0A-=
             fflush(stdout);=0A-             break;=0A-             =0A-   =
        } */ // =E4=B8=BA=E4=BB=80=E4=B9=88 fread fd_clntsock block, =E4=BD=
=86 fgets =E5=B0=B1=E5=8F=AF=E4=BB=A5=EF=BC=9F=EF=BC=9F =E8=BE=93=E5=85=A5s=
ize?  =0A-=0A-           /* // =E6=A3=80=E6=9F=A5 header=0A-           whil=
e(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){=0A-               printf(=
"\nHeaders: %s\n", buf);=0A            }=0A-           fgets(buf,sizeof(buf=
), fd_clntsock);=0A-           printf("$$$$$$$$ %s", buf);=0A-=0A-         =
  fgets(buf,sizeof(buf), fd_clntsock);=0A-           printf("*** $$$$$$$$ %=
s", buf);=0A-           */=0A-=0A-=0A+           =0A+       =0A+           =
strcat(requestURI, "\n");=0A         =0A-        // printf("\n(%s)\n",reque=
stURI);=0A-=0A-        for(int i=3D0; i<16; i++){=0A-            requestURI=
++;=0A-        }=0A-        strcat(requestURI, "\n");=0A-        // printf(=
"\n(%s)\n",requestURI);=0A-=0A+           // printf("\n(%s)\n",requestURI);=
=0A =0A+           // send    =0A =0A-        // =E6=88=91=E8=A6=81=E6=8A=
=8A=E4=B8=9C=E8=A5=BF search key send =E7=BB=99 mdb-lookup-server=0A-      =
  //=0A-=0A-=0A-        printf("\n(%s)\n",requestURI);=0A-=0A-       // =E6=
=88=91=E5=B7=B2=E7=BB=8F=E5=92=8C =E5=AE=83connect =E4=B8=8A=E4=BA=86=EF=BC=
=8C=E5=9C=A8 while loop =E5=A4=96=E9=9D=A2=0A     =0A-    //printf("=1A=1A"=
)    =0A-    if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D str=
len(requestURI)) {=0A-	die("send failed");=0A-    }=0A-=0A-=0A-=0A-    /*=
=0A-           while(fgets(buf,sizeof(buf), fd_clntsock) !=3D NULL){=0A-   =
            printf("\nHeaders: %s\n", buf);=0A+           if (send(mdb_sock=
, requestURI, strlen(requestURI), 0) !=3D strlen(requestURI)) {=0A+        =
       fclose(fd_mdb);=0A+               fclose(fd_clntsock);=0A+          =
     die("send failed");=0A            }=0A-           */=0A-           // =
fgets(buf,sizeof(buf), fd_mdb);=0A-           // printf("$$$$$$$$ %s", buf)=
;=0A-=0A-=0A-    /*=0A-           printf("\n\n 1111111111111111111111111111=
1111--------------------------\n\n");=0A-=0A-           fgets(buf,sizeof(bu=
f), fd_mdb);=0A-           printf("*** $$$$$$$$ %s", buf);=0A-=0A-         =
  printf("\n\n 22222222222222222222222222222222--------------------------\n=
\n");=0A-=0A-           fgets(buf,sizeof(buf), fd_mdb);=0A-           print=
f("*** $$$$$$$$ %s", buf);=0A-      */=0A-=0A-=0A-=0A-=0A-  /*      =0A-   =
 char html[10000];=0A-    strcpy(html,=0A-        "HTTP 200 OK\r\n"       =
=0A-        "\r\n"=0A-               =0A-        "<h1>mdb-lookup</h1>\n"=0A=
-               =0A-        "<p>\n"=0A-               =0A-        "<form me=
thod=3DGET action=3D/mdb-lookup>\n"=0A-               =0A-        "lookup: =
<input type=3Dtext name=3Dkey>\n"=0A-               =0A-        "<input typ=
e=3Dsubmit>\n"=0A-               =0A-        "</form>\n"=0A-               =
=0A-        "<p>\n"=0A-=0A-        "<p><table border>\n");=0A-=0A-=0A-     =
   printf("0000000000000000000000000000000000000000000000000000000000000000=
\n");=0A-    char row[100];=0A-    while(fgets(buf, sizeof(buf), fd_mdb)!=
=3D NULL ){=0A-=0A-        if( strcmp(buf, "\n") =3D=3D 0){=0A-            =
printf("\n\n end \n\n");=0A-            break;=0A-        }=0A-=0A-        =
snprintf(row, sizeof(row), "<tr><td> %s\n", buf);=0A-        printf("%s\n",=
 row );=0A-        strcat(html, row);=0A-=0A-      =0A-        =0A-    }=0A=
-=0A-    strcat(html, "</table>\n</body>\n</html>");=0A-=0A-=0A-    printf(=
"\n\n%s\n\n", html);=0A-*/=0A-=0A-=0A-=0A-    =0A-    strcpy(buf,=0A-      =
  "HTTP 200 OK\r\n"       =0A-        "\r\n"=0A-               =0A-        =
"<h1>mdb-lookup</h1>\n"=0A-               =0A-        "<p>\n"=0A-          =
     =0A-        "<form method=3DGET action=3D/mdb-lookup>\n"=0A-          =
     =0A-        "lookup: <input type=3Dtext name=3Dkey>\n"=0A-            =
   =0A-        "<input type=3Dsubmit>\n"=0A-               =0A-        "</f=
orm>\n"=0A-               =0A-        "<p>\n"=0A-=0A-        "<p><table bor=
der>\n");=0A-=0A+          =0A+       =0A+           fprintf(stderr, "200 O=
K\n");=0A+           strcpy(buf,=0A+                   "HTTP/1.0 200 OK\r\n=
"     =0A+                   "\r\n"=0A+                   "<h1>mdb-lookup</=
h1>\n"=0A+                   "<p>\n"=0A+                   "<form method=3D=
GET action=3D/mdb-lookup>\n"=0A+                   "lookup: <input type=3Dt=
ext name=3Dkey>\n"=0A+                   "<input type=3Dsubmit>\n"=0A+     =
              "</form>\n"=0A+                   "<p>\n"=0A+                =
   "<p><table border>\n");=0A     =0A+           if( send(clntsock, buf, st=
rlen(buf), 0) !=3D strlen(buf) ){=0A+               fclose(fd_mdb);=0A+    =
           fclose(fd_clntsock);=0A+               die("send contenct failed=
 2b)");=0A+           }=0A =0A+   =0A            =0A-    if( send(clntsock,=
 buf, strlen(buf), 0) !=3D strlen(buf) ){=0A-    =0A-        perror("send c=
ontent failed");=0A-=0A-        break;=0A-=0A-    }=0A-=0A-    char row[100=
];=0A-    while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){=0A-=0A-        i=
f( strcmp(row, "\n") =3D=3D 0){=0A-            printf("\n\n end \n\n");=0A-=
            break;=0A-        }=0A-=0A-=0A-        snprintf(buf, sizeof(buf=
), "<tr><td> %s\n", row);=0A-        //printf("%s\n", row) ;=0A-        //s=
trcat(html, row);=0A-=0A+          =0A+           =0A+           char row[1=
00];=0A+          =0A+           int even =3D 0;=0A+           =0A+        =
   while(fgets(row, sizeof(row), fd_mdb)!=3D NULL){=0A+               if( s=
trcmp(row, "\n") =3D=3D 0){=0A+                   //printf("\n\n end \n\n")=
;=0A+                   break;=0A+               }=0A =0A-    if( send(clnt=
sock, buf, strlen(buf), 0) !=3D strlen(buf) ){=0A+               if(even++%=
2 =3D=3D 0){=0A+               =0A+                   snprintf(buf, sizeof(=
buf), "<tr><td> %s\n", row);=0A+               }else{=0A+                  =
 snprintf(buf, sizeof(buf), "<tr><td  bgcolor=3Dyellow> %s\n", row);=0A+=0A=
+               }=0A+               if( send(clntsock, buf, strlen(buf), 0)=
 !=3D strlen(buf) ){=0A+                   fclose(fd_mdb);=0A+             =
      fclose(fd_clntsock);=0A+                   die("send contenct failed =
2b)");=0A+               }=0A     =0A-        perror("send content failed")=
;=0A-=0A-        break;=0A-=0A-    }=0A-    }=0A-=0A-=0A-=0A-=0A-=0A-=0A-=
=0A-=0A+           }=0A =0A =0A         continue; =0A-       }=0A-=0A-=0A-=
=0A-       =0A-       ////////////////////////////////////////////=0A+     =
  }// end if ./mdb-lookup?key=3D=0A =0A =0A =0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A=
-=0A-       // check requestURI !!!!!!!!!!!!!!!!=0A-       //=0A-       =0A=
-       // check web_root=0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A-=0A-      =0A-=
=0A-=0A-=0A-=0A-=0A-       // printf("\nweb_root %s\n", web_root);=0A-=0A-=
=0A-       // log print out=0A-       fprintf(stderr, "\"%s %s %s\" %d OK\n=
",method, requestURI, httpVersion, 200);=0A+       // part2 a) continue  //=
////////=0A =0A        // retrive the file -- requestURI=0A        // 1. ma=
ke path=0A@@ -633,7 +432,6 @@ int main(int argc, char **argv) {=0A        s=
trcat(full_path, requestURI);  // char *file_path =3D strcat(web_root, requ=
estURI);=0A =0A =0A-=0A        // int stat(const char *path, struct stat *b=
uf);=0A        // success returns 0 & fill buf, error return -1=0A        /=
/ reference: https://www.ibm.com/docs/en/i/7.3?topic=3Dssw_ibm_i_73/apis/st=
at.htm =0A@@ -643,89 +441,73 @@ int main(int argc, char **argv) {=0A =0A =
=0A =0A-       // check ending char of path is '/' or not, return 400 error=
 code    =0A+       // check ending char of path is '/', if true, concat  i=
ndex.html =0A        if(full_path_1[strlen(full_path_1)-1] =3D=3D '/' ){=0A=
-           // if ending with '/', attach index.html=0A            strcat(f=
ull_path_1, "index.html");=0A-           // printf("***********%s\n", full_=
path_1);=0A-=0A        }=0A-       /*=0A-       else{=0A-           // else=
 send 400 error code=0A-           char *html =3D cook_html(400);=0A-      =
     printf("html : \n%s",html);=0A-           if (send(clntsock, html, str=
len(html), 0) !=3D strlen(html) ){=0A-               free(html);=0A-       =
        die("send content failed");=0A-           }=0A-           free(html=
); =0A-           fclose(fd_clntsock);=0A-           continue;=0A-       }*=
/=0A-=0A-=0A-=0A+       =0A+       =0A        // if path/file exists, proce=
eds, else  =0A-       if(stat(full_path_1, &status) =3D=3D 0){ // succeeds =
-- file exists, then check directory/file=0A-=0A-           printf("*******=
***  %s", full_path_1 );=0A+       if(stat(full_path_1, &status) =3D=3D 0){=
 // succeeds -- stat return none 0,  file not exists, then check directory/=
file=0A =0A-           // full_path ends with / or not=0A-           // pri=
ntf("***********%s\n",full_path_1);=0A-           // printf("%c, %c\n", '/'=
,full_path_1[strlen(full_path_1)-1] );=0A-           // if(full_path_1[strl=
en(full_path_1)-1] =3D=3D '/' ){=0A-           //        strcat(full_path_1=
, "index.html");=0A-           //        // printf("***********%s\n", full_=
path_1);=0A-           // }=0A+           //printf("**********  %s", full_p=
ath_1 );=0A+       =0A        }else{=0A =0A            //printf("\nfail doe=
s not exists:  %s\n", full_path_1 );=0A+            fprintf(stderr, "%d Not=
 Found\n", 404); =0A+            char *html_404 =3D =0A+                "HT=
TP/1.0 404 Not Found\r\n\r\n"=0A+                "<html><body><h1>404 Not F=
ound</h1></body></html>";=0A+=0A+            if (send(clntsock, html_404, s=
trlen(html_404), 0) !=3D strlen(html_404)){=0A+                   fclose(fd=
_mdb);=0A+                   fclose(fd_clntsock);=0A+                   die=
("send content failed");=0A+            }=0A =0A-           char *html =3D =
cook_html(404);=0A-           printf("html : \n%s",html);=0A-           if =
(send(clntsock, html, strlen(html), 0) !=3D strlen(html) ){=0A-            =
   //free(html);=0A-               die("send content failed");=0A-         =
  }=0A-           free(html); =0A-           fclose(fd_clntsock);=0A-      =
     continue;=0A+            continue;=0A        } =0A =0A-       // 2. se=
nd response headers=0A+=0A+       fprintf(stderr, "200 OK\n");=0A+=0A+=0A+ =
      // 2. prepare response headers=0A        snprintf(buf, sizeof(buf), =
=0A                "HTTP/1.0 200 OK\r\n"=0A                "\r\n");=0A =0A =
       // 3. open file, read & send=0A-       // printf("\nfull_path_1: %s\=
n", full_path_1);=0A-       // printf("\nstat code: %d\n", stat(full_path_1=
, &status));=0A        FILE *file_requested =3D fopen(full_path_1, "rb");=
=0A-       if( file_requested =3D=3D NULL) =0A+       if( file_requested =
=3D=3D NULL){ =0A+               fclose(fd_mdb);=0A+               fclose(f=
d_clntsock);=0A                die("fail open file");=0A+       }=0A       =
 int size_read;=0A =0A        size_read =3D strlen(buf); // should be 19, h=
eader =0A        do{=0A-           printf("\n @@@@@@@@@@@@@@@@@@ %d \n",siz=
e_read); =0A+           //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read); =
=0A            if( send(clntsock, buf, size_read, 0) !=3D size_read ){=0A- =
              perror("send content failed");=0A-               break;=0A+  =
             fclose(fd_mdb);=0A+               fclose(fd_clntsock);=0A+    =
           die("send content failed");=0A            }=0A        }while(( s=
ize_read =3D fread(buf,1, sizeof(buf), file_requested)) > 0);=0A =0A =0A-  =
     //if(feof(file_requested) )=0A-       //    printf("file has not been =
fully read");=0A-=0A        fclose(file_requested);=0A        fclose(fd_cln=
tsock);=0A =0A-       fclose(fd_mdb);=0A-=0A-=0A+       fprintf(stdout, "\n=
");=0A     }// while (1)=0A =0A+       =0A+    =0A+=0A+ =0A+    fclose(fd_m=
db);=0A     return 0;=0A }=0A-- =0A2.17.1=0A=0A=0AFrom 58ac4b4732ec355c52b3=
dab752eb8e3684cea079 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@co=
lumbia.edu>=0ADate: Thu, 5 May 2022 22:22:07 -0400=0ASubject: [PATCH 4/7] f=
inish test, part2 ab both work on firefox=0A=0A---=0A http-server.c | 78 ++=
+++++++------------------------------------------=0A 1 file changed, 14 ins=
ertions(+), 64 deletions(-)=0A=0Adiff --git a/http-server.c b/http-server.c=
=0Aindex befd329..7387137 100644=0A--- a/http-server.c=0A+++ b/http-server.=
c=0A@@ -29,30 +29,6 @@ static void printUsage() {=0A     exit(1);=0A }=0A =
=0A-char* cook_html(int code){ // char* content=0A-=0A-    char *html =3D (=
char *) malloc(1000 * sizeof(char));=0A-=0A-    char *error_code_prompt;=0A=
-    if(code =3D=3D 501)=0A-        error_code_prompt =3D  "Not Implemented=
";=0A-    if(code =3D=3D 400)=0A-        error_code_prompt =3D  "Bad Reques=
t";=0A-    if(code =3D=3D 404)=0A-        error_code_prompt =3D "Not Found"=
;=0A-=0A-=0A-    snprintf(html, 1000,  //sizeof(html), =0A-            "HTT=
P/1.0 %d %s\r\n"=0A-            "\r\n"=0A-            //"<html>\r\n<body>\r=
\n<h1>%d %s</h1>\r\n</body>\r\n</html>\r\n",=0A-            "<html><body><h=
1>%d %s</h1></body></html>",=0A-            code, error_code_prompt, code, =
error_code_prompt);=0A-    printf("\n\n%s\\n\n", html);=0A-    return html;=
=0A-}=0A-=0A-=0A =0A =0A =0A@@ -115,7 +91,6 @@ int main(int argc, char **ar=
gv) {=0A     int mdb_sock;=0A     struct sockaddr_in mdb_serverAddr;=0A    =
 struct hostent *mdb_he;=0A-    // char buf_2[BUF_SIZE];                   =
 // necessary?=0A =0A      =0A     // get mdb-lookup server ip from mdb-ser=
ver name=0A@@ -124,15 +99,6 @@ int main(int argc, char **argv) {=0A     }=
=0A     mdb_serverIP =3D inet_ntoa(*(struct in_addr *)mdb_he->h_addr);=0A =
=0A-    /* for debugging=0A-       printf("1: %s\n", mdb_serverName);=0A-  =
     printf("2: %s\n", mdb_serverIP);=0A-       printf("3: %s\n", mdb_serve=
rPort);=0A-       printf("4: %s\n", filePath);=0A-       printf("5: %s\n", =
fname);=0A-       */=0A-=0A-=0A     // create socket=0A     if ((mdb_sock =
=3D socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {=0A 	die("socket faile=
d");=0A@@ -300,23 +266,17 @@ int main(int argc, char **argv) {=0A =0A      =
   // printf("2333333333333333333333333333"); fflush(stdout);=0A =0A-=0A-=
=0A          =0A =0A        ///////////////   part 2 b=0A =0A-=0A-         =
  //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(requestURI=
, "/mdb-lookup"));=0A-=0A        // http://clac.cs.columbia.edu:41782/mdb-l=
ookup =0A        if (strcmp(requestURI, "/mdb-lookup") =3D=3D0 ){=0A =0A   =
         //printf("111111111111111  (%s), %d\n\n\n", requestURI, strcmp(req=
uestURI, "/mdb-lookup"));=0A-       =0A            fprintf(stderr, "200 OK\=
n");=0A            const char *form =3D=0A-               "HTTP 200 OK\r\n"=
=0A+               "HTTP/1.0 200 OK\r\n"=0A                "\r\n"=0A       =
         "<h1>mdb-lookup</h1>\n"=0A                "<p>\n"=0A@@ -333,35 +29=
3,24 @@ int main(int argc, char **argv) {=0A            }=0A =0A           =
 //printf("\n\n send, you should see search page  \n\n");=0A+           fcl=
ose(fd_clntsock);=0A            continue; =0A       =0A        }=0A =0A-=0A=
-=0A       =0A        // http://clac.cs.columbia.edu:41782/mdb-lookup?key=
=3Dhello =0A        if (strncmp(requestURI, "/mdb-lookup?key=3D",16) =3D=3D=
0 ){=0A =0A            //printf("2222222222222222  (%s), %d\n\n\n", request=
URI, strncmp(requestURI, "/mdb-lookup?key=3D",16 ));=0A-      =0A          =
  // printf("\n(%s)\n",requestURI);=0A-=0A-        =0A            for(int i=
=3D0; i<16; i++){=0A-           =0A                requestURI++;=0A-       =
 =0A            }=0A-           =0A-       =0A            strcat(requestURI=
, "\n");=0A         =0A            // printf("\n(%s)\n",requestURI);=0A-=0A=
            // send    =0A-=0A-    =0A            if (send(mdb_sock, reques=
tURI, strlen(requestURI), 0) !=3D strlen(requestURI)) {=0A                f=
close(fd_mdb);=0A                fclose(fd_clntsock);=0A@@ -388,14 +337,8 @=
@ int main(int argc, char **argv) {=0A                die("send contenct fa=
iled 2b)");=0A            }=0A =0A-   =0A-           =0A-          =0A-    =
       =0A            char row[100];=0A-          =0A            int even =
=3D 0;=0A-           =0A            while(fgets(row, sizeof(row), fd_mdb)!=
=3D NULL){=0A                if( strcmp(row, "\n") =3D=3D 0){=0A           =
         //printf("\n\n end \n\n");=0A@@ -417,8 +360,8 @@ int main(int argc=
, char **argv) {=0A     =0A            }=0A =0A-=0A-        continue; =0A+ =
          fclose(fd_clntsock);=0A+           continue; =0A        }// end i=
f ./mdb-lookup?key=3D=0A =0A =0A@@ -454,8 +397,15 @@ int main(int argc, cha=
r **argv) {=0A        =0A        }else{=0A =0A+           printf("*********=
*  %s", full_path_1 );=0A+           fprintf(stderr, "%d Not Found\n", 404)=
; =0A+           if( strcmp(full_path,"/mnt/disks/students221/yz4004/html/c=
s3157/tng/favicon.ico" ) =3D=3D 0 ){=0A+=0A+               break;=0A+      =
     }=0A+=0A+=0A            //printf("\nfail does not exists:  %s\n", full=
_path_1 );=0A-            fprintf(stderr, "%d Not Found\n", 404); =0A      =
       char *html_404 =3D =0A                 "HTTP/1.0 404 Not Found\r\n\r=
\n"=0A                 "<html><body><h1>404 Not Found</h1></body></html>";=
=0A@@ -492,6 +442,7 @@ int main(int argc, char **argv) {=0A            //pr=
intf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read); =0A            if( send(clnt=
sock, buf, size_read, 0) !=3D size_read ){=0A                fclose(fd_mdb)=
;=0A+               fclose(file_requested);=0A                fclose(fd_cln=
tsock);=0A                die("send content failed");=0A            }=0A@@ =
-501,10 +452,9 @@ int main(int argc, char **argv) {=0A        fclose(file_r=
equested);=0A        fclose(fd_clntsock);=0A =0A-       fprintf(stdout, "\n=
");=0A+       //fprintf(stdout, "\n");=0A     }// while (1)=0A =0A-       =
=0A     =0A =0A  =0A-- =0A2.17.1=0A=0A=0AFrom edbc31cfe47c1bfb59c17b691baed=
94f59b45d78 Mon Sep 17 00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.ed=
u>=0ADate: Thu, 5 May 2022 22:24:34 -0400=0ASubject: [PATCH 5/7] modify REA=
DME=0A=0A---=0A README.txt | 7 +++++++=0A 1 file changed, 7 insertions(+)=
=0A=0Adiff --git a/README.txt b/README.txt=0Aindex 66dfd3e..e571053 100644=
=0A--- a/README.txt=0A+++ b/README.txt=0A@@ -9,3 +9,10 @@ The description s=
hould indicate whether your solution for the part is=0A working or not.  Yo=
u may also want to include anything else you would=0A like to communicate t=
o the grader such as extra functionalities you=0A implemented or how you tr=
ied to fix your non-working code.=0A+=0A+=0A+Yixuan Zou=0A+yz4004=0A+lab7=
=0A+=0A+part2 a) b) both work on firefox.=0A-- =0A2.17.1=0A=0A=0AFrom 2195a=
ddaa7c9f6178a534a0e51477319b2fa53fc Mon Sep 17 00:00:00 2001=0AFrom: Yixuan=
_Zou <yz4004@columbia.edu>=0ADate: Thu, 5 May 2022 23:44:57 -0400=0ASubject=
: [PATCH 6/7] modify error prompt=0A=0A---=0A http-server.c | 79 ++++++++++=
+++++++++++++++++++++++++----------------=0A 1 file changed, 54 insertions(=
+), 25 deletions(-)=0A=0Adiff --git a/http-server.c b/http-server.c=0Aindex=
 7387137..ec99309 100644=0A--- a/http-server.c=0A+++ b/http-server.c=0A@@ -=
142,7 +142,7 @@ int main(int argc, char **argv) {=0A =0A         if ((clnts=
ock =3D accept(servsock,=0A                         (struct sockaddr * ) &c=
lntaddr, &clntlen)) < 0){=0A-            //perror("next clinet");=0A+      =
      perror("clinet crash");=0A             //die("accept fail");=0A      =
       continue; =0A         }=0A@@ -164,11 +164,16 @@ int main(int argc, c=
har **argv) {=0A         char requestLine[1000]; =0A         if(fgets(reque=
stLine, sizeof(requestLine), fd_clntsock) =3D=3D NULL ){=0A             // =
fail to read request line, (maybe clnt crash/close connection -- fail to se=
nd request), skip current clnt to next one.=0A-            fprintf(stderr, =
"clnt crashes");=0A-            //fclose(fd_clntsock); no need=0A+         =
   // fprintf(stderr, "clnt crashes");=0A+            fclose(fd_clntsock); =
//no need?=0A             continue;=0A         }=0A =0A+       // check fge=
ts error =0A+       if (ferror(fd_clntsock)){=0A+           perror("fd_clnt=
sock error");=0A+       }=0A+=0A         // parse browser http request line=
=0A         char *token_separators =3D "\t \r\n"; // tab, space, new line=
=0A         char *method =3D strtok(requestLine, token_separators);=0A@@ -2=
17,9 +222,10 @@ int main(int argc, char **argv) {=0A =0A             //prin=
tf("html : \n%s",html);=0A             if (send(clntsock, html_501, strlen(=
html_501), 0) !=3D strlen(html_501)){=0A-               fclose(fd_mdb);=0A+=
               //fclose(fd_mdb);=0A                fclose(fd_clntsock); =0A=
-               die("send content failed");=0A+               //die("send c=
ontent failed");=0A+               perror("send content failed");=0A       =
      }=0A =0A             continue;=0A@@ -234,9 +240,10 @@ int main(int ar=
gc, char **argv) {=0A                 "<html><body><h1>501 Not Implemented<=
/h1></body></html>";=0A =0A             if (send(clntsock, html_501, strlen=
(html_501), 0) !=3D strlen(html_501)){=0A-               fclose(fd_mdb);=0A=
+               //fclose(fd_mdb);=0A                fclose(fd_clntsock);=0A=
-               die("send content failed");=0A+               //die("send c=
ontent failed");=0A+               perror("send content failed");=0A       =
      }=0A =0A             continue;=0A@@ -255,9 +262,10 @@ int main(int ar=
gc, char **argv) {=0A                 "<html><body><h1>400 Bad Request</h1>=
</body></html>";=0A =0A             if (send(clntsock, html_400, strlen(htm=
l_400), 0) !=3D strlen(html_400)){=0A-               fclose(fd_mdb);=0A+   =
            //fclose(fd_mdb);=0A                fclose(fd_clntsock);=0A-   =
            die("send content failed");=0A+               //die("send conte=
nt failed");=0A+               perror("send content failed");=0A           =
  }=0A =0A             continue;=0A@@ -287,9 +295,10 @@ int main(int argc, =
char **argv) {=0A                "<p>\n";=0A =0A            if (send(clntso=
ck, form, strlen(form), 0) !=3D strlen(form) ){=0A-               fclose(fd=
_mdb);=0A+               //fclose(fd_mdb);=0A                fclose(fd_clnt=
sock);=0A-               die("send content failed");=0A+               //di=
e("send content failed");=0A+               perror("send content failed");=
=0A            }=0A =0A            //printf("\n\n send, you should see sear=
ch page  \n\n");=0A@@ -312,9 +321,10 @@ int main(int argc, char **argv) {=
=0A            // printf("\n(%s)\n",requestURI);=0A            // send    =
=0A            if (send(mdb_sock, requestURI, strlen(requestURI), 0) !=3D s=
trlen(requestURI)) {=0A-               fclose(fd_mdb);=0A+               //=
fclose(fd_mdb);=0A                fclose(fd_clntsock);=0A-               di=
e("send failed");=0A+               //die("send failed");=0A+              =
 perror("send failed");=0A            }=0A           =0A        =0A@@ -332,=
9 +342,10 @@ int main(int argc, char **argv) {=0A                    "<p><t=
able border>\n");=0A     =0A            if( send(clntsock, buf, strlen(buf)=
, 0) !=3D strlen(buf) ){=0A-               fclose(fd_mdb);=0A+             =
  //fclose(fd_mdb);=0A                fclose(fd_clntsock);=0A-             =
  die("send contenct failed 2b)");=0A+               //die("send contenct f=
ailed 2b)");=0A+               perror("send content failed");=0A           =
 }=0A =0A            char row[100];=0A@@ -353,13 +364,18 @@ int main(int ar=
gc, char **argv) {=0A =0A                }=0A                if( send(clnts=
ock, buf, strlen(buf), 0) !=3D strlen(buf) ){=0A-                   fclose(=
fd_mdb);=0A+                   //fclose(fd_mdb);=0A                    fclo=
se(fd_clntsock);=0A-                   die("send contenct failed 2b)");=0A+=
                   //die("send contenct failed 2b)");=0A+                  =
 perror("send content failed");=0A                }=0A     =0A+           }=
 // end while, fget from fb_mdb=0A+       =0A+           // check fgets fd_=
mdb =0A+           if (ferror(fd_mdb)){=0A+               perror("fgets fd_=
mdb error");=0A            }=0A-=0A            fclose(fd_clntsock);=0A     =
       continue; =0A        }// end if ./mdb-lookup?key=3D=0A@@ -397,7 +413=
,7 @@ int main(int argc, char **argv) {=0A        =0A        }else{=0A =0A-=
           printf("**********  %s", full_path_1 );=0A+           //printf("=
**********  %s", full_path_1 );=0A            fprintf(stderr, "%d Not Found=
\n", 404); =0A            if( strcmp(full_path,"/mnt/disks/students221/yz40=
04/html/cs3157/tng/favicon.ico" ) =3D=3D 0 ){=0A =0A@@ -411,9 +427,10 @@ in=
t main(int argc, char **argv) {=0A                 "<html><body><h1>404 Not=
 Found</h1></body></html>";=0A =0A             if (send(clntsock, html_404,=
 strlen(html_404), 0) !=3D strlen(html_404)){=0A-                   fclose(=
fd_mdb);=0A+                   //fclose(fd_mdb);=0A                    fclo=
se(fd_clntsock);=0A-                   die("send content failed");=0A+     =
              //die("send content failed");=0A+                   perror("s=
end content failed");=0A             }=0A =0A             continue;=0A@@ -4=
41,14 +458,27 @@ int main(int argc, char **argv) {=0A        do{=0A        =
    //printf("\n @@@@@@@@@@@@@@@@@@ %d \n",size_read); =0A            if( s=
end(clntsock, buf, size_read, 0) !=3D size_read ){=0A-               fclose=
(fd_mdb);=0A+               //fclose(fd_mdb);=0A                fclose(file=
_requested);=0A-               fclose(fd_clntsock);=0A-               die("=
send content failed");=0A+               perror("send content failed");=0A+=
               break;=0A+               //fclose(fd_clntsock);=0A+         =
      //die("send content failed");=0A            }=0A        }while(( size=
_read =3D fread(buf,1, sizeof(buf), file_requested)) > 0);=0A =0A =0A+     =
  // fread() returns 0 on EOF or on error=0A+       // so we need to check =
if there was an error.=0A+       if (ferror(file_requested)){=0A+          =
 //fclose(fd_mdb);=0A+           fclose(fd_clntsock);=0A+           //die("=
fread failed");=0A+           perror("fread failed");=0A+       }=0A+   =0A=
+       =0A+=0A        fclose(file_requested);=0A        fclose(fd_clntsock=
);=0A =0A@@ -456,7 +486,6 @@ int main(int argc, char **argv) {=0A     }// w=
hile (1)=0A =0A     =0A-=0A  =0A     fclose(fd_mdb);=0A     return 0;=0A-- =
=0A2.17.1=0A=0A=0AFrom 1117997b16556f63572b46290f26a6665eb50f62 Mon Sep 17 =
00:00:00 2001=0AFrom: Yixuan_Zou <yz4004@columbia.edu>=0ADate: Thu, 5 May 2=
022 23:48:50 -0400=0ASubject: [PATCH 7/7] modify error prompt=0A=0A---=0A h=
ttp-server.c | 2 +-=0A 1 file changed, 1 insertion(+), 1 deletion(-)=0A=0Ad=
iff --git a/http-server.c b/http-server.c=0Aindex ec99309..a09df07 100644=
=0A--- a/http-server.c=0A+++ b/http-server.c=0A@@ -459,7 +459,7 @@ int main=
(int argc, char **argv) {=0A            //printf("\n @@@@@@@@@@@@@@@@@@ %d =
\n",size_read); =0A            if( send(clntsock, buf, size_read, 0) !=3D s=
ize_read ){=0A                //fclose(fd_mdb);=0A-               fclose(fi=
le_requested);=0A+               //fclose(file_requested);=0A              =
  perror("send content failed");=0A                break;=0A               =
 //fclose(fd_clntsock);=0A-- =0A2.17.1=0A=0A
--envbJBWh7q8WU6mo--

